---
title: Lv1：main函数 | 编译原理
description: "PKU编译原理实践课程"
pubDate: 2025 08 14
categories: 
  - tech
tags:
  - compiler
  - rust
---
本课程的编译对象 SysY语言是一种简单版的C语言.

作为一种编程语言,它有如下规范:
1. 词法规范
	- 标识符`IDENT`
	- 数值常量整型数`INT_CONST`
	- 注释`// /* */`

2. 语法规范
	- 开始符号为 `CompUnit`
    
	 ```ebnf
	CompUnit ::= FuncDef;
	FuncDef ::= FuncType IDENT "()" Block;
	FuncType ::= "int";
	
	Block ::= "{}" Stmt;
	Stmt ::= "return" Number ";";
	Number ::= INT_CONST ;
	```

3. 语义规范
`INT_CONST`的范围为$[0,2^{31}-1]$, 不包含负号.

可以看出, SysY语言是简单版的C语言.

## 编译器的结构
编译器把源代码变成可执行文件的过程:
1. 编译: 将源代码编译为汇编代码(assembly)
2. 汇编: 将汇编代码汇编为目标文件(obj file)
3. 链接: 将目标文件链接为可执行文件(executable)

本课程中实现的编译器, 只涉及上述第一点.即将SysY源代码编译成RISC-V汇编语言.在这种意义之下, 编译器通常由以下几个部分组成:

- **前端:** 通过词法分析和语法分析, 将源代码解析成抽象语法树 (abstract syntax tree, AST). 通过语义分析, 扫描抽象语法树, 检查其是否存在语义错误.
- **中端:** 将抽象语法树转换为中间表示 (intermediate representation, IR), 并在此基础上完成一些机器无关优化.
- **后端:** 将中间表示转换为目标平台的汇编代码, 并在此基础上完成一些机器相关优化.

### 词法分析阶段
词法分析的作用, 是把字节流转换为单词流 (token stream). 词法分析器 (lexer) 会按照某种规则读取文件, 并将文件的内容拆分成一个个 token 作为输出, 传递给语法分析器 (parser). 同时, lexer 还会忽略文件里的一些无意义的内容, 比如空格, 换行符和注释.

而语法分析的目的, 按照程序的语法规则, 将输入的 token 流变成程序的 AST.


### 语义分析阶段
语义分析阶段, 编译器通常会:

- **建立符号表**, 跟踪程序里变量的声明和使用, 确定程序在某处用到了哪一个变量, 同时也可发现变量重复定义/引用未定义变量之类的错误.
- **进行类型检查**, 确定程序中是否存在诸如 “对整数变量进行数组访问” 这种类型问题. 同时标注程序中表达式的类型, 以便进行后续的生成工作. 对于某些编程语言 (例如 C++11 之后的 C++, Rust 等等), 编译器还会进行类型推断.
- **进行必要的编译期计算**. SysY 中支持使用常量表达式作为数组定义时的长度, 而我们在生成 IR 之前, 必须知道数组的长度 (SysY 不支持 [VLA](https://en.wikipedia.org/wiki/Variable-length_array)), 这就要求编译器必须能在编译的时候算出常量表达式的值, 同时对那些无法计算的常量表达式报错. 对于某些支持元编程的语言, 这一步可能会非常复杂.

至此, 我们就能得到一个语法正确, 语义清晰的 AST 表示了.

### IR生成
编译器通常会将 AST 转换为另一种形式的数据结构, 我们把它称作 IR. IR 的抽象层次比 AST 更低, 但又不至于低到汇编代码的程度. 在此基础上, 无论是直接把 IR 进一步转换为汇编代码, 还是在 IR 之上做出一些优化, 都相对更容易.

有了 IR 的存在, 我们也可以大幅降低编译器的开发成本: 假设我们想开发 MM 种语言的编译器, 要求它们能把输入编译成 NN 种指令系统的目标代码, 在没有统一的 IR 的情况下, 我们需要开发 M×NM×N 个相关模块. 如果我们先把所有源语言都转换到同一种 IR, 然后再将这种 IR 翻译为不同的目标代码, 我们就只需要开发 M+NM+N 个相关模块.

### 目标代码生成

编译器进行的最后一步操作, 就是将 IR 转换为目标代码, 也就是目标指令系统的汇编代码. 通常情况下, 这一步通常要做以下几件事:

1. **指令选择:** 决定 IR 中的指令应该被翻译为哪些目标指令系统的指令. 例如前文的 Koopa IR 程序中出现的 `lt` 指令可以被翻译为 RISC-V 中的 `slt`/`slti` 指令.
2. **寄存器分配:** 决定 IR 中的值和指令系统中寄存器的对应关系. 例如前文的 Koopa IR 程序中的 `@x`, `%cond`, `%0` 等等, 它们最终可能会被放在 RISC-V 的某些寄存器中. 由于指令系统中寄存器的数量通常是有限的 (RISC-V 中只有 32 个整数通用寄存器, 且它们并不都能用来存放数据), 某些值还可能会被分配在内存中.
3. **指令调度:** 决定 IR 生成的指令序列最终的顺序如何. 我们通常希望编译器能生成一个最优化的指令序列, 它可以最大程度地利用目标平台的微结构特性, 这样生成的程序的性能就会很高. 例如编译器可能会穿插调度访存指令和其他指令, 以求减少访存导致的停顿.


## 词法/语法分析初见
EBNF 中还会出现一些别的记法:

- `A | B` 表示可以推导出 `A`, 或者 `B`.
- `[...]` 表示方括号内包含的项可被重复 0 次或 1 次.
- `{...}` 表示花括号内包含的项可被重复 0 次或多次.

在Rust中, lalrpop来帮助生成词法/语法分析器. lalrpop是一个LR/LALR分析器生成器.

为了使用lalrpop, 我运行了
```shell
cargo add lalrpop --features=lexer
```
块注释(/\* \*/)的正则表达式: `\/\*[^\/]*\*\/`

阅读了一下教程的代码, 在虚拟机中运行了一下, 发现报错Rust版本不匹配.所以`cargo init`应在虚拟机里面执行.把`edition`改为2021,`version`改为3后恢复了正常.编译时间比较久,然后就可以看到输出了.

## 解析`main`函数
上一节我们借助词法/语法分析器解析了`main`函数,但是只能把输入的源代码转换成, 呃, 源代码, 而不是 AST.

### 设计AST
我在src/下面创建了 `ast.rs`, 里面放置了一些结构体, 然后创建 `lib.rs`暴露 `ast.rs`

重要的是在 `sysy.lalrpop`里面使用这些新结构体,一定要在第一行前面加上
`use compiler::ast::*;`
教程没有提这行加在哪里,我试了很多地方😭,第二行也不行,

> 不得不说编译好慢啊

这样我们得到了AST: 
```
CompUnit {
    func_def: FuncDef {
        func_type: Int,
        id: "main",
        block: Block {
            stmt: Stmt {
                num: 3,
            },
        },
    },
}
```
很好!

## Lv1.4 IR生成
我们已经有了AST,现在要变成Koopa IR

### 语义分析
> 在课程实践中, 所有的测试用例均为符合语法/语义规范的 SysY 程序. **我们不要求你编写的编译器具备处理语法/语义错误的能力, 也不会考察这些内容.** 但我们希望学有余力的同学, 能够在自己的编译器中检查这些问题, 并对其作出合适的处理, 比如像 `clang` 或 `rustc` 一样, 给出精确到行列的错误信息, 甚至具备忽略错误继续扫描, 以及对错误给出修改建议的高级功能.

🤔

### Koopa IR基础
本章中我们只会用到函数返回指令和整数常量, 也就是 `Return` 和 `Integer`.

这个程序写出来长这样:

```
fun @main(): i32 {  // main 函数的定义
%entry:             // 入口基本块
  ret 0             // return 0
}
```

### 生成Koopa IR
为了生成字符串形式的 `Koopa IR`, 我决定调用`Koopa IR`框架提供的接口.

> 这真是掌握Rust的学生的福利!有接口当然是使用接口了,省去了一大堆文本字符串处理.


研究了一番[Koopa IR文档](https://docs.rs/koopa/latest/koopa/ir/index.html)后, 我写出了针对本章要求的AST -> Koopa IR转换.

在虚拟机中执行测试:
```shell
autotest -koopa -s lv1 /root/compiler
```

终端如下输出:
```
    Finished release [optimized] target(s) in 17.95s
running test "0_main" ... PASSED
running test "1_comments" ... PASSED
running test "2_int_dec" ... PASSED
running test "3_int_oct" ... PASSED
running test "4_int_hex" ... PASSED
running test "5_compact" ... PASSED
running test "6_whitespaces" ... PASSED
PASSED (7/7)
```

通过了!

